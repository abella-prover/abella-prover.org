
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Abella: Specification "cc". - Details</title>
<link href="http://abella-prover.org/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="http://abella-prover.org/images/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="http://abella-prover.org/images/favicon.ico"
        type="image/x-icon" />
</head>

<body>

<div id="logo-small">
<a href="http://abella-prover.org/index.html">
<img src="http://abella-prover.org/images/logo-small.png"/>
</a>
</div>

<div class="section">
Welcome to Abella 2.0.2-dev
<a name="1"></a>
<pre class="code">
Abella < <b>Specification "cc".</b>
Reading specification "cc"
</pre>
<a name="2"></a>
<pre class="code">
Abella < <b>Close nat, tm, tm_list, ctm, ctm_list, ty.</b>
</pre>
<a name="3"></a>
<pre class="code">
Abella < <b>Theorem eq_ml_member : 
forall A B X, A = B -> {ml_member X A} -> {ml_member X B}.</b>
</pre>
<a name="4"></a>
<pre>


  ============================
   forall A B X, A = B -> {ml_member X A} -> {ml_member X B}

eq_ml_member < <b>intros.</b>
</pre>
<a name="5"></a>
<pre>

  Variables: A, B, X
  H1 : A = B
  H2 : {ml_member X A}
  ============================
   {ml_member X B}

eq_ml_member < <b>case H1.</b>
</pre>
<a name="6"></a>
<pre>

  Variables: A, B, X
  H2 : {ml_member X B}
  ============================
   {ml_member X B}

eq_ml_member < <b>search.</b>
Proof completed.
</pre>
<a name="7"></a>
<pre class="code">
Abella < <b>Theorem eq_inst_eval : 
forall A B C V, nabla x, A x = B x -> {evalcc (B C) V} -> {evalcc (A C) V}.</b>
</pre>
<a name="8"></a>
<pre>


  ============================
   forall A B C V, nabla x, A x = B x -> {evalcc (B C) V} -> {evalcc (A C) V}

eq_inst_eval < <b>intros.</b>
</pre>
<a name="9"></a>
<pre>

  Variables: A, B, C, V
  H1 : A n1 = B n1
  H2 : {evalcc (B C) V}
  ============================
   {evalcc (A C) V}

eq_inst_eval < <b>case H1.</b>
</pre>
<a name="10"></a>
<pre>

  Variables: A, B, C, V
  H2 : {evalcc (B C) V}
  ============================
   {evalcc (B C) V}

eq_inst_eval < <b>search.</b>
Proof completed.
</pre>
<a name="11"></a>
<pre class="code">
Abella < <b>Define tname : tm -> prop by 
nabla n, tname n.</b>
</pre>
<a name="12"></a>
<pre class="code">
Abella < <b>Define ctname : ctm -> prop by 
nabla n, ctname n.</b>
</pre>
<a name="13"></a>
<pre class="code">
Abella < <b>Define fresh_tm : tm -> tm -> prop by 
nabla x, fresh_tm x M.</b>
</pre>
<a name="14"></a>
<pre class="code">
Abella < <b>Define fresh_tm_tm : tm -> (tm -> tm) -> prop by 
nabla x, fresh_tm_tm x M.</b>
</pre>
<a name="15"></a>
<pre class="code">
Abella < <b>Define fresh_ctm_ctm : ctm -> (ctm -> ctm) -> prop by 
nabla x, fresh_ctm_ctm x M.</b>
</pre>
<a name="16"></a>
<pre class="code">
Abella < <b>Define fresh_ctm_ml : ctm -> ctm -> (ctm -> map_list) -> prop by 
nabla x, fresh_ctm_ml x (M x) N.</b>
</pre>
<a name="17"></a>
<pre class="code">
Abella < <b>Define fresh_smap_list : tm -> smap_list -> prop by 
fresh_smap_list M sml_nil;
nabla x, fresh_smap_list M (sml_cons (smap x V) (ML x)) := nabla x, fresh_smap_list M (ML x).</b>
</pre>
<a name="18"></a>
<pre class="code">
Abella < <b>Define fresh_tmctx : tm -> olist -> prop by 
nabla x, fresh_tmctx x L.</b>
</pre>
<a name="19"></a>
<pre class="code">
Abella < <b>Theorem member_prune_tm : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').</b>
</pre>
<a name="20"></a>
<pre>


  ============================
   forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

member_prune_tm < <b>induction on 1.</b>
</pre>
<a name="21"></a>
<pre>


  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  ============================
   forall M L, nabla x, member (M x) L @ -> (exists M', M = y\M')

member_prune_tm < <b>intros.</b>
</pre>
<a name="22"></a>
<pre>

  Variables: M, L
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H1 : member (M n1) L @
  ============================
   exists M', M = y\M'

member_prune_tm < <b>case H1.</b>
</pre>
<a name="23"></a>
<pre>
Subgoal 1:

  Variables: M, L, L3, L2
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  ============================
   exists M', z1\L2 = y\M'

Subgoal 2 is:
 exists M', M = y\M'

member_prune_tm < <b>search.</b>
</pre>
<a name="24"></a>
<pre>
Subgoal 2:

  Variables: M, L, L3, L2
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H2 : member (M n1) L3 *
  ============================
   exists M', M = y\M'

member_prune_tm < <b>apply IH to H2.</b>
</pre>
<a name="25"></a>
<pre>
Subgoal 2:

  Variables: M, L, L3, L2, M'
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H2 : member M' L3 *
  ============================
   exists M'1, z1\M' = y\M'1

member_prune_tm < <b>search.</b>
Proof completed.
</pre>
<a name="26"></a>
<pre class="code">
Abella < <b>Theorem member_prune_ctm : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').</b>
</pre>
<a name="27"></a>
<pre>


  ============================
   forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

member_prune_ctm < <b>induction on 1.</b>
</pre>
<a name="28"></a>
<pre>


  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  ============================
   forall M L, nabla x, member (M x) L @ -> (exists M', M = y\M')

member_prune_ctm < <b>intros.</b>
</pre>
<a name="29"></a>
<pre>

  Variables: M, L
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H1 : member (M n1) L @
  ============================
   exists M', M = y\M'

member_prune_ctm < <b>case H1.</b>
</pre>
<a name="30"></a>
<pre>
Subgoal 1:

  Variables: M, L, L3, L2
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  ============================
   exists M', z1\L2 = y\M'

Subgoal 2 is:
 exists M', M = y\M'

member_prune_ctm < <b>search.</b>
</pre>
<a name="31"></a>
<pre>
Subgoal 2:

  Variables: M, L, L3, L2
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H2 : member (M n1) L3 *
  ============================
   exists M', M = y\M'

member_prune_ctm < <b>apply IH to H2.</b>
</pre>
<a name="32"></a>
<pre>
Subgoal 2:

  Variables: M, L, L3, L2, M'
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H2 : member M' L3 *
  ============================
   exists M'1, z1\M' = y\M'1

member_prune_ctm < <b>search.</b>
Proof completed.
</pre>
<a name="33"></a>
<pre class="code">
Abella < <b>Theorem mem_of_absurd : 
forall T L, nabla x, member (of x T) L -> false.</b>
</pre>
<a name="34"></a>
<pre>


  ============================
   forall T L, nabla x, member (of x T) L -> false

mem_of_absurd < <b>induction on 1.</b>
</pre>
<a name="35"></a>
<pre>


  IH : forall T L, nabla x, member (of x T) L * -> false
  ============================
   forall T L, nabla x, member (of x T) L @ -> false

mem_of_absurd < <b>intros.</b>
</pre>
<a name="36"></a>
<pre>

  Variables: T, L
  IH : forall T L, nabla x, member (of x T) L * -> false
  H1 : member (of n1 T) L @
  ============================
   false

mem_of_absurd < <b>case H1.</b>
</pre>
<a name="37"></a>
<pre>

  Variables: T, L, L3, L2
  IH : forall T L, nabla x, member (of x T) L * -> false
  H2 : member (of n1 T) L3 *
  ============================
   false

mem_of_absurd < <b>apply IH to H2.</b>
Proof completed.
</pre>
<a name="38"></a>
<pre class="code">
Abella < <b>Theorem mem_of_absurd' : 
forall T L, nabla x, member (cof x T) L -> false.</b>
</pre>
<a name="39"></a>
<pre>


  ============================
   forall T L, nabla x, member (cof x T) L -> false

mem_of_absurd' < <b>induction on 1.</b>
</pre>
<a name="40"></a>
<pre>


  IH : forall T L, nabla x, member (cof x T) L * -> false
  ============================
   forall T L, nabla x, member (cof x T) L @ -> false

mem_of_absurd' < <b>intros.</b>
</pre>
<a name="41"></a>
<pre>

  Variables: T, L
  IH : forall T L, nabla x, member (cof x T) L * -> false
  H1 : member (cof n1 T) L @
  ============================
   false

mem_of_absurd' < <b>case H1.</b>
</pre>
<a name="42"></a>
<pre>

  Variables: T, L, L3, L2
  IH : forall T L, nabla x, member (cof x T) L * -> false
  H2 : member (cof n1 T) L3 *
  ============================
   false

mem_of_absurd' < <b>apply IH to H2.</b>
Proof completed.
</pre>
<a name="43"></a>
<pre class="code">
Abella < <b>Theorem sml_mem_absurd : 
forall V ML, nabla x, {sml_member (smap x (V x)) ML} -> false.</b>
</pre>
<a name="44"></a>
<pre>


  ============================
   forall V ML, nabla x, {sml_member (smap x (V x)) ML} -> false

sml_mem_absurd < <b>induction on 1.</b>
</pre>
<a name="45"></a>
<pre>


  IH : forall V ML, nabla x, {sml_member (smap x (V x)) ML}* -> false
  ============================
   forall V ML, nabla x, {sml_member (smap x (V x)) ML}@ -> false

sml_mem_absurd < <b>intros.</b>
</pre>
<a name="46"></a>
<pre>

  Variables: V, ML
  IH : forall V ML, nabla x, {sml_member (smap x (V x)) ML}* -> false
  H1 : {sml_member (smap n1 (V n1)) ML}@
  ============================
   false

sml_mem_absurd < <b>case H1.</b>
</pre>
<a name="47"></a>
<pre>

  Variables: V, ML, ML2, ML1
  IH : forall V ML, nabla x, {sml_member (smap x (V x)) ML}* -> false
  H2 : {sml_member (smap n1 (V n1)) ML2}*
  ============================
   false

sml_mem_absurd < <b>apply IH to H2.</b>
Proof completed.
</pre>
<a name="48"></a>
<pre class="code">
Abella < <b>Theorem cml_mem_absurd : 
forall V ML, nabla x, {cml_member (cmap x (V x)) ML} -> false.</b>
</pre>
<a name="49"></a>
<pre>


  ============================
   forall V ML, nabla x, {cml_member (cmap x (V x)) ML} -> false

cml_mem_absurd < <b>induction on 1.</b>
</pre>
<a name="50"></a>
<pre>


  IH : forall V ML, nabla x, {cml_member (cmap x (V x)) ML}* -> false
  ============================
   forall V ML, nabla x, {cml_member (cmap x (V x)) ML}@ -> false

cml_mem_absurd < <b>intros.</b>
</pre>
<a name="51"></a>
<pre>

  Variables: V, ML
  IH : forall V ML, nabla x, {cml_member (cmap x (V x)) ML}* -> false
  H1 : {cml_member (cmap n1 (V n1)) ML}@
  ============================
   false

cml_mem_absurd < <b>case H1.</b>
</pre>
<a name="52"></a>
<pre>

  Variables: V, ML, ML2, ML1
  IH : forall V ML, nabla x, {cml_member (cmap x (V x)) ML}* -> false
  H2 : {cml_member (cmap n1 (V n1)) ML2}*
  ============================
   false

cml_mem_absurd < <b>apply IH to H2.</b>
Proof completed.
</pre>
<a name="53"></a>
<pre class="code">
Abella < <b>Theorem ml_member_prune1 : 
forall E E' Map, nabla x, {ml_member (map (E x) E') Map} -> (exists E1,
  E = y\E1).</b>
</pre>
<a name="54"></a>
<pre>


  ============================
   forall E E' Map, nabla x, {ml_member (map (E x) E') Map} -> (exists E1,
     E = y\E1)

ml_member_prune1 < <b>induction on 1.</b>
</pre>
<a name="55"></a>
<pre>


  IH : forall E E' Map, nabla x, {ml_member (map (E x) E') Map}* ->
         (exists E1, E = y\E1)
  ============================
   forall E E' Map, nabla x, {ml_member (map (E x) E') Map}@ -> (exists E1,
     E = y\E1)

ml_member_prune1 < <b>intros.</b>
</pre>
<a name="56"></a>
<pre>

  Variables: E, E', Map
  IH : forall E E' Map, nabla x, {ml_member (map (E x) E') Map}* ->
         (exists E1, E = y\E1)
  H1 : {ml_member (map (E n1) E') Map}@
  ============================
   exists E1, E = y\E1

ml_member_prune1 < <b>case H1.</b>
</pre>
<a name="57"></a>
<pre>
Subgoal 1:

  Variables: E, E', Map, Map2, Map1
  IH : forall E E' Map, nabla x, {ml_member (map (E x) E') Map}* ->
         (exists E1, E = y\E1)
  ============================
   exists E1, z1\Map1 = y\E1

Subgoal 2 is:
 exists E1, E = y\E1

ml_member_prune1 < <b>search.</b>
</pre>
<a name="58"></a>
<pre>
Subgoal 2:

  Variables: E, E', Map, Map2, Map1
  IH : forall E E' Map, nabla x, {ml_member (map (E x) E') Map}* ->
         (exists E1, E = y\E1)
  H2 : {ml_member (map (E n1) E') Map2}*
  ============================
   exists E1, E = y\E1

ml_member_prune1 < <b>apply IH to H2.</b>
</pre>
<a name="59"></a>
<pre>
Subgoal 2:

  Variables: E, E', Map, Map2, Map1, E1
  IH : forall E E' Map, nabla x, {ml_member (map (E x) E') Map}* ->
         (exists E1, E = y\E1)
  H2 : {ml_member (map E1 E') Map2}*
  ============================
   exists E2, z1\E1 = y\E2

ml_member_prune1 < <b>search.</b>
Proof completed.
</pre>
<a name="60"></a>
<pre class="code">
Abella < <b>Theorem ml_member_prune2 : 
forall E E' Map, nabla x, {ml_member (map E (E' x)) Map} -> (exists E1',
  E' = y\E1').</b>
</pre>
<a name="61"></a>
<pre>


  ============================
   forall E E' Map, nabla x, {ml_member (map E (E' x)) Map} -> (exists E1',
     E' = y\E1')

ml_member_prune2 < <b>induction on 1.</b>
</pre>
<a name="62"></a>
<pre>


  IH : forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}* ->
         (exists E1', E' = y\E1')
  ============================
   forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}@ -> (exists E1',
     E' = y\E1')

ml_member_prune2 < <b>intros.</b>
</pre>
<a name="63"></a>
<pre>

  Variables: E, E', Map
  IH : forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}* ->
         (exists E1', E' = y\E1')
  H1 : {ml_member (map E (E' n1)) Map}@
  ============================
   exists E1', E' = y\E1'

ml_member_prune2 < <b>case H1.</b>
</pre>
<a name="64"></a>
<pre>
Subgoal 1:

  Variables: E, E', Map, Map2, Map1
  IH : forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}* ->
         (exists E1', E' = y\E1')
  ============================
   exists E1', z1\Map1 = y\E1'

Subgoal 2 is:
 exists E1', E' = y\E1'

ml_member_prune2 < <b>search.</b>
</pre>
<a name="65"></a>
<pre>
Subgoal 2:

  Variables: E, E', Map, Map2, Map1
  IH : forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}* ->
         (exists E1', E' = y\E1')
  H2 : {ml_member (map E (E' n1)) Map2}*
  ============================
   exists E1', E' = y\E1'

ml_member_prune2 < <b>apply IH to H2.</b>
</pre>
<a name="66"></a>
<pre>
Subgoal 2:

  Variables: E, E', Map, Map2, Map1, E1'
  IH : forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}* ->
         (exists E1', E' = y\E1')
  H2 : {ml_member (map E E1') Map2}*
  ============================
   exists E1'1, z1\E1' = y\E1'1

ml_member_prune2 < <b>search.</b>
Proof completed.
</pre>
<a name="67"></a>
<pre class="code">
Abella < <b>Theorem eq_map_list_inv : 
forall A B, nabla x, A x = B x -> A = B.</b>
</pre>
<a name="68"></a>
<pre>


  ============================
   forall A B, nabla x, A x = B x -> A = B

eq_map_list_inv < <b>intros.</b>
</pre>
<a name="69"></a>
<pre>

  Variables: A, B
  H1 : A n1 = B n1
  ============================
   A = B

eq_map_list_inv < <b>case H1.</b>
</pre>
<a name="70"></a>
<pre>

  Variables: A, B
  ============================
   z1\B z1 = B

eq_map_list_inv < <b>search.</b>
Proof completed.
</pre>
<a name="71"></a>
<pre class="code">
Abella < <b>Theorem eq_map_list_rewrite : 
forall A B X, A = B ->
  z1\z2\ml_cons (map X (fst z2)) (A z1 z2) = y\z2\ml_cons (map X (fst z2)) (B y z2).</b>
</pre>
<a name="72"></a>
<pre>


  ============================
   forall A B X, A = B ->
     z1\z2\ml_cons (map X (fst z2)) (A z1 z2) = y\z2\ml_cons (map X (fst z2)) (B y z2)

eq_map_list_rewrite < <b>intros.</b>
</pre>
<a name="73"></a>
<pre>

  Variables: A, B, X
  H1 : A = B
  ============================
   z1\z2\ml_cons (map X (fst z2)) (A z1 z2) = y\z2\ml_cons (map X (fst z2)) (B y z2)

eq_map_list_rewrite < <b>case H1.</b>
</pre>
<a name="74"></a>
<pre>

  Variables: A, B, X
  ============================
   z1\z2\ml_cons (map X (fst z2)) (B z1 z2) = y\z2\ml_cons (map X (fst z2)) (B y z2)

eq_map_list_rewrite < <b>search.</b>
Proof completed.
</pre>
<a name="75"></a>
<pre class="code">
Abella < <b>Theorem mapvar_prune : 
forall FVs ML, nabla x, {mapvar FVs (ML x)} -> (exists ML', ML = y\ML').</b>
</pre>
<a name="76"></a>
<pre>


  ============================
   forall FVs ML, nabla x, {mapvar FVs (ML x)} -> (exists ML', ML = y\ML')

mapvar_prune < <b>induction on 1.</b>
</pre>
<a name="77"></a>
<pre>


  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  ============================
   forall FVs ML, nabla x, {mapvar FVs (ML x)}@ -> (exists ML', ML = y\ML')

mapvar_prune < <b>intros.</b>
</pre>
<a name="78"></a>
<pre>

  Variables: FVs, ML
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H1 : {mapvar FVs (ML n1)}@
  ============================
   exists ML', ML = y\ML'

mapvar_prune < <b>case H1.</b>
</pre>
<a name="79"></a>
<pre>
Subgoal 1:

  Variables: FVs, ML
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  ============================
   exists ML', z1\z2\ml_nil = y\ML'

Subgoal 2 is:
 exists ML', ML = y\ML'

mapvar_prune < <b>search.</b>
</pre>
<a name="80"></a>
<pre>
Subgoal 2:

  Variables: FVs, ML, Map, L, X
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H2 : xenv\ml_cons (map X (fst xenv)) (Map n1 (rst xenv)) = xenv\ML n1 xenv
  H3 : {mapvar L (Map n1)}*
  ============================
   exists ML', ML = y\ML'

mapvar_prune < <b>apply IH to H3.</b>
</pre>
<a name="81"></a>
<pre>
Subgoal 2:

  Variables: FVs, ML, Map, L, X, ML'
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H2 : xenv\ml_cons (map X (fst xenv)) (ML' (rst xenv)) = xenv\ML n1 xenv
  H3 : {mapvar L ML'}*
  ============================
   exists ML', ML = y\ML'

mapvar_prune < <b>case H2.</b>
</pre>
<a name="82"></a>
<pre>
Subgoal 2:

  Variables: FVs, ML, Map, L, X, ML', ML2
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H3 : {mapvar L ML'}*
  H4 : xenv\ML2 n1 xenv = xenv\ML' (rst xenv)
  ============================
   exists ML', z1\z2\ml_cons (map X (fst z2)) (ML2 z1 z2) = y\ML'

mapvar_prune < <b>exists z2\ml_cons (map X (fst z2)) (ML' (rst z2)).</b>
</pre>
<a name="83"></a>
<pre>
Subgoal 2:

  Variables: FVs, ML, Map, L, X, ML', ML2
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H3 : {mapvar L ML'}*
  H4 : xenv\ML2 n1 xenv = xenv\ML' (rst xenv)
  ============================
   z1\z2\ml_cons (map X (fst z2)) (ML2 z1 z2) = y\z2\ml_cons (map X (fst z2)) (ML' (rst z2))

mapvar_prune < <b>apply eq_map_list_inv to H4.</b>
</pre>
<a name="84"></a>
<pre>
Subgoal 2:

  Variables: FVs, ML, Map, L, X, ML', ML2
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H3 : {mapvar L ML'}*
  H4 : xenv\ML2 n1 xenv = xenv\ML' (rst xenv)
  H5 : z2\z3\ML2 z2 z3 = z2\z3\ML' (rst z3)
  ============================
   z1\z2\ml_cons (map X (fst z2)) (ML2 z1 z2) = y\z2\ml_cons (map X (fst z2)) (ML' (rst z2))

mapvar_prune < <b>backchain eq_map_list_rewrite.</b>
Proof completed.
</pre>
<a name="85"></a>
<pre class="code">
Abella < <b>Define tmctx : olist -> prop by 
tmctx nil;
nabla x, tmctx (tm x :: L x) := nabla x, tmctx (L x).</b>
</pre>
<a name="86"></a>
<pre class="code">
Abella < <b>Define ctmctx : olist -> prop by 
ctmctx nil;
nabla x, ctmctx (ctm x :: L x) := nabla x, ctmctx (L x).</b>
</pre>
<a name="87"></a>
<pre class="code">
Abella < <b>Theorem tmctx_mem : 
forall L E, tmctx L -> member E L -> (exists X, E = tm X /\ tname X).</b>
</pre>
<a name="88"></a>
<pre>


  ============================
   forall L E, tmctx L -> member E L -> (exists X, E = tm X /\ tname X)

tmctx_mem < <b>induction on 1.</b>
</pre>
<a name="89"></a>
<pre>


  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  ============================
   forall L E, tmctx L @ -> member E L -> (exists X, E = tm X /\ tname X)

tmctx_mem < <b>intros.</b>
</pre>
<a name="90"></a>
<pre>

  Variables: L, E
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H1 : tmctx L @
  H2 : member E L
  ============================
   exists X, E = tm X /\ tname X

tmctx_mem < <b>case H1.</b>
</pre>
<a name="91"></a>
<pre>
Subgoal 1:

  Variables: L, E
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H2 : member E nil
  ============================
   exists X, E = tm X /\ tname X

Subgoal 2 is:
 exists X, E n1 = tm X /\ tname X

tmctx_mem < <b>case H2.</b>
</pre>
<a name="92"></a>
<pre>
Subgoal 2:

  Variables: L, E, L1
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H2 : member (E n1) (tm n1 :: L1 n1)
  H3 : tmctx (L1 n1) *
  ============================
   exists X, E n1 = tm X /\ tname X

tmctx_mem < <b>case H2.</b>
</pre>
<a name="93"></a>
<pre>
Subgoal 2.1:

  Variables: L, E, L1
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H3 : tmctx (L1 n1) *
  ============================
   exists X, tm n1 = tm X /\ tname X

Subgoal 2.2 is:
 exists X, E n1 = tm X /\ tname X

tmctx_mem < <b>search.</b>
</pre>
<a name="94"></a>
<pre>
Subgoal 2.2:

  Variables: L, E, L1
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H3 : tmctx (L1 n1) *
  H4 : member (E n1) (L1 n1)
  ============================
   exists X, E n1 = tm X /\ tname X

tmctx_mem < <b>apply IH to H3 H4.</b>
</pre>
<a name="95"></a>
<pre>
Subgoal 2.2:

  Variables: L, E, L1, X
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H3 : tmctx (L1 n1) *
  H4 : member (tm (X n1)) (L1 n1)
  H5 : tname (X n1)
  ============================
   exists X1, tm (X n1) = tm X1 /\ tname X1

tmctx_mem < <b>search.</b>
Proof completed.
</pre>
<a name="96"></a>
<pre class="code">
Abella < <b>Theorem ctmctx_mem : 
forall L E, ctmctx L -> member E L -> (exists X, E = ctm X /\ ctname X).</b>
</pre>
<a name="97"></a>
<pre>


  ============================
   forall L E, ctmctx L -> member E L -> (exists X, E = ctm X /\ ctname X)

ctmctx_mem < <b>induction on 1.</b>
</pre>
<a name="98"></a>
<pre>


  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  ============================
   forall L E, ctmctx L @ -> member E L -> (exists X, E = ctm X /\ ctname X)

ctmctx_mem < <b>intros.</b>
</pre>
<a name="99"></a>
<pre>

  Variables: L, E
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H1 : ctmctx L @
  H2 : member E L
  ============================
   exists X, E = ctm X /\ ctname X

ctmctx_mem < <b>case H1.</b>
</pre>
<a name="100"></a>
<pre>
Subgoal 1:

  Variables: L, E
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H2 : member E nil
  ============================
   exists X, E = ctm X /\ ctname X

Subgoal 2 is:
 exists X, E n1 = ctm X /\ ctname X

ctmctx_mem < <b>case H2.</b>
</pre>
<a name="101"></a>
<pre>
Subgoal 2:

  Variables: L, E, L1
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H2 : member (E n1) (ctm n1 :: L1 n1)
  H3 : ctmctx (L1 n1) *
  ============================
   exists X, E n1 = ctm X /\ ctname X

ctmctx_mem < <b>case H2.</b>
</pre>
<a name="102"></a>
<pre>
Subgoal 2.1:

  Variables: L, E, L1
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H3 : ctmctx (L1 n1) *
  ============================
   exists X, ctm n1 = ctm X /\ ctname X

Subgoal 2.2 is:
 exists X, E n1 = ctm X /\ ctname X

ctmctx_mem < <b>search.</b>
</pre>
<a name="103"></a>
<pre>
Subgoal 2.2:

  Variables: L, E, L1
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H3 : ctmctx (L1 n1) *
  H4 : member (E n1) (L1 n1)
  ============================
   exists X, E n1 = ctm X /\ ctname X

ctmctx_mem < <b>apply IH to H3 H4.</b>
</pre>
<a name="104"></a>
<pre>
Subgoal 2.2:

  Variables: L, E, L1, X
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H3 : ctmctx (L1 n1) *
  H4 : member (ctm (X n1)) (L1 n1)
  H5 : ctname (X n1)
  ============================
   exists X1, ctm (X n1) = ctm X1 /\ ctname X1

ctmctx_mem < <b>search.</b>
Proof completed.
</pre>
<a name="105"></a>
<pre class="code">
Abella < <b>Theorem closed_tm_prune_aux : 
forall M L, nabla x, tmctx L -> {L |- tm (M x)} -> (exists M', M = y\M').</b>
</pre>
<a name="106"></a>
<pre>


  ============================
   forall M L, nabla x, tmctx L -> {L |- tm (M x)} -> (exists M', M = y\M')

closed_tm_prune_aux < <b>induction on 2.</b>
</pre>
<a name="107"></a>
<pre>


  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  ============================
   forall M L, nabla x, tmctx L -> {L |- tm (M x)}@ -> (exists M', M = y\M')

closed_tm_prune_aux < <b>intros.</b>
</pre>
<a name="108"></a>
<pre>

  Variables: M, L
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H2 : {L |- tm (M n1)}@
  ============================
   exists M', M = y\M'

closed_tm_prune_aux < <b>case H2.</b>
</pre>
<a name="109"></a>
<pre>
Subgoal 1:

  Variables: M, L, N
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  ============================
   exists M', z1\lnat N = y\M'

Subgoal 2 is:
 exists M', z1\app (M1 z1) (N z1) = y\M'

Subgoal 3 is:
 exists M', z1\abs (R z1) = y\M'

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < <b>search.</b>
</pre>
<a name="110"></a>
<pre>
Subgoal 2:

  Variables: M, L, N, M1
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L |- tm (M1 n1)}*
  H4 : {L |- tm (N n1)}*
  ============================
   exists M', z1\app (M1 z1) (N z1) = y\M'

Subgoal 3 is:
 exists M', z1\abs (R z1) = y\M'

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < <b>apply IH to H1 H3.</b>
</pre>
<a name="111"></a>
<pre>
Subgoal 2:

  Variables: M, L, N, M1, M'
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L |- tm M'}*
  H4 : {L |- tm (N n1)}*
  ============================
   exists M'1, z1\app M' (N z1) = y\M'1

Subgoal 3 is:
 exists M', z1\abs (R z1) = y\M'

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < <b>apply IH to H1 H4.</b>
</pre>
<a name="112"></a>
<pre>
Subgoal 2:

  Variables: M, L, N, M1, M', M'1
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L |- tm M'}*
  H4 : {L |- tm M'1}*
  ============================
   exists M'2, z1\app M' M'1 = y\M'2

Subgoal 3 is:
 exists M', z1\abs (R z1) = y\M'

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < <b>search.</b>
</pre>
<a name="113"></a>
<pre>
Subgoal 3:

  Variables: M, L, R
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L, tm n2 |- tm (R n1 n2)}*
  ============================
   exists M', z1\abs (R z1) = y\M'

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < <b>apply IH to _ H3.</b>
</pre>
<a name="114"></a>
<pre>
Subgoal 3:

  Variables: M, L, R, M'
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L, tm n2 |- tm (M' n2)}*
  ============================
   exists M'1, z1\abs (z2\M' z2) = y\M'1

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < <b>search.</b>
</pre>
<a name="115"></a>
<pre>
Subgoal 4:

  Variables: M, L, F
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L, [F n1] |- tm (M n1)}*
  H4 : member (F n1) L
  ============================
   exists M', M = y\M'

closed_tm_prune_aux < <b>apply tmctx_mem to H1 H4.</b>
</pre>
<a name="116"></a>
<pre>
Subgoal 4:

  Variables: M, L, F, X
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L, [tm (X n1)] |- tm (M n1)}*
  H4 : member (tm (X n1)) L
  H5 : tname (X n1)
  ============================
   exists M', M = y\M'

closed_tm_prune_aux < <b>case H3.</b>
</pre>
<a name="117"></a>
<pre>
Subgoal 4:

  Variables: M, L, F, X
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H4 : member (tm (M n1)) L
  H5 : tname (M n1)
  ============================
   exists M', M = y\M'

closed_tm_prune_aux < <b>apply member_prune_tm to H4.</b>
</pre>
<a name="118"></a>
<pre>
Subgoal 4:

  Variables: M, L, F, X, M', M'1
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H4 : member (tm M'1) L
  H5 : tname M'1
  ============================
   exists M', z1\M'1 = y\M'

closed_tm_prune_aux < <b>search.</b>
Proof completed.
</pre>
<a name="119"></a>
<pre class="code">
Abella < <b>Theorem closed_tm_prune : 
forall M, nabla x, {tm (M x)} -> (exists M', M = y\M').</b>
</pre>
<a name="120"></a>
<pre>


  ============================
   forall M, nabla x, {tm (M x)} -> (exists M', M = y\M')

closed_tm_prune < <b>intros.</b>
</pre>
<a name="121"></a>
<pre>

  Variables: M
  H1 : {tm (M n1)}
  ============================
   exists M', M = y\M'

closed_tm_prune < <b>apply closed_tm_prune_aux to _ H1.</b>
</pre>
<a name="122"></a>
<pre>

  Variables: M, M'
  H1 : {tm M'}
  ============================
   exists M'1, z1\M' = y\M'1

closed_tm_prune < <b>search.</b>
Proof completed.
</pre>
<a name="123"></a>
<pre class="code">
Abella < <b>Theorem closed_ctm_prune_aux : 
forall M L, nabla x, ctmctx L -> {L |- ctm (M x)} -> (exists M', M = y\M').</b>
</pre>
<a name="124"></a>
<pre>


  ============================
   forall M L, nabla x, ctmctx L -> {L |- ctm (M x)} -> (exists M', M = y\M')

closed_ctm_prune_aux < <b>induction on 2.</b>
</pre>
<a name="125"></a>
<pre>


  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  ============================
   forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}@ -> (exists M',
     M = y\M')

closed_ctm_prune_aux < <b>intros.</b>
</pre>
<a name="126"></a>
<pre>

  Variables: M, L
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H2 : {L |- ctm (M n1)}@
  ============================
   exists M', M = y\M'

closed_ctm_prune_aux < <b>case H2.</b>
</pre>
<a name="127"></a>
<pre>
Subgoal 1:

  Variables: M, L
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  ============================
   exists M', z1\unit = y\M'

Subgoal 2 is:
 exists M', z1\clnat N = y\M'

Subgoal 3 is:
 exists M', z1\clet (M1 z1) (F z1) = y\M'

Subgoal 4 is:
 exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>search.</b>
</pre>
<a name="128"></a>
<pre>
Subgoal 2:

  Variables: M, L, N
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  ============================
   exists M', z1\clnat N = y\M'

Subgoal 3 is:
 exists M', z1\clet (M1 z1) (F z1) = y\M'

Subgoal 4 is:
 exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>search.</b>
</pre>
<a name="129"></a>
<pre>
Subgoal 3:

  Variables: M, L, F, M1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (M1 n1)}*
  H4 : {L, ctm n2 |- ctm (F n1 n2)}*
  ============================
   exists M', z1\clet (M1 z1) (F z1) = y\M'

Subgoal 4 is:
 exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to H1 H3.</b>
</pre>
<a name="130"></a>
<pre>
Subgoal 3:

  Variables: M, L, F, M1, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L, ctm n2 |- ctm (F n1 n2)}*
  ============================
   exists M'1, z1\clet M' (F z1) = y\M'1

Subgoal 4 is:
 exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to _ H4.</b>
</pre>
<a name="131"></a>
<pre>
Subgoal 3:

  Variables: M, L, F, M1, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L, ctm n2 |- ctm (M'1 n2)}*
  ============================
   exists M'2, z1\clet M' (z2\M'1 z2) = y\M'2

Subgoal 4 is:
 exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>search.</b>
</pre>
<a name="132"></a>
<pre>
Subgoal 4:

  Variables: M, L, M1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (M1 n1)}*
  ============================
   exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to H1 H3.</b>
</pre>
<a name="133"></a>
<pre>
Subgoal 4:

  Variables: M, L, M1, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  ============================
   exists M'1, z1\fst M' = y\M'1

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>search.</b>
</pre>
<a name="134"></a>
<pre>
Subgoal 5:

  Variables: M, L, M1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (M1 n1)}*
  ============================
   exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to H1 H3.</b>
</pre>
<a name="135"></a>
<pre>
Subgoal 5:

  Variables: M, L, M1, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  ============================
   exists M'1, z1\rst M' = y\M'1

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>search.</b>
</pre>
<a name="136"></a>
<pre>
Subgoal 6:

  Variables: M, L, N, M1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (M1 n1)}*
  H4 : {L |- ctm (N n1)}*
  ============================
   exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to H1 H3.</b>
</pre>
<a name="137"></a>
<pre>
Subgoal 6:

  Variables: M, L, N, M1, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm (N n1)}*
  ============================
   exists M'1, z1\cross M' (N z1) = y\M'1

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to H1 H4.</b>
</pre>
<a name="138"></a>
<pre>
Subgoal 6:

  Variables: M, L, N, M1, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm M'1}*
  ============================
   exists M'2, z1\cross M' M'1 = y\M'2

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>search.</b>
</pre>
<a name="139"></a>
<pre>
Subgoal 7:

  Variables: M, L, N, M1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (M1 n1)}*
  H4 : {L |- ctm (N n1)}*
  ============================
   exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to H1 H3.</b>
</pre>
<a name="140"></a>
<pre>
Subgoal 7:

  Variables: M, L, N, M1, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm (N n1)}*
  ============================
   exists M'1, z1\capp M' (N z1) = y\M'1

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to H1 H4.</b>
</pre>
<a name="141"></a>
<pre>
Subgoal 7:

  Variables: M, L, N, M1, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm M'1}*
  ============================
   exists M'2, z1\capp M' M'1 = y\M'2

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>search.</b>
</pre>
<a name="142"></a>
<pre>
Subgoal 8:

  Variables: M, L, R
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L, ctm n2 |- ctm (R n1 n2)}*
  ============================
   exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to _ H3.</b>
</pre>
<a name="143"></a>
<pre>
Subgoal 8:

  Variables: M, L, R, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L, ctm n2 |- ctm (M' n2)}*
  ============================
   exists M'1, z1\cabs (z2\M' z2) = y\M'1

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>search.</b>
</pre>
<a name="144"></a>
<pre>
Subgoal 9:

  Variables: M, L, PE, F
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (F n1)}*
  H4 : {L |- ctm (PE n1)}*
  ============================
   exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to H1 H3.</b>
</pre>
<a name="145"></a>
<pre>
Subgoal 9:

  Variables: M, L, PE, F, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm (PE n1)}*
  ============================
   exists M'1, z1\cpair M' (PE z1) = y\M'1

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to H1 H4.</b>
</pre>
<a name="146"></a>
<pre>
Subgoal 9:

  Variables: M, L, PE, F, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm M'1}*
  ============================
   exists M'2, z1\cpair M' M'1 = y\M'2

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>search.</b>
</pre>
<a name="147"></a>
<pre>
Subgoal 10:

  Variables: M, L, F, P
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (P n1)}*
  H4 : {L, ctm n2, ctm n3 |- ctm (F n1 n2 n3)}*
  ============================
   exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to H1 H3.</b>
</pre>
<a name="148"></a>
<pre>
Subgoal 10:

  Variables: M, L, F, P, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L, ctm n2, ctm n3 |- ctm (F n1 n2 n3)}*
  ============================
   exists M'1, z1\cunpair M' (F z1) = y\M'1

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>apply IH to _ H4.</b>
</pre>
<a name="149"></a>
<pre>
Subgoal 10:

  Variables: M, L, F, P, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L, ctm n2, ctm n3 |- ctm (M'1 n3 n2)}*
  ============================
   exists M'2, z1\cunpair M' (z2\z3\M'1 z3 z2) = y\M'2

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < <b>search.</b>
</pre>
<a name="150"></a>
<pre>
Subgoal 11:

  Variables: M, L, F
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L, [F n1] |- ctm (M n1)}*
  H4 : member (F n1) L
  ============================
   exists M', M = y\M'

closed_ctm_prune_aux < <b>apply ctmctx_mem to H1 H4.</b>
</pre>
<a name="151"></a>
<pre>
Subgoal 11:

  Variables: M, L, F, X
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L, [ctm (X n1)] |- ctm (M n1)}*
  H4 : member (ctm (X n1)) L
  H5 : ctname (X n1)
  ============================
   exists M', M = y\M'

closed_ctm_prune_aux < <b>case H3.</b>
</pre>
<a name="152"></a>
<pre>
Subgoal 11:

  Variables: M, L, F, X
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H4 : member (ctm (M n1)) L
  H5 : ctname (M n1)
  ============================
   exists M', M = y\M'

closed_ctm_prune_aux < <b>apply member_prune_ctm to H4.</b>
</pre>
<a name="153"></a>
<pre>
Subgoal 11:

  Variables: M, L, F, X, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H4 : member (ctm M'1) L
  H5 : ctname M'1
  ============================
   exists M', z1\M'1 = y\M'

closed_ctm_prune_aux < <b>search.</b>
Proof completed.
</pre>
<a name="154"></a>
<pre class="code">
Abella < <b>Theorem closed_ctm_prune : 
forall M, nabla x, {ctm (M x)} -> (exists M', M = y\M').</b>
</pre>
<a name="155"></a>
<pre>


  ============================
   forall M, nabla x, {ctm (M x)} -> (exists M', M = y\M')

closed_ctm_prune < <b>intros.</b>
</pre>
<a name="156"></a>
<pre>

  Variables: M
  H1 : {ctm (M n1)}
  ============================
   exists M', M = y\M'

closed_ctm_prune < <b>apply closed_ctm_prune_aux to _ H1.</b>
</pre>
<a name="157"></a>
<pre>

  Variables: M, M'
  H1 : {ctm M'}
  ============================
   exists M'1, z1\M' = y\M'1

closed_ctm_prune < <b>search.</b>
Proof completed.
</pre>
<a name="158"></a>
<pre class="code">
Abella < <b>Define tmctx_rst : o -> olist -> olist -> prop by 
nabla x, tmctx_rst (tm x) nil nil;
nabla x, tmctx_rst (tm x) (tm x :: L x) L' := nabla x, tmctx_rst (tm x) (L x) L';
nabla x, tmctx_rst (tm x) (tm Y :: L x) (tm Y :: L') := nabla x, tmctx_rst (tm x) (L x) L'.</b>
</pre>
<a name="159"></a>
<pre class="code">
Abella < <b>Theorem tmctx_rst_mem_inv : 
forall X L L' E, tmctx_rst X L L' -> member E L' -> member E L.</b>
</pre>
<a name="160"></a>
<pre>


  ============================
   forall X L L' E, tmctx_rst X L L' -> member E L' -> member E L

tmctx_rst_mem_inv < <b>induction on 1.</b>
</pre>
<a name="161"></a>
<pre>


  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  ============================
   forall X L L' E, tmctx_rst X L L' @ -> member E L' -> member E L

tmctx_rst_mem_inv < <b>intros.</b>
</pre>
<a name="162"></a>
<pre>

  Variables: X, L, L', E
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H1 : tmctx_rst X L L' @
  H2 : member E L'
  ============================
   member E L

tmctx_rst_mem_inv < <b>case H1.</b>
</pre>
<a name="163"></a>
<pre>
Subgoal 1:

  Variables: X, L, L', E
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H2 : member (E n1) nil
  ============================
   member (E n1) nil

Subgoal 2 is:
 member (E n1) (tm n1 :: L1 n1)

Subgoal 3 is:
 member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < <b>search.</b>
</pre>
<a name="164"></a>
<pre>
Subgoal 2:

  Variables: X, L, L', E, L'1, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H2 : member (E n1) L'1
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  ============================
   member (E n1) (tm n1 :: L1 n1)

Subgoal 3 is:
 member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < <b>apply IH to H3 H2.</b>
</pre>
<a name="165"></a>
<pre>
Subgoal 2:

  Variables: X, L, L', E, L'1, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H2 : member (E n1) L'1
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  H4 : member (E n1) (L1 n1)
  ============================
   member (E n1) (tm n1 :: L1 n1)

Subgoal 3 is:
 member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < <b>search.</b>
</pre>
<a name="166"></a>
<pre>
Subgoal 3:

  Variables: X, L, L', E, L'1, Y, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H2 : member (E n1) (tm Y :: L'1)
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  ============================
   member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < <b>case H2.</b>
</pre>
<a name="167"></a>
<pre>
Subgoal 3.1:

  Variables: X, L, L', E, L'1, Y, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  ============================
   member (tm Y) (tm Y :: L1 n1)

Subgoal 3.2 is:
 member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < <b>search.</b>
</pre>
<a name="168"></a>
<pre>
Subgoal 3.2:

  Variables: X, L, L', E, L'1, Y, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  H4 : member (E n1) L'1
  ============================
   member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < <b>apply IH to H3 H4.</b>
</pre>
<a name="169"></a>
<pre>
Subgoal 3.2:

  Variables: X, L, L', E, L'1, Y, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  H4 : member (E n1) L'1
  H5 : member (E n1) (L1 n1)
  ============================
   member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < <b>search.</b>
Proof completed.
</pre>
<a name="170"></a>
<pre class="code">
Abella < <b>Theorem tmctx_rst_exists : 
forall L, nabla x, tmctx (L x) -> (exists L', tmctx_rst (tm x) (L x) L' /\
  fresh_tmctx x L').</b>
</pre>
<a name="171"></a>
<pre>


  ============================
   forall L, nabla x, tmctx (L x) -> (exists L', tmctx_rst (tm x) (L x) L' /\
     fresh_tmctx x L')

tmctx_rst_exists < <b>induction on 1.</b>
</pre>
<a name="172"></a>
<pre>


  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  ============================
   forall L, nabla x, tmctx (L x) @ -> (exists L',
     tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')

tmctx_rst_exists < <b>intros.</b>
</pre>
<a name="173"></a>
<pre>

  Variables: L
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H1 : tmctx (L n1) @
  ============================
   exists L', tmctx_rst (tm n1) (L n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < <b>case H1.</b>
</pre>
<a name="174"></a>
<pre>
Subgoal 1:

  Variables: L
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  ============================
   exists L', tmctx_rst (tm n1) nil L' /\ fresh_tmctx n1 L'

Subgoal 2 is:
 exists L', tmctx_rst (tm n1) (tm n2 :: L1 n1 n2) L' /\ fresh_tmctx n1 L'

Subgoal 3 is:
 exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < <b>search.</b>
</pre>
<a name="175"></a>
<pre>
Subgoal 2:

  Variables: L, L1
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1 n2) *
  ============================
   exists L', tmctx_rst (tm n1) (tm n2 :: L1 n1 n2) L' /\ fresh_tmctx n1 L'

Subgoal 3 is:
 exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < <b>apply IH to H2.</b>
</pre>
<a name="176"></a>
<pre>
Subgoal 2:

  Variables: L, L1, L'
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1 n2) *
  H3 : tmctx_rst (tm n1) (L1 n1 n2) (L' n2 n1)
  H4 : fresh_tmctx n1 (L' n2 n1)
  ============================
   exists L', tmctx_rst (tm n1) (tm n2 :: L1 n1 n2) L' /\ fresh_tmctx n1 L'

Subgoal 3 is:
 exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < <b>case H4.</b>
</pre>
<a name="177"></a>
<pre>
Subgoal 2:

  Variables: L, L1, L', L3
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1 n2) *
  H3 : tmctx_rst (tm n1) (L1 n1 n2) (L3 n2)
  ============================
   exists L', tmctx_rst (tm n1) (tm n2 :: L1 n1 n2) L' /\ fresh_tmctx n1 L'

Subgoal 3 is:
 exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < <b>search.</b>
</pre>
<a name="178"></a>
<pre>
Subgoal 3:

  Variables: L, L1
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1) *
  ============================
   exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < <b>apply IH to H2.</b>
</pre>
<a name="179"></a>
<pre>
Subgoal 3:

  Variables: L, L1, L'
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1) *
  H3 : tmctx_rst (tm n1) (L1 n1) (L' n1)
  H4 : fresh_tmctx n1 (L' n1)
  ============================
   exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < <b>case H4.</b>
</pre>
<a name="180"></a>
<pre>
Subgoal 3:

  Variables: L, L1, L', L2
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1) *
  H3 : tmctx_rst (tm n1) (L1 n1) L2
  ============================
   exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < <b>search.</b>
Proof completed.
</pre>
<a name="181"></a>
<pre class="code">
Abella < <b>Theorem tmctx_rst_pres : 
forall L L', nabla x, tmctx (L x) -> tmctx_rst (tm x) (L x) L' -> tmctx L'.</b>
</pre>
<a name="182"></a>
<pre>


  ============================
   forall L L', nabla x, tmctx (L x) -> tmctx_rst (tm x) (L x) L' -> tmctx L'

tmctx_rst_pres < <b>induction on 1.</b>
</pre>
<a name="183"></a>
<pre>


  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  ============================
   forall L L', nabla x, tmctx (L x) @ -> tmctx_rst (tm x) (L x) L' ->
     tmctx L'

tmctx_rst_pres < <b>intros.</b>
</pre>
<a name="184"></a>
<pre>

  Variables: L, L'
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H1 : tmctx (L n1) @
  H2 : tmctx_rst (tm n1) (L n1) L'
  ============================
   tmctx L'

tmctx_rst_pres < <b>case H1.</b>
</pre>
<a name="185"></a>
<pre>
Subgoal 1:

  Variables: L, L'
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H2 : tmctx_rst (tm n1) nil L'
  ============================
   tmctx L'

Subgoal 2 is:
 tmctx (L' n2)

Subgoal 3 is:
 tmctx L'

tmctx_rst_pres < <b>case H2.</b>
</pre>
<a name="186"></a>
<pre>
Subgoal 1:

  Variables: L, L'
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  ============================
   tmctx nil

Subgoal 2 is:
 tmctx (L' n2)

Subgoal 3 is:
 tmctx L'

tmctx_rst_pres < <b>search.</b>
</pre>
<a name="187"></a>
<pre>
Subgoal 2:

  Variables: L, L', L1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H2 : tmctx_rst (tm n1) (tm n2 :: L1 n1 n2) (L' n2)
  H3 : tmctx (L1 n1 n2) *
  ============================
   tmctx (L' n2)

Subgoal 3 is:
 tmctx L'

tmctx_rst_pres < <b>case H2.</b>
</pre>
<a name="188"></a>
<pre>
Subgoal 2:

  Variables: L, L', L1, L'1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H3 : tmctx (L1 n1 n2) *
  H4 : tmctx_rst (tm n1) (L1 n1 n2) (L'1 n2)
  ============================
   tmctx (tm n2 :: L'1 n2)

Subgoal 3 is:
 tmctx L'

tmctx_rst_pres < <b>apply IH to H3 H4.</b>
</pre>
<a name="189"></a>
<pre>
Subgoal 2:

  Variables: L, L', L1, L'1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H3 : tmctx (L1 n1 n2) *
  H4 : tmctx_rst (tm n1) (L1 n1 n2) (L'1 n2)
  H5 : tmctx (L'1 n2)
  ============================
   tmctx (tm n2 :: L'1 n2)

Subgoal 3 is:
 tmctx L'

tmctx_rst_pres < <b>search.</b>
</pre>
<a name="190"></a>
<pre>
Subgoal 3:

  Variables: L, L', L1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H2 : tmctx_rst (tm n1) (tm n1 :: L1 n1) L'
  H3 : tmctx (L1 n1) *
  ============================
   tmctx L'

tmctx_rst_pres < <b>case H2.</b>
</pre>
<a name="191"></a>
<pre>
Subgoal 3:

  Variables: L, L', L1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H3 : tmctx (L1 n1) *
  H4 : tmctx_rst (tm n1) (L1 n1) L'
  ============================
   tmctx L'

tmctx_rst_pres < <b>apply IH to H3 H4.</b>
</pre>
<a name="192"></a>
<pre>
Subgoal 3:

  Variables: L, L', L1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H3 : tmctx (L1 n1) *
  H4 : tmctx_rst (tm n1) (L1 n1) L'
  H5 : tmctx L'
  ============================
   tmctx L'

tmctx_rst_pres < <b>search.</b>
Proof completed.
</pre>
<a name="193"></a>
<pre class="code">
Abella < <b>Theorem tmctx_rst_mem_str : 
forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' -> member (tm X) (L x) ->
  member (tm X) L'.</b>
</pre>
<a name="194"></a>
<pre>


  ============================
   forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' ->
     member (tm X) (L x) -> member (tm X) L'

tmctx_rst_mem_str < <b>induction on 1.</b>
</pre>
<a name="195"></a>
<pre>


  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  ============================
   forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' @ ->
     member (tm X) (L x) -> member (tm X) L'

tmctx_rst_mem_str < <b>intros.</b>
</pre>
<a name="196"></a>
<pre>

  Variables: L, L', X
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H1 : tmctx_rst (tm n1) (L n1) L' @
  H2 : member (tm X) (L n1)
  ============================
   member (tm X) L'

tmctx_rst_mem_str < <b>case H1.</b>
</pre>
<a name="197"></a>
<pre>
Subgoal 1:

  Variables: L, L', X
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H2 : member (tm X) nil
  ============================
   member (tm X) nil

Subgoal 2 is:
 member (tm X) L'

Subgoal 3 is:
 member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < <b>case H2.</b>
</pre>
<a name="198"></a>
<pre>
Subgoal 2:

  Variables: L, L', X, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H2 : member (tm X) (tm n1 :: L1 n1)
  H3 : tmctx_rst (tm n1) (L1 n1) L' *
  ============================
   member (tm X) L'

Subgoal 3 is:
 member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < <b>case H2.</b>
</pre>
<a name="199"></a>
<pre>
Subgoal 2:

  Variables: L, L', X, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H3 : tmctx_rst (tm n1) (L1 n1) L' *
  H4 : member (tm X) (L1 n1)
  ============================
   member (tm X) L'

Subgoal 3 is:
 member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < <b>apply IH to H3 H4.</b>
</pre>
<a name="200"></a>
<pre>
Subgoal 2:

  Variables: L, L', X, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H3 : tmctx_rst (tm n1) (L1 n1) L' *
  H4 : member (tm X) (L1 n1)
  H5 : member (tm X) L'
  ============================
   member (tm X) L'

Subgoal 3 is:
 member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < <b>search.</b>
</pre>
<a name="201"></a>
<pre>
Subgoal 3:

  Variables: L, L', X, L'1, Y, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H2 : member (tm X) (tm Y :: L1 n1)
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  ============================
   member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < <b>case H2.</b>
</pre>
<a name="202"></a>
<pre>
Subgoal 3.1:

  Variables: L, L', X, L'1, Y, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  ============================
   member (tm Y) (tm Y :: L'1)

Subgoal 3.2 is:
 member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < <b>search.</b>
</pre>
<a name="203"></a>
<pre>
Subgoal 3.2:

  Variables: L, L', X, L'1, Y, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  H4 : member (tm X) (L1 n1)
  ============================
   member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < <b>apply IH to H3 H4.</b>
</pre>
<a name="204"></a>
<pre>
Subgoal 3.2:

  Variables: L, L', X, L'1, Y, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  H4 : member (tm X) (L1 n1)
  H5 : member (tm X) L'1
  ============================
   member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < <b>search.</b>
Proof completed.
</pre>
<a name="205"></a>
<pre class="code">
Abella < <b>Theorem tm_strenghten : 
forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M} ->
  tmctx_rst (tm x) (L x) L' -> {L' |- tm M}.</b>
</pre>
<a name="206"></a>
<pre>


  ============================
   forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M} ->
     tmctx_rst (tm x) (L x) L' -> {L' |- tm M}

tm_strenghten < <b>induction on 2.</b>
</pre>
<a name="207"></a>
<pre>


  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  ============================
   forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}@ ->
     tmctx_rst (tm x) (L x) L' -> {L' |- tm M}

tm_strenghten < <b>intros.</b>
</pre>
<a name="208"></a>
<pre>

  Variables: L, L', M
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H2 : {L n1 |- tm M}@
  H3 : tmctx_rst (tm n1) (L n1) L'
  ============================
   {L' |- tm M}

tm_strenghten < <b>case H2.</b>
</pre>
<a name="209"></a>
<pre>
Subgoal 1:

  Variables: L, L', M, N
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  ============================
   {L' |- tm (lnat N)}

Subgoal 2 is:
 {L' |- tm (app M2 M3)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < <b>search.</b>
</pre>
<a name="210"></a>
<pre>
Subgoal 2:

  Variables: L, L', M, M3, M2
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1 |- tm M2}*
  H5 : {L n1 |- tm M3}*
  ============================
   {L' |- tm (app M2 M3)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < <b>apply IH to H1 H4 H3.</b>
</pre>
<a name="211"></a>
<pre>
Subgoal 2:

  Variables: L, L', M, M3, M2
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1 |- tm M2}*
  H5 : {L n1 |- tm M3}*
  H6 : {L' |- tm M2}
  ============================
   {L' |- tm (app M2 M3)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < <b>apply IH to H1 H5 H3.</b>
</pre>
<a name="212"></a>
<pre>
Subgoal 2:

  Variables: L, L', M, M3, M2
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1 |- tm M2}*
  H5 : {L n1 |- tm M3}*
  H6 : {L' |- tm M2}
  H7 : {L' |- tm M3}
  ============================
   {L' |- tm (app M2 M3)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < <b>search.</b>
</pre>
<a name="213"></a>
<pre>
Subgoal 3:

  Variables: L, L', M, M1
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, tm n2 |- tm (M1 n2)}*
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < <b>assert tmctx (tm n2 :: L n1).</b>
</pre>
<a name="214"></a>
<pre>
Subgoal 3:

  Variables: L, L', M, M1
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, tm n2 |- tm (M1 n2)}*
  H5 : tmctx (tm n2 :: L n1)
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < <b>assert tmctx_rst (tm n1) (tm n2 :: L n1) (tm n2 :: L').</b>
</pre>
<a name="215"></a>
<pre>
Subgoal 3:

  Variables: L, L', M, M1
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, tm n2 |- tm (M1 n2)}*
  H5 : tmctx (tm n2 :: L n1)
  H6 : tmctx_rst (tm n1) (tm n2 :: L n1) (tm n2 :: L')
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < <b>apply IH to H5 H4 H6.</b>
</pre>
<a name="216"></a>
<pre>
Subgoal 3:

  Variables: L, L', M, M1
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, tm n2 |- tm (M1 n2)}*
  H5 : tmctx (tm n2 :: L n1)
  H6 : tmctx_rst (tm n1) (tm n2 :: L n1) (tm n2 :: L')
  H7 : {L', tm n2 |- tm (M1 n2)}
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < <b>search.</b>
</pre>
<a name="217"></a>
<pre>
Subgoal 4:

  Variables: L, L', M, F
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, [F n1] |- tm M}*
  H5 : member (F n1) (L n1)
  ============================
   {L' |- tm M}

tm_strenghten < <b>apply tmctx_mem to H1 H5.</b>
</pre>
<a name="218"></a>
<pre>
Subgoal 4:

  Variables: L, L', M, F, X
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, [tm (X n1)] |- tm M}*
  H5 : member (tm (X n1)) (L n1)
  H6 : tname (X n1)
  ============================
   {L' |- tm M}

tm_strenghten < <b>case H4.</b>
</pre>
<a name="219"></a>
<pre>
Subgoal 4:

  Variables: L, L', M, F, X
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H5 : member (tm M) (L n1)
  H6 : tname M
  ============================
   {L' |- tm M}

tm_strenghten < <b>case H6.</b>
</pre>
<a name="220"></a>
<pre>
Subgoal 4:

  Variables: L, L', M, F, X
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n2 n1)
  H3 : tmctx_rst (tm n1) (L n2 n1) (L' n2)
  H5 : member (tm n2) (L n2 n1)
  ============================
   {L' n2 |- tm n2}

tm_strenghten < <b>apply tmctx_rst_mem_str to H3 H5.</b>
</pre>
<a name="221"></a>
<pre>
Subgoal 4:

  Variables: L, L', M, F, X
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n2 n1)
  H3 : tmctx_rst (tm n1) (L n2 n1) (L' n2)
  H5 : member (tm n2) (L n2 n1)
  H7 : member (tm n2) (L' n2)
  ============================
   {L' n2 |- tm n2}

tm_strenghten < <b>search.</b>
Proof completed.
</pre>
<a name="222"></a>
<pre class="code">
Abella < <b>Theorem tm_cut : 
forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)} ->
  tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}.</b>
</pre>
<a name="223"></a>
<pre>


  ============================
   forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)} ->
     tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}

tm_cut < <b>induction on 2.</b>
</pre>
<a name="224"></a>
<pre>


  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  ============================
   forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}@ ->
     tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}

tm_cut < <b>intros.</b>
</pre>
<a name="225"></a>
<pre>

  Variables: L, M, L', V
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H2 : {L n1 |- tm (M n1)}@
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  ============================
   {L' |- tm (M V)}

tm_cut < <b>case H2.</b>
</pre>
<a name="226"></a>
<pre>
Subgoal 1:

  Variables: L, M, L', V, N
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  ============================
   {L' |- tm (lnat N)}

Subgoal 2 is:
 {L' |- tm (app (M1 V) (N V))}

Subgoal 3 is:
 {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < <b>search.</b>
</pre>
<a name="227"></a>
<pre>
Subgoal 2:

  Variables: L, M, L', V, N, M1
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1 |- tm (M1 n1)}*
  H6 : {L n1 |- tm (N n1)}*
  ============================
   {L' |- tm (app (M1 V) (N V))}

Subgoal 3 is:
 {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < <b>apply IH to H1 H5 H3 H4.</b>
</pre>
<a name="228"></a>
<pre>
Subgoal 2:

  Variables: L, M, L', V, N, M1
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1 |- tm (M1 n1)}*
  H6 : {L n1 |- tm (N n1)}*
  H7 : {L' |- tm (M1 V)}
  ============================
   {L' |- tm (app (M1 V) (N V))}

Subgoal 3 is:
 {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < <b>apply IH to H1 H6 H3 H4.</b>
</pre>
<a name="229"></a>
<pre>
Subgoal 2:

  Variables: L, M, L', V, N, M1
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1 |- tm (M1 n1)}*
  H6 : {L n1 |- tm (N n1)}*
  H7 : {L' |- tm (M1 V)}
  H8 : {L' |- tm (N V)}
  ============================
   {L' |- tm (app (M1 V) (N V))}

Subgoal 3 is:
 {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < <b>search.</b>
</pre>
<a name="230"></a>
<pre>
Subgoal 3:

  Variables: L, M, L', V, R
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1, tm n2 |- tm (R n1 n2)}*
  ============================
   {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < <b>apply IH to _ H5 _ H4.</b>
</pre>
<a name="231"></a>
<pre>
Subgoal 3:

  Variables: L, M, L', V, R
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1, tm n2 |- tm (R n1 n2)}*
  H6 : {L', tm n2 |- tm (R V n2)}
  ============================
   {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < <b>search.</b>
</pre>
<a name="232"></a>
<pre>
Subgoal 4:

  Variables: L, M, L', V, F
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1, [F n1] |- tm (M n1)}*
  H6 : member (F n1) (L n1)
  ============================
   {L' |- tm (M V)}

tm_cut < <b>apply tmctx_mem to H1 H6.</b>
</pre>
<a name="233"></a>
<pre>
Subgoal 4:

  Variables: L, M, L', V, F, X
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1, [tm (X n1)] |- tm (M n1)}*
  H6 : member (tm (X n1)) (L n1)
  H7 : tname (X n1)
  ============================
   {L' |- tm (M V)}

tm_cut < <b>case H5.</b>
</pre>
<a name="234"></a>
<pre>
Subgoal 4:

  Variables: L, M, L', V, F, X
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H6 : member (tm (M n1)) (L n1)
  H7 : tname (M n1)
  ============================
   {L' |- tm (M V)}

tm_cut < <b>case H7.</b>
</pre>
<a name="235"></a>
<pre>
Subgoal 4.1:

  Variables: L, M, L', V, F, X
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n2 n1)
  H3 : tmctx_rst (tm n1) (L n2 n1) (L' n2)
  H4 : {tm (V n2)}
  H6 : member (tm n2) (L n2 n1)
  ============================
   {L' n2 |- tm n2}

Subgoal 4.2 is:
 {L' |- tm V}

tm_cut < <b>apply tmctx_rst_mem_str to H3 H6.</b>
</pre>
<a name="236"></a>
<pre>
Subgoal 4.1:

  Variables: L, M, L', V, F, X
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n2 n1)
  H3 : tmctx_rst (tm n1) (L n2 n1) (L' n2)
  H4 : {tm (V n2)}
  H6 : member (tm n2) (L n2 n1)
  H8 : member (tm n2) (L' n2)
  ============================
   {L' n2 |- tm n2}

Subgoal 4.2 is:
 {L' |- tm V}

tm_cut < <b>search.</b>
</pre>
<a name="237"></a>
<pre>
Subgoal 4.2:

  Variables: L, M, L', V, F, X
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H6 : member (tm n1) (L n1)
  ============================
   {L' |- tm V}

tm_cut < <b>search.</b>
Proof completed.
</pre>
<a name="238"></a>
<pre class="code">
Abella < <b>Define env_elem_aux : (ctm -> ctm) -> prop by 
env_elem_aux (x\x);
env_elem_aux (x\rst (R x)) := env_elem_aux R.</b>
</pre>
<a name="239"></a>
<pre class="code">
Abella < <b>Define env_elem : (ctm -> ctm) -> prop by 
env_elem (x\fst (R x)) := env_elem_aux R.</b>
</pre>
<a name="240"></a>
<pre class="code">
Abella < <b>Define env_map : (ctm -> map_list) -> prop by 
env_map (x\ml_nil);
env_map (x\ml_cons (map X (V x)) (ML x)) := env_map ML /\ env_elem V.</b>
</pre>
<a name="241"></a>
<pre class="code">
Abella < <b>Theorem env_elem_aux_closed : 
forall E, nabla x, env_elem_aux (E x) -> (exists E', E = y\E').</b>
</pre>
<a name="242"></a>
<pre>


  ============================
   forall E, nabla x, env_elem_aux (E x) -> (exists E', E = y\E')

env_elem_aux_closed < <b>induction on 1.</b>
</pre>
<a name="243"></a>
<pre>


  IH : forall E, nabla x, env_elem_aux (E x) * -> (exists E', E = y\E')
  ============================
   forall E, nabla x, env_elem_aux (E x) @ -> (exists E', E = y\E')

env_elem_aux_closed < <b>intros.</b>
</pre>
<a name="244"></a>
<pre>

  Variables: E
  IH : forall E, nabla x, env_elem_aux (E x) * -> (exists E', E = y\E')
  H1 : env_elem_aux (E n1) @
  ============================
   exists E', E = y\E'

env_elem_aux_closed < <b>case H1.</b>
</pre>
<a name="245"></a>
<pre>
Subgoal 1:

  Variables: E
  IH : forall E, nabla x, env_elem_aux (E x) * -> (exists E', E = y\E')
  ============================
   exists E', z1\z2\z2 = y\E'

Subgoal 2 is:
 exists E', z1\z2\rst (R z1 z2) = y\E'

env_elem_aux_closed < <b>search.</b>
</pre>
<a name="246"></a>
<pre>
Subgoal 2:

  Variables: E, R
  IH : forall E, nabla x, env_elem_aux (E x) * -> (exists E', E = y\E')
  H2 : env_elem_aux (R n1) *
  ============================
   exists E', z1\z2\rst (R z1 z2) = y\E'

env_elem_aux_closed < <b>apply IH to H2.</b>
</pre>
<a name="247"></a>
<pre>
Subgoal 2:

  Variables: E, R, E'
  IH : forall E, nabla x, env_elem_aux (E x) * -> (exists E', E = y\E')
  H2 : env_elem_aux E' *
  ============================
   exists E'1, z1\z2\rst (E' z2) = y\E'1

env_elem_aux_closed < <b>search.</b>
Proof completed.
</pre>
<a name="248"></a>
<pre class="code">
Abella < <b>Theorem env_elem_closed : 
forall E, nabla x, env_elem (E x) -> (exists E', E = y\E').</b>
</pre>
<a name="249"></a>
<pre>


  ============================
   forall E, nabla x, env_elem (E x) -> (exists E', E = y\E')

env_elem_closed < <b>intros.</b>
</pre>
<a name="250"></a>
<pre>

  Variables: E
  H1 : env_elem (E n1)
  ============================
   exists E', E = y\E'

env_elem_closed < <b>case H1.</b>
</pre>
<a name="251"></a>
<pre>

  Variables: E, R
  H2 : env_elem_aux (R n1)
  ============================
   exists E', z1\z2\fst (R z1 z2) = y\E'

env_elem_closed < <b>apply env_elem_aux_closed to H2.</b>
</pre>
<a name="252"></a>
<pre>

  Variables: E, R, E'
  H2 : env_elem_aux E'
  ============================
   exists E'1, z1\z2\fst (E' z2) = y\E'1

env_elem_closed < <b>search.</b>
Proof completed.
</pre>
<a name="253"></a>
<pre class="code">
Abella < <b>Theorem env_elem_aux_extend : 
forall E, env_elem_aux E -> env_elem_aux (x\E (rst x)).</b>
</pre>
<a name="254"></a>
<pre>


  ============================
   forall E, env_elem_aux E -> env_elem_aux (x\E (rst x))

env_elem_aux_extend < <b>induction on 1.</b>
</pre>
<a name="255"></a>
<pre>


  IH : forall E, env_elem_aux E * -> env_elem_aux (x\E (rst x))
  ============================
   forall E, env_elem_aux E @ -> env_elem_aux (x\E (rst x))

env_elem_aux_extend < <b>intros.</b>
</pre>
<a name="256"></a>
<pre>

  Variables: E
  IH : forall E, env_elem_aux E * -> env_elem_aux (x\E (rst x))
  H1 : env_elem_aux E @
  ============================
   env_elem_aux (x\E (rst x))

env_elem_aux_extend < <b>case H1.</b>
</pre>
<a name="257"></a>
<pre>
Subgoal 1:

  Variables: E
  IH : forall E, env_elem_aux E * -> env_elem_aux (x\E (rst x))
  ============================
   env_elem_aux (x\rst x)

Subgoal 2 is:
 env_elem_aux (x\rst (R (rst x)))

env_elem_aux_extend < <b>search.</b>
</pre>
<a name="258"></a>
<pre>
Subgoal 2:

  Variables: E, R
  IH : forall E, env_elem_aux E * -> env_elem_aux (x\E (rst x))
  H2 : env_elem_aux R *
  ============================
   env_elem_aux (x\rst (R (rst x)))

env_elem_aux_extend < <b>apply IH to H2.</b>
</pre>
<a name="259"></a>
<pre>
Subgoal 2:

  Variables: E, R
  IH : forall E, env_elem_aux E * -> env_elem_aux (x\E (rst x))
  H2 : env_elem_aux R *
  H3 : env_elem_aux (x\R (rst x))
  ============================
   env_elem_aux (x\rst (R (rst x)))

env_elem_aux_extend < <b>search.</b>
Proof completed.
</pre>
<a name="260"></a>
<pre class="code">
Abella < <b>Theorem env_elem_extend : 
forall E, env_elem E -> env_elem (x\E (rst x)).</b>
</pre>
<a name="261"></a>
<pre>


  ============================
   forall E, env_elem E -> env_elem (x\E (rst x))

env_elem_extend < <b>intros.</b>
</pre>
<a name="262"></a>
<pre>

  Variables: E
  H1 : env_elem E
  ============================
   env_elem (x\E (rst x))

env_elem_extend < <b>case H1.</b>
</pre>
<a name="263"></a>
<pre>

  Variables: E, R
  H2 : env_elem_aux R
  ============================
   env_elem (x\fst (R (rst x)))

env_elem_extend < <b>apply env_elem_aux_extend to H2.</b>
</pre>
<a name="264"></a>
<pre>

  Variables: E, R
  H2 : env_elem_aux R
  H3 : env_elem_aux (x\R (rst x))
  ============================
   env_elem (x\fst (R (rst x)))

env_elem_extend < <b>search.</b>
Proof completed.
</pre>
<a name="265"></a>
<pre class="code">
Abella < <b>Theorem mapvar_mem : 
forall FVs Map X E Env, nabla x, {mapvar FVs Map} ->
  {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\ env_elem E' /\
  {ml_member (map X (E' x)) (Map x)}).</b>
</pre>
<a name="266"></a>
<pre>


  ============================
   forall FVs Map X E Env, nabla x, {mapvar FVs Map} ->
     {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
     env_elem E' /\ {ml_member (map X (E' x)) (Map x)})

mapvar_mem < <b>induction on 1.</b>
</pre>
<a name="267"></a>
<pre>


  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  ============================
   forall FVs Map X E Env, nabla x, {mapvar FVs Map}@ ->
     {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
     env_elem E' /\ {ml_member (map X (E' x)) (Map x)})

mapvar_mem < <b>intros.</b>
</pre>
<a name="268"></a>
<pre>

  Variables: FVs, Map, X, E, Env
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H1 : {mapvar FVs Map}@
  H2 : {ml_member (map X E) (Map Env)}
  ============================
   exists E', E = E' Env /\ env_elem E' /\
     {ml_member (map X (E' n1)) (Map n1)}

mapvar_mem < <b>case H1.</b>
</pre>
<a name="269"></a>
<pre>
Subgoal 1:

  Variables: FVs, Map, X, E, Env
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H2 : {ml_member (map X E) ml_nil}
  ============================
   exists E', E = E' Env /\ env_elem E' /\ {ml_member (map X (E' n1)) ml_nil}

Subgoal 2 is:
 exists E', E = E' Env /\ env_elem E' /\
   {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>case H2.</b>
</pre>
<a name="270"></a>
<pre>
Subgoal 2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H2 : {ml_member (map X E) (ml_cons (map X1 (fst Env)) (Map1 (rst Env)))}
  H3 : {mapvar L Map1}*
  ============================
   exists E', E = E' Env /\ env_elem E' /\
     {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>case H2.</b>
</pre>
<a name="271"></a>
<pre>
Subgoal 2.1:

  Variables: FVs, Map, X, E, Env, Map1, L, X1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  ============================
   exists E', fst Env = E' Env /\ env_elem E' /\
     {ml_member (map X1 (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

Subgoal 2.2 is:
 exists E', E = E' Env /\ env_elem E' /\
   {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>exists x\fst x.</b>
</pre>
<a name="272"></a>
<pre>
Subgoal 2.1:

  Variables: FVs, Map, X, E, Env, Map1, L, X1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  ============================
   fst Env = fst Env /\ env_elem (x\fst x) /\
     {ml_member (map X1 (fst n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

Subgoal 2.2 is:
 exists E', E = E' Env /\ env_elem E' /\
   {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>search.</b>
</pre>
<a name="273"></a>
<pre>
Subgoal 2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  ============================
   exists E', E = E' Env /\ env_elem E' /\
     {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>apply IH to H3 H4.</b>
</pre>
<a name="274"></a>
<pre>
Subgoal 2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E'
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E' n1 (rst Env)
  H6 : env_elem (E' n1)
  H7 : {ml_member (map X (E' n1 n1)) (Map1 n1)}
  ============================
   exists E', E = E' Env /\ env_elem E' /\
     {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>apply env_elem_closed to H6.</b>
</pre>
<a name="275"></a>
<pre>
Subgoal 2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  ============================
   exists E', E = E' Env /\ env_elem E' /\
     {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>exists x\E'1 (rst x).</b>
</pre>
<a name="276"></a>
<pre>
Subgoal 2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  ============================
   E = E'1 (rst Env) /\ env_elem (x\E'1 (rst x)) /\
     {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>split.</b>
</pre>
<a name="277"></a>
<pre>
Subgoal 2.2.1:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  ============================
   E = E'1 (rst Env)

Subgoal 2.2.2 is:
 env_elem (x\E'1 (rst x))

Subgoal 2.2.3 is:
 {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>search.</b>
</pre>
<a name="278"></a>
<pre>
Subgoal 2.2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  ============================
   env_elem (x\E'1 (rst x))

Subgoal 2.2.3 is:
 {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>apply env_elem_extend to H6.</b>
</pre>
<a name="279"></a>
<pre>
Subgoal 2.2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  H8 : env_elem (x\E'1 (rst x))
  ============================
   env_elem (x\E'1 (rst x))

Subgoal 2.2.3 is:
 {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>search.</b>
</pre>
<a name="280"></a>
<pre>
Subgoal 2.2.3:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  ============================
   {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>inst H7 with n1 = rst n1.</b>
</pre>
<a name="281"></a>
<pre>
Subgoal 2.2.3:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  H8 : {ml_member (map X (E'1 (rst n1))) (Map1 (rst n1))}
  ============================
   {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < <b>search.</b>
Proof completed.
</pre>
<a name="282"></a>
<pre class="code">
Abella < <b>Theorem env_map_rst : 
forall Map, env_map Map -> env_map (x\Map (rst x)).</b>
</pre>
<a name="283"></a>
<pre>


  ============================
   forall Map, env_map Map -> env_map (x\Map (rst x))

env_map_rst < <b>induction on 1.</b>
</pre>
<a name="284"></a>
<pre>


  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  ============================
   forall Map, env_map Map @ -> env_map (x\Map (rst x))

env_map_rst < <b>intros.</b>
</pre>
<a name="285"></a>
<pre>

  Variables: Map
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H1 : env_map Map @
  ============================
   env_map (x\Map (rst x))

env_map_rst < <b>case H1.</b>
</pre>
<a name="286"></a>
<pre>
Subgoal 1:

  Variables: Map
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  ============================
   env_map (x\ml_nil)

Subgoal 2 is:
 env_map (x\ml_cons (map X (V (rst x))) (ML (rst x)))

env_map_rst < <b>search.</b>
</pre>
<a name="287"></a>
<pre>
Subgoal 2:

  Variables: Map, ML, V, X
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H2 : env_map ML *
  H3 : env_elem V
  ============================
   env_map (x\ml_cons (map X (V (rst x))) (ML (rst x)))

env_map_rst < <b>apply IH to H2.</b>
</pre>
<a name="288"></a>
<pre>
Subgoal 2:

  Variables: Map, ML, V, X
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H2 : env_map ML *
  H3 : env_elem V
  H4 : env_map (x\ML (rst x))
  ============================
   env_map (x\ml_cons (map X (V (rst x))) (ML (rst x)))

env_map_rst < <b>unfold.</b>
</pre>
<a name="289"></a>
<pre>
Subgoal 2.1:

  Variables: Map, ML, V, X
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H2 : env_map ML *
  H3 : env_elem V
  H4 : env_map (x\ML (rst x))
  ============================
   env_map (z1\ML (rst z1))

Subgoal 2.2 is:
 env_elem (z1\V (rst z1))

env_map_rst < <b>search.</b>
</pre>
<a name="290"></a>
<pre>
Subgoal 2.2:

  Variables: Map, ML, V, X
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H2 : env_map ML *
  H3 : env_elem V
  H4 : env_map (x\ML (rst x))
  ============================
   env_elem (z1\V (rst z1))

env_map_rst < <b>apply env_elem_extend to H3.</b>
</pre>
<a name="291"></a>
<pre>
Subgoal 2.2:

  Variables: Map, ML, V, X
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H2 : env_map ML *
  H3 : env_elem V
  H4 : env_map (x\ML (rst x))
  H5 : env_elem (x\V (rst x))
  ============================
   env_elem (z1\V (rst z1))

env_map_rst < <b>search.</b>
Proof completed.
</pre>
<a name="292"></a>
<pre class="code">
Abella < <b>Theorem mapvar_env_map : 
forall FVs Map, {mapvar FVs Map} -> env_map Map.</b>
</pre>
<a name="293"></a>
<pre>


  ============================
   forall FVs Map, {mapvar FVs Map} -> env_map Map

mapvar_env_map < <b>induction on 1.</b>
</pre>
<a name="294"></a>
<pre>


  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  ============================
   forall FVs Map, {mapvar FVs Map}@ -> env_map Map

mapvar_env_map < <b>intros.</b>
</pre>
<a name="295"></a>
<pre>

  Variables: FVs, Map
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H1 : {mapvar FVs Map}@
  ============================
   env_map Map

mapvar_env_map < <b>case H1.</b>
</pre>
<a name="296"></a>
<pre>
Subgoal 1:

  Variables: FVs, Map
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  ============================
   env_map (xenv\ml_nil)

Subgoal 2 is:
 env_map (xenv\ml_cons (map X (fst xenv)) (Map1 (rst xenv)))

mapvar_env_map < <b>search.</b>
</pre>
<a name="297"></a>
<pre>
Subgoal 2:

  Variables: FVs, Map, Map1, L, X
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H2 : {mapvar L Map1}*
  ============================
   env_map (xenv\ml_cons (map X (fst xenv)) (Map1 (rst xenv)))

mapvar_env_map < <b>apply IH to H2.</b>
</pre>
<a name="298"></a>
<pre>
Subgoal 2:

  Variables: FVs, Map, Map1, L, X
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H2 : {mapvar L Map1}*
  H3 : env_map Map1
  ============================
   env_map (xenv\ml_cons (map X (fst xenv)) (Map1 (rst xenv)))

mapvar_env_map < <b>unfold.</b>
</pre>
<a name="299"></a>
<pre>
Subgoal 2.1:

  Variables: FVs, Map, Map1, L, X
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H2 : {mapvar L Map1}*
  H3 : env_map Map1
  ============================
   env_map (z1\Map1 (rst z1))

Subgoal 2.2 is:
 env_elem (z1\fst z1)

mapvar_env_map < <b>apply env_map_rst to H3.</b>
</pre>
<a name="300"></a>
<pre>
Subgoal 2.1:

  Variables: FVs, Map, Map1, L, X
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H2 : {mapvar L Map1}*
  H3 : env_map Map1
  H4 : env_map (x\Map1 (rst x))
  ============================
   env_map (z1\Map1 (rst z1))

Subgoal 2.2 is:
 env_elem (z1\fst z1)

mapvar_env_map < <b>search.</b>
</pre>
<a name="301"></a>
<pre>
Subgoal 2.2:

  Variables: FVs, Map, Map1, L, X
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H2 : {mapvar L Map1}*
  H3 : env_map Map1
  ============================
   env_elem (z1\fst z1)

mapvar_env_map < <b>search.</b>
Proof completed.
</pre>
<a name="302"></a>
<pre class="code">
Abella < <b>Theorem env_elem_aux_ctm : 
forall V, nabla xenv, env_elem_aux V -> {ctm xenv |- ctm (V xenv)}.</b>
</pre>
<a name="303"></a>
<pre>


  ============================
   forall V, nabla xenv, env_elem_aux V -> {ctm xenv |- ctm (V xenv)}

env_elem_aux_ctm < <b>induction on 1.</b>
</pre>
<a name="304"></a>
<pre>


  IH : forall V, nabla xenv, env_elem_aux V * -> {ctm xenv |- ctm (V xenv)}
  ============================
   forall V, nabla xenv, env_elem_aux V @ -> {ctm xenv |- ctm (V xenv)}

env_elem_aux_ctm < <b>intros.</b>
</pre>
<a name="305"></a>
<pre>

  Variables: V
  IH : forall V, nabla xenv, env_elem_aux V * -> {ctm xenv |- ctm (V xenv)}
  H1 : env_elem_aux V @
  ============================
   {ctm n1 |- ctm (V n1)}

env_elem_aux_ctm < <b>case H1.</b>
</pre>
<a name="306"></a>
<pre>
Subgoal 1:

  Variables: V
  IH : forall V, nabla xenv, env_elem_aux V * -> {ctm xenv |- ctm (V xenv)}
  ============================
   {ctm n1 |- ctm n1}

Subgoal 2 is:
 {ctm n1 |- ctm (rst (R n1))}

env_elem_aux_ctm < <b>search.</b>
</pre>
<a name="307"></a>
<pre>
Subgoal 2:

  Variables: V, R
  IH : forall V, nabla xenv, env_elem_aux V * -> {ctm xenv |- ctm (V xenv)}
  H2 : env_elem_aux R *
  ============================
   {ctm n1 |- ctm (rst (R n1))}

env_elem_aux_ctm < <b>apply IH to H2.</b>
</pre>
<a name="308"></a>
<pre>
Subgoal 2:

  Variables: V, R
  IH : forall V, nabla xenv, env_elem_aux V * -> {ctm xenv |- ctm (V xenv)}
  H2 : env_elem_aux R *
  H3 : {ctm n1 |- ctm (R n1)}
  ============================
   {ctm n1 |- ctm (rst (R n1))}

env_elem_aux_ctm < <b>search.</b>
Proof completed.
</pre>
<a name="309"></a>
<pre class="code">
Abella < <b>Theorem env_elem_ctm : 
forall V, nabla xenv, env_elem V -> {ctm xenv |- ctm (V xenv)}.</b>
</pre>
<a name="310"></a>
<pre>


  ============================
   forall V, nabla xenv, env_elem V -> {ctm xenv |- ctm (V xenv)}

env_elem_ctm < <b>intros.</b>
</pre>
<a name="311"></a>
<pre>

  Variables: V
  H1 : env_elem V
  ============================
   {ctm n1 |- ctm (V n1)}

env_elem_ctm < <b>case H1.</b>
</pre>
<a name="312"></a>
<pre>

  Variables: V, R
  H2 : env_elem_aux R
  ============================
   {ctm n1 |- ctm (fst (R n1))}

env_elem_ctm < <b>apply env_elem_aux_ctm to H2.</b>
</pre>
<a name="313"></a>
<pre>

  Variables: V, R
  H2 : env_elem_aux R
  H3 : {ctm n1 |- ctm (R n1)}
  ============================
   {ctm n1 |- ctm (fst (R n1))}

env_elem_ctm < <b>search.</b>
Proof completed.
</pre>
<a name="314"></a>
<pre class="code">
Abella < <b>Theorem env_map_ctm : 
forall Map V X, nabla xenv, env_map Map ->
  {ml_member (map X (V xenv)) (Map xenv)} -> {ctm xenv |- ctm (V xenv)}.</b>
</pre>
<a name="315"></a>
<pre>


  ============================
   forall Map V X, nabla xenv, env_map Map ->
     {ml_member (map X (V xenv)) (Map xenv)} -> {ctm xenv |- ctm (V xenv)}

env_map_ctm < <b>induction on 1.</b>
</pre>
<a name="316"></a>
<pre>


  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  ============================
   forall Map V X, nabla xenv, env_map Map @ ->
     {ml_member (map X (V xenv)) (Map xenv)} -> {ctm xenv |- ctm (V xenv)}

env_map_ctm < <b>intros.</b>
</pre>
<a name="317"></a>
<pre>

  Variables: Map, V, X
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H1 : env_map Map @
  H2 : {ml_member (map X (V n1)) (Map n1)}
  ============================
   {ctm n1 |- ctm (V n1)}

env_map_ctm < <b>case H1.</b>
</pre>
<a name="318"></a>
<pre>
Subgoal 1:

  Variables: Map, V, X
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H2 : {ml_member (map X (V n1)) ml_nil}
  ============================
   {ctm n1 |- ctm (V n1)}

Subgoal 2 is:
 {ctm n1 |- ctm (V n1)}

env_map_ctm < <b>case H2.</b>
</pre>
<a name="319"></a>
<pre>
Subgoal 2:

  Variables: Map, V, X, ML, V1, X1
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H2 : {ml_member (map X (V n1)) (ml_cons (map X1 (V1 n1)) (ML n1))}
  H3 : env_map ML *
  H4 : env_elem V1
  ============================
   {ctm n1 |- ctm (V n1)}

env_map_ctm < <b>case H2.</b>
</pre>
<a name="320"></a>
<pre>
Subgoal 2.1:

  Variables: Map, V, X, ML, V1, X1
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H3 : env_map ML *
  H4 : env_elem V1
  ============================
   {ctm n1 |- ctm (V1 n1)}

Subgoal 2.2 is:
 {ctm n1 |- ctm (V n1)}

env_map_ctm < <b>apply env_elem_ctm to H4.</b>
</pre>
<a name="321"></a>
<pre>
Subgoal 2.1:

  Variables: Map, V, X, ML, V1, X1
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H3 : env_map ML *
  H4 : env_elem V1
  H5 : {ctm n1 |- ctm (V1 n1)}
  ============================
   {ctm n1 |- ctm (V1 n1)}

Subgoal 2.2 is:
 {ctm n1 |- ctm (V n1)}

env_map_ctm < <b>search.</b>
</pre>
<a name="322"></a>
<pre>
Subgoal 2.2:

  Variables: Map, V, X, ML, V1, X1
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H3 : env_map ML *
  H4 : env_elem V1
  H5 : {ml_member (map X (V n1)) (ML n1)}
  ============================
   {ctm n1 |- ctm (V n1)}

env_map_ctm < <b>apply IH to H3 H5.</b>
</pre>
<a name="323"></a>
<pre>
Subgoal 2.2:

  Variables: Map, V, X, ML, V1, X1
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H3 : env_map ML *
  H4 : env_elem V1
  H5 : {ml_member (map X (V n1)) (ML n1)}
  H6 : {ctm n1 |- ctm (V n1)}
  ============================
   {ctm n1 |- ctm (V n1)}

env_map_ctm < <b>search.</b>
Proof completed.
</pre>
<a name="324"></a>
<pre class="code">
Abella < <b>Theorem mapenv_ctm : 
forall FVs PE Map, nabla x y xenv, env_map Map ->
  {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)} ->
  {ctm xenv, ctm y |- ctm (PE xenv y)}.</b>
</pre>
<a name="325"></a>
<pre>


  ============================
   forall FVs PE Map, nabla x y xenv, env_map Map ->
     {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)} ->
     {ctm xenv, ctm y |- ctm (PE xenv y)}

mapenv_ctm < <b>induction on 2.</b>
</pre>
<a name="326"></a>
<pre>


  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  ============================
   forall FVs PE Map, nabla x y xenv, env_map Map ->
     {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}@ ->
     {ctm xenv, ctm y |- ctm (PE xenv y)}

mapenv_ctm < <b>intros.</b>
</pre>
<a name="327"></a>
<pre>

  Variables: FVs, PE, Map
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H2 : {mapenv (FVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}@
  ============================
   {ctm n3, ctm n2 |- ctm (PE n3 n2)}

mapenv_ctm < <b>case H2.</b>
</pre>
<a name="328"></a>
<pre>
Subgoal 1:

  Variables: FVs, PE, Map
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  ============================
   {ctm n3, ctm n2 |- ctm unit}

Subgoal 2 is:
 {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < <b>search.</b>
</pre>
<a name="329"></a>
<pre>
Subgoal 2:

  Variables: FVs, PE, Map, ML, L, M, X
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H3 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H4 : {mapenv (L n1) (ml_cons (map n1 n2) (Map n3)) (ML n2 n3)}*
  ============================
   {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < <b>apply IH to H1 H4.</b>
</pre>
<a name="330"></a>
<pre>
Subgoal 2:

  Variables: FVs, PE, Map, ML, L, M, X
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H3 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H4 : {mapenv (L n1) (ml_cons (map n1 n2) (Map n3)) (ML n2 n3)}*
  H5 : {ctm n3, ctm n2 |- ctm (ML n2 n3)}
  ============================
   {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < <b>case H3.</b>
</pre>
<a name="331"></a>
<pre>
Subgoal 2.1:

  Variables: FVs, PE, Map, ML, L, M, X
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H4 : {mapenv (L n1) (ml_cons (map n1 n2) (Map n3)) (ML n2 n3)}*
  H5 : {ctm n3, ctm n2 |- ctm (ML n2 n3)}
  ============================
   {ctm n3, ctm n2 |- ctm (cross n2 (ML n2 n3))}

Subgoal 2.2 is:
 {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < <b>search.</b>
</pre>
<a name="332"></a>
<pre>
Subgoal 2.2:

  Variables: FVs, PE, Map, ML, L, M, X
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H4 : {mapenv (L n1) (ml_cons (map n1 n2) (Map n3)) (ML n2 n3)}*
  H5 : {ctm n3, ctm n2 |- ctm (ML n2 n3)}
  H6 : {ml_member (map (X n1) (M n2 n3)) (Map n3)}*
  ============================
   {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < <b>apply env_map_ctm to H1 H6.</b>
</pre>
<a name="333"></a>
<pre>
Subgoal 2.2:

  Variables: FVs, PE, Map, ML, L, M, X
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H4 : {mapenv (L n1) (ml_cons (map n1 n2) (Map n3)) (ML n2 n3)}*
  H5 : {ctm n3, ctm n2 |- ctm (ML n2 n3)}
  H6 : {ml_member (map (X n1) (M n2 n3)) (Map n3)}*
  H7 : {ctm n3 |- ctm (M n2 n3)}
  ============================
   {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < <b>search.</b>
Proof completed.
</pre>
<a name="334"></a>
<pre class="code">
Abella < <b>Theorem cc_ctm : 
forall M P Map FVs, nabla x xenv y, env_map Map ->
  {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
  {ctm xenv, ctm y |- ctm (P xenv y)}.</b>
</pre>
<a name="335"></a>
<pre>


  ============================
   forall M P Map FVs, nabla x xenv y, env_map Map ->
     {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
     {ctm xenv, ctm y |- ctm (P xenv y)}

cc_ctm < <b>induction on 2.</b>
</pre>
<a name="336"></a>
<pre>


  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  ============================
   forall M P Map FVs, nabla x xenv y, env_map Map ->
     {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}@ ->
     {ctm xenv, ctm y |- ctm (P xenv y)}

cc_ctm < <b>intros.</b>
</pre>
<a name="337"></a>
<pre>

  Variables: M, P, Map, FVs
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H2 : {cc (M n1) (P n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}@
  ============================
   {ctm n2, ctm n3 |- ctm (P n2 n3)}

cc_ctm < <b>case H2.</b>
</pre>
<a name="338"></a>
<pre>
Subgoal 1:

  Variables: M, P, Map, FVs
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {ml_member (map (M n1) (P n2 n3)) (ml_cons (map n1 n3) (Map n2))}*
  ============================
   {ctm n2, ctm n3 |- ctm (P n2 n3)}

Subgoal 2 is:
 {ctm n2, ctm n3 |- ctm (clnat N)}

Subgoal 3 is:
 {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>case H3.</b>
</pre>
<a name="339"></a>
<pre>
Subgoal 1.1:

  Variables: M, P, Map, FVs
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  ============================
   {ctm n2, ctm n3 |- ctm n3}

Subgoal 1.2 is:
 {ctm n2, ctm n3 |- ctm (P n2 n3)}

Subgoal 2 is:
 {ctm n2, ctm n3 |- ctm (clnat N)}

Subgoal 3 is:
 {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>search.</b>
</pre>
<a name="340"></a>
<pre>
Subgoal 1.2:

  Variables: M, P, Map, FVs
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H4 : {ml_member (map (M n1) (P n2 n3)) (Map n2)}*
  ============================
   {ctm n2, ctm n3 |- ctm (P n2 n3)}

Subgoal 2 is:
 {ctm n2, ctm n3 |- ctm (clnat N)}

Subgoal 3 is:
 {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>apply env_map_ctm to H1 H4.</b>
</pre>
<a name="341"></a>
<pre>
Subgoal 1.2:

  Variables: M, P, Map, FVs
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H4 : {ml_member (map (M n1) (P n2 n3)) (Map n2)}*
  H5 : {ctm n2 |- ctm (P n2 n3)}
  ============================
   {ctm n2, ctm n3 |- ctm (P n2 n3)}

Subgoal 2 is:
 {ctm n2, ctm n3 |- ctm (clnat N)}

Subgoal 3 is:
 {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>search.</b>
</pre>
<a name="342"></a>
<pre>
Subgoal 2:

  Variables: M, P, Map, FVs, N
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  ============================
   {ctm n2, ctm n3 |- ctm (clnat N)}

Subgoal 3 is:
 {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>search.</b>
</pre>
<a name="343"></a>
<pre>
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (NMap n1 n2 n3)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n2 n3 n6)) (tl_cons n4 (NFVs n1))}*
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>apply mapvar_prune to H5.</b>
</pre>
<a name="344"></a>
<pre>
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML'
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML' n3 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML' n3 n1 n6)) (tl_cons n4 (NFVs n1))}*
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>apply mapvar_prune to H5.</b>
</pre>
<a name="345"></a>
<pre>
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML', ML'1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML'1 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>apply mapvar_env_map to H5.</b>
</pre>
<a name="346"></a>
<pre>
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML', ML'1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML'1 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H7 : env_map (ML'1 n1)
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>apply IH to H7 H6.</b>
</pre>
<a name="347"></a>
<pre>
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML', ML'1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML'1 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H7 : env_map (ML'1 n1)
  H8 : {ctm n6, ctm n5 |- ctm (P1 n2 n3 n6 n5)}
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>apply mapenv_ctm to H1 H4.</b>
</pre>
<a name="348"></a>
<pre>
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML', ML'1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML'1 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H7 : env_map (ML'1 n1)
  H8 : {ctm n6, ctm n5 |- ctm (P1 n2 n3 n6 n5)}
  H9 : {ctm n2, ctm n3 |- ctm (PE n2 n3)}
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>assert {ctm n2, ctm n3 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y))))}.</b>
</pre>
<a name="349"></a>
<pre>
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML', ML'1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML'1 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H7 : env_map (ML'1 n1)
  H8 : {ctm n6, ctm n5 |- ctm (P1 n2 n3 n6 n5)}
  H9 : {ctm n2, ctm n3 |- ctm (PE n2 n3)}
  H10 : {ctm n2, ctm n3 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y))))}
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>search.</b>
</pre>
<a name="350"></a>
<pre>
Subgoal 4:

  Variables: M, P, Map, FVs, CM2, M2, CM1, M1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {cc (M1 n1) (CM1 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  H4 : {cc (M2 n1) (CM2 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  ============================
   {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>apply IH to H1 H3.</b>
</pre>
<a name="351"></a>
<pre>
Subgoal 4:

  Variables: M, P, Map, FVs, CM2, M2, CM1, M1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {cc (M1 n1) (CM1 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  H4 : {cc (M2 n1) (CM2 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  H5 : {ctm n2, ctm n3 |- ctm (CM1 n2 n3)}
  ============================
   {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>apply IH to H1 H4.</b>
</pre>
<a name="352"></a>
<pre>
Subgoal 4:

  Variables: M, P, Map, FVs, CM2, M2, CM1, M1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {cc (M1 n1) (CM1 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  H4 : {cc (M2 n1) (CM2 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  H5 : {ctm n2, ctm n3 |- ctm (CM1 n2 n3)}
  H6 : {ctm n2, ctm n3 |- ctm (CM2 n2 n3)}
  ============================
   {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < <b>search.</b>
Proof completed.
</pre>
<a name="353"></a>
<pre class="code">
Abella < <b>Define name_map : map_list -> prop by 
name_map ml_nil;
name_map (ml_cons (map X V) ML) := name_map ML /\ tname X.</b>
</pre>
<a name="354"></a>
<pre class="code">
Abella < <b>Theorem name_map_nominal : 
forall Map X V, name_map Map -> {ml_member (map X V) Map} -> tname X.</b>
</pre>
<a name="355"></a>
<pre>


  ============================
   forall Map X V, name_map Map -> {ml_member (map X V) Map} -> tname X

name_map_nominal < <b>induction on 1.</b>
</pre>
<a name="356"></a>
<pre>


  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  ============================
   forall Map X V, name_map Map @ -> {ml_member (map X V) Map} -> tname X

name_map_nominal < <b>intros.</b>
</pre>
<a name="357"></a>
<pre>

  Variables: Map, X, V
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H1 : name_map Map @
  H2 : {ml_member (map X V) Map}
  ============================
   tname X

name_map_nominal < <b>case H1.</b>
</pre>
<a name="358"></a>
<pre>
Subgoal 1:

  Variables: Map, X, V
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H2 : {ml_member (map X V) ml_nil}
  ============================
   tname X

Subgoal 2 is:
 tname X

name_map_nominal < <b>case H2.</b>
</pre>
<a name="359"></a>
<pre>
Subgoal 2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H2 : {ml_member (map X V) (ml_cons (map X1 V1) ML)}
  H3 : name_map ML *
  H4 : tname X1
  ============================
   tname X

name_map_nominal < <b>case H2.</b>
</pre>
<a name="360"></a>
<pre>
Subgoal 2.1:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

name_map_nominal < <b>search.</b>
</pre>
<a name="361"></a>
<pre>
Subgoal 2.2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  H5 : {ml_member (map X V) ML}
  ============================
   tname X

name_map_nominal < <b>apply IH to H3 H5.</b>
</pre>
<a name="362"></a>
<pre>
Subgoal 2.2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  H5 : {ml_member (map X V) ML}
  H6 : tname X
  ============================
   tname X

name_map_nominal < <b>search.</b>
Proof completed.
</pre>
<a name="363"></a>
<pre class="code">
Abella < <b>Theorem clos_closed : 
forall Map R E FVs F, nabla x xenv y, name_map (Map xenv) -> env_map Map ->
  {cc (abs (R x)) (cpair (F xenv y) (E xenv y)) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
  {ctm (F xenv y)}.</b>
</pre>
<a name="364"></a>
<pre>


  ============================
   forall Map R E FVs F, nabla x xenv y, name_map (Map xenv) ->
     env_map Map ->
     {cc (abs (R x)) (cpair (F xenv y) (E xenv y)) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
     {ctm (F xenv y)}

clos_closed < <b>intros.</b>
</pre>
<a name="365"></a>
<pre>

  Variables: Map, R, E, FVs, F
  H1 : name_map (Map n2)
  H2 : env_map Map
  H3 : {cc (abs (R n1)) (cpair (F n2 n3) (E n2 n3)) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}
  ============================
   {ctm (F n2 n3)}

clos_closed < <b>case H3.</b>
</pre>
<a name="366"></a>
<pre>
Subgoal 1:

  Variables: Map, R, E, FVs, F
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {ml_member (map (abs (R n1)) (cpair (F n2 n3) (E n2 n3))) (ml_cons (map n1 n3) (Map n2))}
  ============================
   {ctm (F n2 n3)}

Subgoal 2 is:
 {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < <b>case H4.</b>
</pre>
<a name="367"></a>
<pre>
Subgoal 1:

  Variables: Map, R, E, FVs, F
  H1 : name_map (Map n2)
  H2 : env_map Map
  H5 : {ml_member (map (abs (R n1)) (cpair (F n2 n3) (E n2 n3))) (Map n2)}
  ============================
   {ctm (F n2 n3)}

Subgoal 2 is:
 {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < <b>assert name_map (Map n2).</b>
</pre>
<a name="368"></a>
<pre>
Subgoal 1:

  Variables: Map, R, E, FVs, F
  H1 : name_map (Map n2)
  H2 : env_map Map
  H5 : {ml_member (map (abs (R n1)) (cpair (F n2 n3) (E n2 n3))) (Map n2)}
  H6 : name_map (Map n2)
  ============================
   {ctm (F n2 n3)}

Subgoal 2 is:
 {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < <b>apply name_map_nominal to H6 H5.</b>
</pre>
<a name="369"></a>
<pre>
Subgoal 1:

  Variables: Map, R, E, FVs, F
  H1 : name_map (Map n2)
  H2 : env_map Map
  H5 : {ml_member (map (abs (R n1)) (cpair (F n2 n3) (E n2 n3))) (Map n2)}
  H6 : name_map (Map n2)
  H7 : tname (abs (R n1))
  ============================
   {ctm (F n2 n3)}

Subgoal 2 is:
 {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < <b>case H7.</b>
</pre>
<a name="370"></a>
<pre>
Subgoal 2:

  Variables: Map, R, E, FVs, F, NFVs, NMap, P
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {fvars (abs (R n1)) (tl_cons n1 FVs) (NFVs n1)}
  H5 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (E n2 n3)}
  H6 : {mapvar (NFVs n1) (NMap n1 n2 n3)}
  H7 : {cc (R n1 n4) (P n2 n3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n2 n3 n6)) (tl_cons n4 (NFVs n1))}
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < <b>apply mapvar_prune to H6.</b>
</pre>
<a name="371"></a>
<pre>
Subgoal 2:

  Variables: Map, R, E, FVs, F, NFVs, NMap, P, ML'
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {fvars (abs (R n1)) (tl_cons n1 FVs) (NFVs n1)}
  H5 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (E n2 n3)}
  H6 : {mapvar (NFVs n1) (ML' n3 n1)}
  H7 : {cc (R n1 n4) (P n2 n3 n6 n5) (ml_cons (map n4 n5) (ML' n3 n1 n6)) (tl_cons n4 (NFVs n1))}
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < <b>apply mapvar_prune to H6.</b>
</pre>
<a name="372"></a>
<pre>
Subgoal 2:

  Variables: Map, R, E, FVs, F, NFVs, NMap, P, ML', ML'1
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {fvars (abs (R n1)) (tl_cons n1 FVs) (NFVs n1)}
  H5 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (E n2 n3)}
  H6 : {mapvar (NFVs n1) (ML'1 n1)}
  H7 : {cc (R n1 n4) (P n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < <b>apply mapvar_env_map to H6.</b>
</pre>
<a name="373"></a>
<pre>
Subgoal 2:

  Variables: Map, R, E, FVs, F, NFVs, NMap, P, ML', ML'1
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {fvars (abs (R n1)) (tl_cons n1 FVs) (NFVs n1)}
  H5 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (E n2 n3)}
  H6 : {mapvar (NFVs n1) (ML'1 n1)}
  H7 : {cc (R n1 n4) (P n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}
  H8 : env_map (ML'1 n1)
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < <b>apply cc_ctm to H8 H7.</b>
</pre>
<a name="374"></a>
<pre>
Subgoal 2:

  Variables: Map, R, E, FVs, F, NFVs, NMap, P, ML', ML'1
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {fvars (abs (R n1)) (tl_cons n1 FVs) (NFVs n1)}
  H5 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (E n2 n3)}
  H6 : {mapvar (NFVs n1) (ML'1 n1)}
  H7 : {cc (R n1 n4) (P n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}
  H8 : env_map (ML'1 n1)
  H9 : {ctm n6, ctm n5 |- ctm (P n2 n3 n6 n5)}
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < <b>search.</b>
Proof completed.
</pre>
<a name="375"></a>
<pre class="code">
Abella < <b>Theorem val_eval : 
forall V, {val V} -> {eval V V}.</b>
</pre>
<a name="376"></a>
<pre>


  ============================
   forall V, {val V} -> {eval V V}

val_eval < <b>intros.</b>
</pre>
<a name="377"></a>
<pre>

  Variables: V
  H1 : {val V}
  ============================
   {eval V V}

val_eval < <b>case H1.</b>
</pre>
<a name="378"></a>
<pre>
Subgoal 1:

  Variables: V, N
  ============================
   {eval (lnat N) (lnat N)}

Subgoal 2 is:
 {eval (abs F) (abs F)}

val_eval < <b>search.</b>
</pre>
<a name="379"></a>
<pre>
Subgoal 2:

  Variables: V, F
  ============================
   {eval (abs F) (abs F)}

val_eval < <b>search.</b>
Proof completed.
</pre>
<a name="380"></a>
<pre class="code">
Abella < <b>Theorem val_eval_refl : 
forall V M, {val V} -> {eval V M} -> V = M.</b>
</pre>
<a name="381"></a>
<pre>


  ============================
   forall V M, {val V} -> {eval V M} -> V = M

val_eval_refl < <b>induction on 1.</b>
</pre>
<a name="382"></a>
<pre>


  IH : forall V M, {val V}* -> {eval V M} -> V = M
  ============================
   forall V M, {val V}@ -> {eval V M} -> V = M

val_eval_refl < <b>intros.</b>
</pre>
<a name="383"></a>
<pre>

  Variables: V, M
  IH : forall V M, {val V}* -> {eval V M} -> V = M
  H1 : {val V}@
  H2 : {eval V M}
  ============================
   V = M

val_eval_refl < <b>case H1.</b>
</pre>
<a name="384"></a>
<pre>
Subgoal 1:

  Variables: V, M, N
  IH : forall V M, {val V}* -> {eval V M} -> V = M
  H2 : {eval (lnat N) M}
  ============================
   lnat N = M

Subgoal 2 is:
 abs F = M

val_eval_refl < <b>case H2.</b>
</pre>
<a name="385"></a>
<pre>
Subgoal 1:

  Variables: V, M, N
  IH : forall V M, {val V}* -> {eval V M} -> V = M
  ============================
   lnat N = lnat N

Subgoal 2 is:
 abs F = M

val_eval_refl < <b>search.</b>
</pre>
<a name="386"></a>
<pre>
Subgoal 2:

  Variables: V, M, F
  IH : forall V M, {val V}* -> {eval V M} -> V = M
  H2 : {eval (abs F) M}
  ============================
   abs F = M

val_eval_refl < <b>case H2.</b>
</pre>
<a name="387"></a>
<pre>
Subgoal 2:

  Variables: V, M, F
  IH : forall V M, {val V}* -> {eval V M} -> V = M
  ============================
   abs F = abs F

val_eval_refl < <b>search.</b>
Proof completed.
</pre>
<a name="388"></a>
<pre class="code">
Abella < <b>Theorem eval_val : 
forall M M', {eval M M'} -> {val M'}.</b>
</pre>
<a name="389"></a>
<pre>


  ============================
   forall M M', {eval M M'} -> {val M'}

eval_val < <b>induction on 1.</b>
</pre>
<a name="390"></a>
<pre>


  IH : forall M M', {eval M M'}* -> {val M'}
  ============================
   forall M M', {eval M M'}@ -> {val M'}

eval_val < <b>intros.</b>
</pre>
<a name="391"></a>
<pre>

  Variables: M, M'
  IH : forall M M', {eval M M'}* -> {val M'}
  H1 : {eval M M'}@
  ============================
   {val M'}

eval_val < <b>case H1.</b>
</pre>
<a name="392"></a>
<pre>
Subgoal 1:

  Variables: M, M', X
  IH : forall M M', {eval M M'}* -> {val M'}
  ============================
   {val (lnat X)}

Subgoal 2 is:
 {val M'}

Subgoal 3 is:
 {val (abs F)}

eval_val < <b>search.</b>
</pre>
<a name="393"></a>
<pre>
Subgoal 2:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {eval M M'}* -> {val M'}
  H2 : {eval M1 (abs F)}*
  H3 : {eval M2 V2}*
  H4 : {eval (F V2) M'}*
  ============================
   {val M'}

Subgoal 3 is:
 {val (abs F)}

eval_val < <b>apply IH to H2.</b>
</pre>
<a name="394"></a>
<pre>
Subgoal 2:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {eval M M'}* -> {val M'}
  H2 : {eval M1 (abs F)}*
  H3 : {eval M2 V2}*
  H4 : {eval (F V2) M'}*
  H5 : {val (abs F)}
  ============================
   {val M'}

Subgoal 3 is:
 {val (abs F)}

eval_val < <b>apply IH to H3.</b>
</pre>
<a name="395"></a>
<pre>
Subgoal 2:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {eval M M'}* -> {val M'}
  H2 : {eval M1 (abs F)}*
  H3 : {eval M2 V2}*
  H4 : {eval (F V2) M'}*
  H5 : {val (abs F)}
  H6 : {val V2}
  ============================
   {val M'}

Subgoal 3 is:
 {val (abs F)}

eval_val < <b>apply IH to H4.</b>
</pre>
<a name="396"></a>
<pre>
Subgoal 2:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {eval M M'}* -> {val M'}
  H2 : {eval M1 (abs F)}*
  H3 : {eval M2 V2}*
  H4 : {eval (F V2) M'}*
  H5 : {val (abs F)}
  H6 : {val V2}
  H7 : {val M'}
  ============================
   {val M'}

Subgoal 3 is:
 {val (abs F)}

eval_val < <b>search.</b>
</pre>
<a name="397"></a>
<pre>
Subgoal 3:

  Variables: M, M', F
  IH : forall M M', {eval M M'}* -> {val M'}
  ============================
   {val (abs F)}

eval_val < <b>search.</b>
Proof completed.
</pre>
<a name="398"></a>
<pre class="code">
Abella < <b>Theorem eval_trans : 
forall M1 M2 M3, {eval M1 M2} -> {eval M2 M3} -> {eval M1 M3}.</b>
</pre>
<a name="399"></a>
<pre>


  ============================
   forall M1 M2 M3, {eval M1 M2} -> {eval M2 M3} -> {eval M1 M3}

eval_trans < <b>intros.</b>
</pre>
<a name="400"></a>
<pre>

  Variables: M1, M2, M3
  H1 : {eval M1 M2}
  H2 : {eval M2 M3}
  ============================
   {eval M1 M3}

eval_trans < <b>apply eval_val to H1.</b>
</pre>
<a name="401"></a>
<pre>

  Variables: M1, M2, M3
  H1 : {eval M1 M2}
  H2 : {eval M2 M3}
  H3 : {val M2}
  ============================
   {eval M1 M3}

eval_trans < <b>apply val_eval_refl to H3 H2.</b>
</pre>
<a name="402"></a>
<pre>

  Variables: M1, M2, M3
  H1 : {eval M1 M3}
  H2 : {eval M3 M3}
  H3 : {val M3}
  ============================
   {eval M1 M3}

eval_trans < <b>search.</b>
Proof completed.
</pre>
<a name="403"></a>
<pre class="code">
Abella < <b>Theorem eval_app_trans : 
forall E1 E2 V1 V2 V, {eval E1 V1} -> {eval E2 V2} -> {eval (app V1 V2) V} ->
  {eval (app E1 E2) V}.</b>
</pre>
<a name="404"></a>
<pre>


  ============================
   forall E1 E2 V1 V2 V, {eval E1 V1} -> {eval E2 V2} ->
     {eval (app V1 V2) V} -> {eval (app E1 E2) V}

eval_app_trans < <b>intros.</b>
</pre>
<a name="405"></a>
<pre>

  Variables: E1, E2, V1, V2, V
  H1 : {eval E1 V1}
  H2 : {eval E2 V2}
  H3 : {eval (app V1 V2) V}
  ============================
   {eval (app E1 E2) V}

eval_app_trans < <b>case H3.</b>
</pre>
<a name="406"></a>
<pre>

  Variables: E1, E2, V1, V2, V, V3, F
  H1 : {eval E1 V1}
  H2 : {eval E2 V2}
  H4 : {eval V1 (abs F)}
  H5 : {eval V2 V3}
  H6 : {eval (F V3) V}
  ============================
   {eval (app E1 E2) V}

eval_app_trans < <b>apply eval_trans to H1 H4.</b>
</pre>
<a name="407"></a>
<pre>

  Variables: E1, E2, V1, V2, V, V3, F
  H1 : {eval E1 V1}
  H2 : {eval E2 V2}
  H4 : {eval V1 (abs F)}
  H5 : {eval V2 V3}
  H6 : {eval (F V3) V}
  H7 : {eval E1 (abs F)}
  ============================
   {eval (app E1 E2) V}

eval_app_trans < <b>apply eval_trans to H2 H5.</b>
</pre>
<a name="408"></a>
<pre>

  Variables: E1, E2, V1, V2, V, V3, F
  H1 : {eval E1 V1}
  H2 : {eval E2 V2}
  H4 : {eval V1 (abs F)}
  H5 : {eval V2 V3}
  H6 : {eval (F V3) V}
  H7 : {eval E1 (abs F)}
  H8 : {eval E2 V3}
  ============================
   {eval (app E1 E2) V}

eval_app_trans < <b>search.</b>
Proof completed.
</pre>
<a name="409"></a>
<pre class="code">
Abella < <b>Theorem val_evalcc : 
forall V, {cval V} -> {evalcc V V}.</b>
</pre>
<a name="410"></a>
<pre>


  ============================
   forall V, {cval V} -> {evalcc V V}

val_evalcc < <b>induction on 1.</b>
</pre>
<a name="411"></a>
<pre>


  IH : forall V, {cval V}* -> {evalcc V V}
  ============================
   forall V, {cval V}@ -> {evalcc V V}

val_evalcc < <b>intros.</b>
</pre>
<a name="412"></a>
<pre>

  Variables: V
  IH : forall V, {cval V}* -> {evalcc V V}
  H1 : {cval V}@
  ============================
   {evalcc V V}

val_evalcc < <b>case H1.</b>
</pre>
<a name="413"></a>
<pre>
Subgoal 1:

  Variables: V
  IH : forall V, {cval V}* -> {evalcc V V}
  ============================
   {evalcc unit unit}

Subgoal 2 is:
 {evalcc (cross V1 V2) (cross V1 V2)}

Subgoal 3 is:
 {evalcc (clnat Num) (clnat Num)}

Subgoal 4 is:
 {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < <b>search.</b>
</pre>
<a name="414"></a>
<pre>
Subgoal 2:

  Variables: V, V2, V1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval V1}*
  H3 : {cval V2}*
  ============================
   {evalcc (cross V1 V2) (cross V1 V2)}

Subgoal 3 is:
 {evalcc (clnat Num) (clnat Num)}

Subgoal 4 is:
 {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < <b>apply IH to H2.</b>
</pre>
<a name="415"></a>
<pre>
Subgoal 2:

  Variables: V, V2, V1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval V1}*
  H3 : {cval V2}*
  H4 : {evalcc V1 V1}
  ============================
   {evalcc (cross V1 V2) (cross V1 V2)}

Subgoal 3 is:
 {evalcc (clnat Num) (clnat Num)}

Subgoal 4 is:
 {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < <b>apply IH to H3.</b>
</pre>
<a name="416"></a>
<pre>
Subgoal 2:

  Variables: V, V2, V1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval V1}*
  H3 : {cval V2}*
  H4 : {evalcc V1 V1}
  H5 : {evalcc V2 V2}
  ============================
   {evalcc (cross V1 V2) (cross V1 V2)}

Subgoal 3 is:
 {evalcc (clnat Num) (clnat Num)}

Subgoal 4 is:
 {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < <b>search.</b>
</pre>
<a name="417"></a>
<pre>
Subgoal 3:

  Variables: V, Num
  IH : forall V, {cval V}* -> {evalcc V V}
  ============================
   {evalcc (clnat Num) (clnat Num)}

Subgoal 4 is:
 {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < <b>search.</b>
</pre>
<a name="418"></a>
<pre>
Subgoal 4:

  Variables: V, F
  IH : forall V, {cval V}* -> {evalcc V V}
  ============================
   {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < <b>search.</b>
</pre>
<a name="419"></a>
<pre>
Subgoal 5:

  Variables: V, N2, N1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval N1}*
  H3 : {cval N2}*
  ============================
   {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < <b>apply IH to H2.</b>
</pre>
<a name="420"></a>
<pre>
Subgoal 5:

  Variables: V, N2, N1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval N1}*
  H3 : {cval N2}*
  H4 : {evalcc N1 N1}
  ============================
   {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < <b>apply IH to H3.</b>
</pre>
<a name="421"></a>
<pre>
Subgoal 5:

  Variables: V, N2, N1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval N1}*
  H3 : {cval N2}*
  H4 : {evalcc N1 N1}
  H5 : {evalcc N2 N2}
  ============================
   {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < <b>search.</b>
Proof completed.
</pre>
<a name="422"></a>
<pre class="code">
Abella < <b>Theorem val_evalcc_refl : 
forall V M, {cval V} -> {evalcc V M} -> V = M.</b>
</pre>
<a name="423"></a>
<pre>


  ============================
   forall V M, {cval V} -> {evalcc V M} -> V = M

val_evalcc_refl < <b>induction on 1.</b>
</pre>
<a name="424"></a>
<pre>


  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  ============================
   forall V M, {cval V}@ -> {evalcc V M} -> V = M

val_evalcc_refl < <b>intros.</b>
</pre>
<a name="425"></a>
<pre>

  Variables: V, M
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H1 : {cval V}@
  H2 : {evalcc V M}
  ============================
   V = M

val_evalcc_refl < <b>case H1.</b>
</pre>
<a name="426"></a>
<pre>
Subgoal 1:

  Variables: V, M
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H2 : {evalcc unit M}
  ============================
   unit = M

Subgoal 2 is:
 cross V1 V2 = M

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < <b>case H2.</b>
</pre>
<a name="427"></a>
<pre>
Subgoal 1:

  Variables: V, M
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  ============================
   unit = unit

Subgoal 2 is:
 cross V1 V2 = M

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < <b>search.</b>
</pre>
<a name="428"></a>
<pre>
Subgoal 2:

  Variables: V, M, V2, V1
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H2 : {evalcc (cross V1 V2) M}
  H3 : {cval V1}*
  H4 : {cval V2}*
  ============================
   cross V1 V2 = M

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < <b>case H2.</b>
</pre>
<a name="429"></a>
<pre>
Subgoal 2:

  Variables: V, M, V2, V1, ML', M'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval V1}*
  H4 : {cval V2}*
  H5 : {evalcc V1 M'}
  H6 : {evalcc V2 ML'}
  ============================
   cross V1 V2 = cross M' ML'

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < <b>apply IH to H3 H5.</b>
</pre>
<a name="430"></a>
<pre>
Subgoal 2:

  Variables: V, M, V2, V1, ML', M'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval M'}*
  H4 : {cval V2}*
  H5 : {evalcc M' M'}
  H6 : {evalcc V2 ML'}
  ============================
   cross M' V2 = cross M' ML'

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < <b>apply IH to H4 H6.</b>
</pre>
<a name="431"></a>
<pre>
Subgoal 2:

  Variables: V, M, V2, V1, ML', M'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval M'}*
  H4 : {cval ML'}*
  H5 : {evalcc M' M'}
  H6 : {evalcc ML' ML'}
  ============================
   cross M' ML' = cross M' ML'

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < <b>search.</b>
</pre>
<a name="432"></a>
<pre>
Subgoal 3:

  Variables: V, M, Num
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H2 : {evalcc (clnat Num) M}
  ============================
   clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < <b>case H2.</b>
</pre>
<a name="433"></a>
<pre>
Subgoal 3:

  Variables: V, M, Num
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  ============================
   clnat Num = clnat Num

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < <b>search.</b>
</pre>
<a name="434"></a>
<pre>
Subgoal 4:

  Variables: V, M, F
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H2 : {evalcc (cabs F) M}
  ============================
   cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < <b>case H2.</b>
</pre>
<a name="435"></a>
<pre>
Subgoal 4:

  Variables: V, M, F
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  ============================
   cabs F = cabs F

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < <b>search.</b>
</pre>
<a name="436"></a>
<pre>
Subgoal 5:

  Variables: V, M, N2, N1
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H2 : {evalcc (cpair N1 N2) M}
  H3 : {cval N1}*
  H4 : {cval N2}*
  ============================
   cpair N1 N2 = M

val_evalcc_refl < <b>case H2.</b>
</pre>
<a name="437"></a>
<pre>
Subgoal 5:

  Variables: V, M, N2, N1, E', F'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval N1}*
  H4 : {cval N2}*
  H5 : {evalcc N1 F'}
  H6 : {evalcc N2 E'}
  ============================
   cpair N1 N2 = cpair F' E'

val_evalcc_refl < <b>apply IH to H3 H5.</b>
</pre>
<a name="438"></a>
<pre>
Subgoal 5:

  Variables: V, M, N2, N1, E', F'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval F'}*
  H4 : {cval N2}*
  H5 : {evalcc F' F'}
  H6 : {evalcc N2 E'}
  ============================
   cpair F' N2 = cpair F' E'

val_evalcc_refl < <b>apply IH to H4 H6.</b>
</pre>
<a name="439"></a>
<pre>
Subgoal 5:

  Variables: V, M, N2, N1, E', F'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval F'}*
  H4 : {cval E'}*
  H5 : {evalcc F' F'}
  H6 : {evalcc E' E'}
  ============================
   cpair F' E' = cpair F' E'

val_evalcc_refl < <b>search.</b>
Proof completed.
</pre>
<a name="440"></a>
<pre class="code">
Abella < <b>Theorem evalcc_val : 
forall M M', {evalcc M M'} -> {cval M'}.</b>
</pre>
<a name="441"></a>
<pre>


  ============================
   forall M M', {evalcc M M'} -> {cval M'}

evalcc_val < <b>induction on 1.</b>
</pre>
<a name="442"></a>
<pre>


  IH : forall M M', {evalcc M M'}* -> {cval M'}
  ============================
   forall M M', {evalcc M M'}@ -> {cval M'}

evalcc_val < <b>intros.</b>
</pre>
<a name="443"></a>
<pre>

  Variables: M, M'
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H1 : {evalcc M M'}@
  ============================
   {cval M'}

evalcc_val < <b>case H1.</b>
</pre>
<a name="444"></a>
<pre>
Subgoal 1:

  Variables: M, M'
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  ============================
   {cval unit}

Subgoal 2 is:
 {cval (cross M'1 ML')}

Subgoal 3 is:
 {cval (clnat N)}

Subgoal 4 is:
 {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>search.</b>
</pre>
<a name="445"></a>
<pre>
Subgoal 2:

  Variables: M, M', ML', ML, M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc ML ML'}*
  ============================
   {cval (cross M'1 ML')}

Subgoal 3 is:
 {cval (clnat N)}

Subgoal 4 is:
 {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>apply IH to H2.</b>
</pre>
<a name="446"></a>
<pre>
Subgoal 2:

  Variables: M, M', ML', ML, M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc ML ML'}*
  H4 : {cval M'1}
  ============================
   {cval (cross M'1 ML')}

Subgoal 3 is:
 {cval (clnat N)}

Subgoal 4 is:
 {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>apply IH to H3.</b>
</pre>
<a name="447"></a>
<pre>
Subgoal 2:

  Variables: M, M', ML', ML, M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc ML ML'}*
  H4 : {cval M'1}
  H5 : {cval ML'}
  ============================
   {cval (cross M'1 ML')}

Subgoal 3 is:
 {cval (clnat N)}

Subgoal 4 is:
 {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>search.</b>
</pre>
<a name="448"></a>
<pre>
Subgoal 3:

  Variables: M, M', N
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  ============================
   {cval (clnat N)}

Subgoal 4 is:
 {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>search.</b>
</pre>
<a name="449"></a>
<pre>
Subgoal 4:

  Variables: M, M', M'1, F, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc (F M'1) M'}*
  ============================
   {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>apply IH to H2.</b>
</pre>
<a name="450"></a>
<pre>
Subgoal 4:

  Variables: M, M', M'1, F, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc (F M'1) M'}*
  H4 : {cval M'1}
  ============================
   {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>apply IH to H3.</b>
</pre>
<a name="451"></a>
<pre>
Subgoal 4:

  Variables: M, M', M'1, F, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc (F M'1) M'}*
  H4 : {cval M'1}
  H5 : {cval M'}
  ============================
   {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>search.</b>
</pre>
<a name="452"></a>
<pre>
Subgoal 5:

  Variables: M, M', ML', M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M' ML')}*
  ============================
   {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>apply IH to H2.</b>
</pre>
<a name="453"></a>
<pre>
Subgoal 5:

  Variables: M, M', ML', M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M' ML')}*
  H3 : {cval (cross M' ML')}
  ============================
   {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>case H3.</b>
</pre>
<a name="454"></a>
<pre>
Subgoal 5:

  Variables: M, M', ML', M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M' ML')}*
  H4 : {cval M'}
  H5 : {cval ML'}
  ============================
   {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>search.</b>
</pre>
<a name="455"></a>
<pre>
Subgoal 6:

  Variables: M, M', M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M'1 M')}*
  ============================
   {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>apply IH to H2.</b>
</pre>
<a name="456"></a>
<pre>
Subgoal 6:

  Variables: M, M', M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M'1 M')}*
  H3 : {cval (cross M'1 M')}
  ============================
   {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>case H3.</b>
</pre>
<a name="457"></a>
<pre>
Subgoal 6:

  Variables: M, M', M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M'1 M')}*
  H4 : {cval M'1}
  H5 : {cval M'}
  ============================
   {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>search.</b>
</pre>
<a name="458"></a>
<pre>
Subgoal 7:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cabs F)}*
  H3 : {evalcc M2 V2}*
  H4 : {evalcc (F V2) M'}*
  ============================
   {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>apply IH to H4.</b>
</pre>
<a name="459"></a>
<pre>
Subgoal 7:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cabs F)}*
  H3 : {evalcc M2 V2}*
  H4 : {evalcc (F V2) M'}*
  H5 : {cval M'}
  ============================
   {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>search.</b>
</pre>
<a name="460"></a>
<pre>
Subgoal 8:

  Variables: M, M', F
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  ============================
   {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>search.</b>
</pre>
<a name="461"></a>
<pre>
Subgoal 9:

  Variables: M, M', E', E, F', F
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc F F'}*
  H3 : {evalcc E E'}*
  ============================
   {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>apply IH to H2.</b>
</pre>
<a name="462"></a>
<pre>
Subgoal 9:

  Variables: M, M', E', E, F', F
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc F F'}*
  H3 : {evalcc E E'}*
  H4 : {cval F'}
  ============================
   {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>apply IH to H3.</b>
</pre>
<a name="463"></a>
<pre>
Subgoal 9:

  Variables: M, M', E', E, F', F
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc F F'}*
  H3 : {evalcc E E'}*
  H4 : {cval F'}
  H5 : {cval E'}
  ============================
   {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < <b>search.</b>
</pre>
<a name="464"></a>
<pre>
Subgoal 10:

  Variables: M, M', E, F, B, PPE'
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc PPE' (cpair F E)}*
  H3 : {evalcc (B F E) M'}*
  ============================
   {cval M'}

evalcc_val < <b>apply IH to H3.</b>
</pre>
<a name="465"></a>
<pre>
Subgoal 10:

  Variables: M, M', E, F, B, PPE'
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc PPE' (cpair F E)}*
  H3 : {evalcc (B F E) M'}*
  H4 : {cval M'}
  ============================
   {cval M'}

evalcc_val < <b>search.</b>
Proof completed.
</pre>
<a name="466"></a>
<pre class="code">
Abella < <b>Theorem evalcc_trans : 
forall M1 M2 M3, {evalcc M1 M2} -> {evalcc M2 M3} -> {evalcc M1 M3}.</b>
</pre>
<a name="467"></a>
<pre>


  ============================
   forall M1 M2 M3, {evalcc M1 M2} -> {evalcc M2 M3} -> {evalcc M1 M3}

evalcc_trans < <b>intros.</b>
</pre>
<a name="468"></a>
<pre>

  Variables: M1, M2, M3
  H1 : {evalcc M1 M2}
  H2 : {evalcc M2 M3}
  ============================
   {evalcc M1 M3}

evalcc_trans < <b>apply evalcc_val to H1.</b>
</pre>
<a name="469"></a>
<pre>

  Variables: M1, M2, M3
  H1 : {evalcc M1 M2}
  H2 : {evalcc M2 M3}
  H3 : {cval M2}
  ============================
   {evalcc M1 M3}

evalcc_trans < <b>apply val_evalcc_refl to H3 H2.</b>
</pre>
<a name="470"></a>
<pre>

  Variables: M1, M2, M3
  H1 : {evalcc M1 M3}
  H2 : {evalcc M3 M3}
  H3 : {cval M3}
  ============================
   {evalcc M1 M3}

evalcc_trans < <b>search.</b>
Proof completed.
</pre>
<a name="471"></a>
<pre class="code">
Abella < <b>Theorem evalcc_det : 
forall E V V', {evalcc E V} -> {evalcc E V'} -> V = V'.</b>
</pre>
<a name="472"></a>
<pre>


  ============================
   forall E V V', {evalcc E V} -> {evalcc E V'} -> V = V'

evalcc_det < <b>induction on 1.</b>
</pre>
<a name="473"></a>
<pre>


  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  ============================
   forall E V V', {evalcc E V}@ -> {evalcc E V'} -> V = V'

evalcc_det < <b>intros.</b>
</pre>
<a name="474"></a>
<pre>

  Variables: E, V, V'
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H1 : {evalcc E V}@
  H2 : {evalcc E V'}
  ============================
   V = V'

evalcc_det < <b>case H1.</b>
</pre>
<a name="475"></a>
<pre>
Subgoal 1:

  Variables: E, V, V'
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc unit V'}
  ============================
   unit = V'

Subgoal 2 is:
 cross M' ML' = V'

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>case H2.</b>
</pre>
<a name="476"></a>
<pre>
Subgoal 1:

  Variables: E, V, V'
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  ============================
   unit = unit

Subgoal 2 is:
 cross M' ML' = V'

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>search.</b>
</pre>
<a name="477"></a>
<pre>
Subgoal 2:

  Variables: E, V, V', ML', ML, M', M
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (cross M ML) V'}
  H3 : {evalcc M M'}*
  H4 : {evalcc ML ML'}*
  ============================
   cross M' ML' = V'

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>case H2.</b>
</pre>
<a name="478"></a>
<pre>
Subgoal 2:

  Variables: E, V, V', ML', ML, M', M, ML'1, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'}*
  H4 : {evalcc ML ML'}*
  H5 : {evalcc M M'1}
  H6 : {evalcc ML ML'1}
  ============================
   cross M' ML' = cross M'1 ML'1

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>apply IH to H3 H5.</b>
</pre>
<a name="479"></a>
<pre>
Subgoal 2:

  Variables: E, V, V', ML', ML, M', M, ML'1, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'1}*
  H4 : {evalcc ML ML'}*
  H5 : {evalcc M M'1}
  H6 : {evalcc ML ML'1}
  ============================
   cross M'1 ML' = cross M'1 ML'1

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>apply IH to H4 H6.</b>
</pre>
<a name="480"></a>
<pre>
Subgoal 2:

  Variables: E, V, V', ML', ML, M', M, ML'1, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'1}*
  H4 : {evalcc ML ML'1}*
  H5 : {evalcc M M'1}
  H6 : {evalcc ML ML'1}
  ============================
   cross M'1 ML'1 = cross M'1 ML'1

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>search.</b>
</pre>
<a name="481"></a>
<pre>
Subgoal 3:

  Variables: E, V, V', N
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (clnat N) V'}
  ============================
   clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>case H2.</b>
</pre>
<a name="482"></a>
<pre>
Subgoal 3:

  Variables: E, V, V', N
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  ============================
   clnat N = clnat N

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>search.</b>
</pre>
<a name="483"></a>
<pre>
Subgoal 4:

  Variables: E, V, V', M', F, M
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (clet M F) V'}
  H3 : {evalcc M M'}*
  H4 : {evalcc (F M') V}*
  ============================
   V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>case H2.</b>
</pre>
<a name="484"></a>
<pre>
Subgoal 4:

  Variables: E, V, V', M', F, M, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'}*
  H4 : {evalcc (F M') V}*
  H5 : {evalcc M M'1}
  H6 : {evalcc (F M'1) V'}
  ============================
   V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>apply IH to H3 H5.</b>
</pre>
<a name="485"></a>
<pre>
Subgoal 4:

  Variables: E, V, V', M', F, M, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'1}*
  H4 : {evalcc (F M'1) V}*
  H5 : {evalcc M M'1}
  H6 : {evalcc (F M'1) V'}
  ============================
   V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>apply IH to H4 H6.</b>
</pre>
<a name="486"></a>
<pre>
Subgoal 4:

  Variables: E, V, V', M', F, M, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'1}*
  H4 : {evalcc (F M'1) V'}*
  H5 : {evalcc M M'1}
  H6 : {evalcc (F M'1) V'}
  ============================
   V' = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>search.</b>
</pre>
<a name="487"></a>
<pre>
Subgoal 5:

  Variables: E, V, V', ML', M
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (fst M) V'}
  H3 : {evalcc M (cross V ML')}*
  ============================
   V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>case H2.</b>
</pre>
<a name="488"></a>
<pre>
Subgoal 5:

  Variables: E, V, V', ML', M, ML'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M (cross V ML')}*
  H4 : {evalcc M (cross V' ML'1)}
  ============================
   V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>apply IH to H3 H4.</b>
</pre>
<a name="489"></a>
<pre>
Subgoal 5:

  Variables: E, V, V', ML', M, ML'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M (cross V' ML'1)}*
  H4 : {evalcc M (cross V' ML'1)}
  ============================
   V' = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>search.</b>
</pre>
<a name="490"></a>
<pre>
Subgoal 6:

  Variables: E, V, V', M', M
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (rst M) V'}
  H3 : {evalcc M (cross M' V)}*
  ============================
   V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>case H2.</b>
</pre>
<a name="491"></a>
<pre>
Subgoal 6:

  Variables: E, V, V', M', M, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M (cross M' V)}*
  H4 : {evalcc M (cross M'1 V')}
  ============================
   V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>apply IH to H3 H4.</b>
</pre>
<a name="492"></a>
<pre>
Subgoal 6:

  Variables: E, V, V', M', M, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M (cross M'1 V')}*
  H4 : {evalcc M (cross M'1 V')}
  ============================
   V' = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>search.</b>
</pre>
<a name="493"></a>
<pre>
Subgoal 7:

  Variables: E, V, V', V2, F, M2, M1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (capp M1 M2) V'}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) V}*
  ============================
   V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>case H2.</b>
</pre>
<a name="494"></a>
<pre>
Subgoal 7:

  Variables: E, V, V', V2, F, M2, M1, V1, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) V}*
  H6 : {evalcc M1 (cabs F1)}
  H7 : {evalcc M2 V1}
  H8 : {evalcc (F1 V1) V'}
  ============================
   V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>apply IH to H3 H6.</b>
</pre>
<a name="495"></a>
<pre>
Subgoal 7:

  Variables: E, V, V', V2, F, M2, M1, V1, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M1 (cabs F1)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F1 V2) V}*
  H6 : {evalcc M1 (cabs F1)}
  H7 : {evalcc M2 V1}
  H8 : {evalcc (F1 V1) V'}
  ============================
   V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>apply IH to H4 H7.</b>
</pre>
<a name="496"></a>
<pre>
Subgoal 7:

  Variables: E, V, V', V2, F, M2, M1, V1, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M1 (cabs F1)}*
  H4 : {evalcc M2 V1}*
  H5 : {evalcc (F1 V1) V}*
  H6 : {evalcc M1 (cabs F1)}
  H7 : {evalcc M2 V1}
  H8 : {evalcc (F1 V1) V'}
  ============================
   V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>apply IH to H5 H8.</b>
</pre>
<a name="497"></a>
<pre>
Subgoal 7:

  Variables: E, V, V', V2, F, M2, M1, V1, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M1 (cabs F1)}*
  H4 : {evalcc M2 V1}*
  H5 : {evalcc (F1 V1) V'}*
  H6 : {evalcc M1 (cabs F1)}
  H7 : {evalcc M2 V1}
  H8 : {evalcc (F1 V1) V'}
  ============================
   V' = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>search.</b>
</pre>
<a name="498"></a>
<pre>
Subgoal 8:

  Variables: E, V, V', F
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (cabs F) V'}
  ============================
   cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>case H2.</b>
</pre>
<a name="499"></a>
<pre>
Subgoal 8:

  Variables: E, V, V', F
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  ============================
   cabs F = cabs F

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>search.</b>
</pre>
<a name="500"></a>
<pre>
Subgoal 9:

  Variables: E, V, V', E', E1, F', F
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (cpair F E1) V'}
  H3 : {evalcc F F'}*
  H4 : {evalcc E1 E'}*
  ============================
   cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < <b>case H2.</b>
</pre>
<a name="501"></a>
<pre>
Subgoal 9:

  Variables: E, V, V', E', E1, F', F, E'1, F'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc F F'}*
  H4 : {evalcc E1 E'}*
  H5 : {evalcc F F'1}
  H6 : {evalcc E1 E'1}
  ============================
   cpair F' E' = cpair F'1 E'1

Subgoal 10 is:
 V = V'

evalcc_det < <b>apply IH to H3 H5.</b>
</pre>
<a name="502"></a>
<pre>
Subgoal 9:

  Variables: E, V, V', E', E1, F', F, E'1, F'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc F F'1}*
  H4 : {evalcc E1 E'}*
  H5 : {evalcc F F'1}
  H6 : {evalcc E1 E'1}
  ============================
   cpair F'1 E' = cpair F'1 E'1

Subgoal 10 is:
 V = V'

evalcc_det < <b>apply IH to H4 H6.</b>
</pre>
<a name="503"></a>
<pre>
Subgoal 9:

  Variables: E, V, V', E', E1, F', F, E'1, F'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc F F'1}*
  H4 : {evalcc E1 E'1}*
  H5 : {evalcc F F'1}
  H6 : {evalcc E1 E'1}
  ============================
   cpair F'1 E'1 = cpair F'1 E'1

Subgoal 10 is:
 V = V'

evalcc_det < <b>search.</b>
</pre>
<a name="504"></a>
<pre>
Subgoal 10:

  Variables: E, V, V', E1, F, B, PPE'
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (cunpair PPE' B) V'}
  H3 : {evalcc PPE' (cpair F E1)}*
  H4 : {evalcc (B F E1) V}*
  ============================
   V = V'

evalcc_det < <b>case H2.</b>
</pre>
<a name="505"></a>
<pre>
Subgoal 10:

  Variables: E, V, V', E1, F, B, PPE', E2, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc PPE' (cpair F E1)}*
  H4 : {evalcc (B F E1) V}*
  H5 : {evalcc PPE' (cpair F1 E2)}
  H6 : {evalcc (B F1 E2) V'}
  ============================
   V = V'

evalcc_det < <b>apply IH to H3 H5.</b>
</pre>
<a name="506"></a>
<pre>
Subgoal 10:

  Variables: E, V, V', E1, F, B, PPE', E2, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc PPE' (cpair F1 E2)}*
  H4 : {evalcc (B F1 E2) V}*
  H5 : {evalcc PPE' (cpair F1 E2)}
  H6 : {evalcc (B F1 E2) V'}
  ============================
   V = V'

evalcc_det < <b>apply IH to H4 H6.</b>
</pre>
<a name="507"></a>
<pre>
Subgoal 10:

  Variables: E, V, V', E1, F, B, PPE', E2, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc PPE' (cpair F1 E2)}*
  H4 : {evalcc (B F1 E2) V'}*
  H5 : {evalcc PPE' (cpair F1 E2)}
  H6 : {evalcc (B F1 E2) V'}
  ============================
   V' = V'

evalcc_det < <b>search.</b>
Proof completed.
</pre>
<a name="508"></a>
<pre class="code">
Abella < <b>Theorem env_elem_aux_eval_cong : 
forall E E1 E2 V V', env_elem_aux E -> {evalcc E1 V} -> {evalcc E2 V} ->
  {evalcc (E E1) V'} -> {evalcc (E E2) V'}.</b>
</pre>
<a name="509"></a>
<pre>


  ============================
   forall E E1 E2 V V', env_elem_aux E -> {evalcc E1 V} -> {evalcc E2 V} ->
     {evalcc (E E1) V'} -> {evalcc (E E2) V'}

env_elem_aux_eval_cong < <b>induction on 1.</b>
</pre>
<a name="510"></a>
<pre>


  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  ============================
   forall E E1 E2 V V', env_elem_aux E @ -> {evalcc E1 V} -> {evalcc E2 V} ->
     {evalcc (E E1) V'} -> {evalcc (E E2) V'}

env_elem_aux_eval_cong < <b>intros.</b>
</pre>
<a name="511"></a>
<pre>

  Variables: E, E1, E2, V, V'
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H1 : env_elem_aux E @
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H4 : {evalcc (E E1) V'}
  ============================
   {evalcc (E E2) V'}

env_elem_aux_eval_cong < <b>case H1.</b>
</pre>
<a name="512"></a>
<pre>
Subgoal 1:

  Variables: E, E1, E2, V, V'
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H4 : {evalcc E1 V'}
  ============================
   {evalcc E2 V'}

Subgoal 2 is:
 {evalcc (rst (R E2)) V'}

env_elem_aux_eval_cong < <b>apply evalcc_det to H2 H4.</b>
</pre>
<a name="513"></a>
<pre>
Subgoal 1:

  Variables: E, E1, E2, V, V'
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H2 : {evalcc E1 V'}
  H3 : {evalcc E2 V'}
  H4 : {evalcc E1 V'}
  ============================
   {evalcc E2 V'}

Subgoal 2 is:
 {evalcc (rst (R E2)) V'}

env_elem_aux_eval_cong < <b>search.</b>
</pre>
<a name="514"></a>
<pre>
Subgoal 2:

  Variables: E, E1, E2, V, V', R
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H4 : {evalcc (rst (R E1)) V'}
  H5 : env_elem_aux R *
  ============================
   {evalcc (rst (R E2)) V'}

env_elem_aux_eval_cong < <b>case H4.</b>
</pre>
<a name="515"></a>
<pre>
Subgoal 2:

  Variables: E, E1, E2, V, V', R, M'
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H5 : env_elem_aux R *
  H6 : {evalcc (R E1) (cross M' V')}
  ============================
   {evalcc (rst (R E2)) V'}

env_elem_aux_eval_cong < <b>apply IH to H5 H2 H3 H6.</b>
</pre>
<a name="516"></a>
<pre>
Subgoal 2:

  Variables: E, E1, E2, V, V', R, M'
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H5 : env_elem_aux R *
  H6 : {evalcc (R E1) (cross M' V')}
  H7 : {evalcc (R E2) (cross M' V')}
  ============================
   {evalcc (rst (R E2)) V'}

env_elem_aux_eval_cong < <b>search.</b>
Proof completed.
</pre>
<a name="517"></a>
<pre class="code">
Abella < <b>Theorem env_elem_eval_cong : 
forall E E1 E2 V V', env_elem E -> {evalcc E1 V} -> {evalcc E2 V} ->
  {evalcc (E E1) V'} -> {evalcc (E E2) V'}.</b>
</pre>
<a name="518"></a>
<pre>


  ============================
   forall E E1 E2 V V', env_elem E -> {evalcc E1 V} -> {evalcc E2 V} ->
     {evalcc (E E1) V'} -> {evalcc (E E2) V'}

env_elem_eval_cong < <b>intros.</b>
</pre>
<a name="519"></a>
<pre>

  Variables: E, E1, E2, V, V'
  H1 : env_elem E
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H4 : {evalcc (E E1) V'}
  ============================
   {evalcc (E E2) V'}

env_elem_eval_cong < <b>case H1.</b>
</pre>
<a name="520"></a>
<pre>

  Variables: E, E1, E2, V, V', R
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H4 : {evalcc (fst (R E1)) V'}
  H5 : env_elem_aux R
  ============================
   {evalcc (fst (R E2)) V'}

env_elem_eval_cong < <b>case H4.</b>
</pre>
<a name="521"></a>
<pre>

  Variables: E, E1, E2, V, V', R, ML'
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H5 : env_elem_aux R
  H6 : {evalcc (R E1) (cross V' ML')}
  ============================
   {evalcc (fst (R E2)) V'}

env_elem_eval_cong < <b>apply env_elem_aux_eval_cong to H5 H2 H3 H6.</b>
</pre>
<a name="522"></a>
<pre>

  Variables: E, E1, E2, V, V', R, ML'
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H5 : env_elem_aux R
  H6 : {evalcc (R E1) (cross V' ML')}
  H7 : {evalcc (R E2) (cross V' ML')}
  ============================
   {evalcc (fst (R E2)) V'}

env_elem_eval_cong < <b>search.</b>
Proof completed.
</pre>
<a name="523"></a>
<pre class="code">
Abella < <b>Theorem evalcc_ctm_pres : 
forall M N, {evalcc M N} -> {ctm M} -> {ctm N}.</b>
</pre>
<a name="524"></a>
<pre>


  ============================
   forall M N, {evalcc M N} -> {ctm M} -> {ctm N}

evalcc_ctm_pres < <b>induction on 1.</b>
</pre>
<a name="525"></a>
<pre>


  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  ============================
   forall M N, {evalcc M N}@ -> {ctm M} -> {ctm N}

evalcc_ctm_pres < <b>intros.</b>
</pre>
<a name="526"></a>
<pre>

  Variables: M, N
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H1 : {evalcc M N}@
  H2 : {ctm M}
  ============================
   {ctm N}

evalcc_ctm_pres < <b>case H1.</b>
</pre>
<a name="527"></a>
<pre>
Subgoal 1:

  Variables: M, N
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm unit}
  ============================
   {ctm unit}

Subgoal 2 is:
 {ctm (cross M' ML')}

Subgoal 3 is:
 {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>search.</b>
</pre>
<a name="528"></a>
<pre>
Subgoal 2:

  Variables: M, N, ML', ML, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (cross M1 ML)}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc ML ML'}*
  ============================
   {ctm (cross M' ML')}

Subgoal 3 is:
 {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>case H2.</b>
</pre>
<a name="529"></a>
<pre>
Subgoal 2:

  Variables: M, N, ML', ML, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc ML ML'}*
  H5 : {ctm M1}
  H6 : {ctm ML}
  ============================
   {ctm (cross M' ML')}

Subgoal 3 is:
 {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>apply IH to H3 H5.</b>
</pre>
<a name="530"></a>
<pre>
Subgoal 2:

  Variables: M, N, ML', ML, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc ML ML'}*
  H5 : {ctm M1}
  H6 : {ctm ML}
  H7 : {ctm M'}
  ============================
   {ctm (cross M' ML')}

Subgoal 3 is:
 {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>apply IH to H4 H6.</b>
</pre>
<a name="531"></a>
<pre>
Subgoal 2:

  Variables: M, N, ML', ML, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc ML ML'}*
  H5 : {ctm M1}
  H6 : {ctm ML}
  H7 : {ctm M'}
  H8 : {ctm ML'}
  ============================
   {ctm (cross M' ML')}

Subgoal 3 is:
 {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>search.</b>
</pre>
<a name="532"></a>
<pre>
Subgoal 3:

  Variables: M, N, N1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (clnat N1)}
  ============================
   {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>search.</b>
</pre>
<a name="533"></a>
<pre>
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (clet M1 F)}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>case H2.</b>
</pre>
<a name="534"></a>
<pre>
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  H5 : {ctm M1}
  H6 : {ctm n1 |- ctm (F n1)}
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>apply IH to H3 H5.</b>
</pre>
<a name="535"></a>
<pre>
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  H5 : {ctm M1}
  H6 : {ctm n1 |- ctm (F n1)}
  H7 : {ctm M'}
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>inst H6 with n1 = M'.</b>
</pre>
<a name="536"></a>
<pre>
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  H5 : {ctm M1}
  H6 : {ctm n1 |- ctm (F n1)}
  H7 : {ctm M'}
  H8 : {ctm M' |- ctm (F M')}
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>cut H8 with H7.</b>
</pre>
<a name="537"></a>
<pre>
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  H5 : {ctm M1}
  H6 : {ctm n1 |- ctm (F n1)}
  H7 : {ctm M'}
  H8 : {ctm M' |- ctm (F M')}
  H9 : {ctm (F M')}
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>apply IH to H4 H9.</b>
</pre>
<a name="538"></a>
<pre>
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  H5 : {ctm M1}
  H6 : {ctm n1 |- ctm (F n1)}
  H7 : {ctm M'}
  H8 : {ctm M' |- ctm (F M')}
  H9 : {ctm (F M')}
  H10 : {ctm N}
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>search.</b>
</pre>
<a name="539"></a>
<pre>
Subgoal 5:

  Variables: M, N, ML', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (fst M1)}
  H3 : {evalcc M1 (cross N ML')}*
  ============================
   {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>case H2.</b>
</pre>
<a name="540"></a>
<pre>
Subgoal 5:

  Variables: M, N, ML', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross N ML')}*
  H4 : {ctm M1}
  ============================
   {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>apply IH to H3 H4.</b>
</pre>
<a name="541"></a>
<pre>
Subgoal 5:

  Variables: M, N, ML', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross N ML')}*
  H4 : {ctm M1}
  H5 : {ctm (cross N ML')}
  ============================
   {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>case H5.</b>
</pre>
<a name="542"></a>
<pre>
Subgoal 5:

  Variables: M, N, ML', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross N ML')}*
  H4 : {ctm M1}
  H6 : {ctm N}
  H7 : {ctm ML'}
  ============================
   {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>search.</b>
</pre>
<a name="543"></a>
<pre>
Subgoal 6:

  Variables: M, N, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (rst M1)}
  H3 : {evalcc M1 (cross M' N)}*
  ============================
   {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>case H2.</b>
</pre>
<a name="544"></a>
<pre>
Subgoal 6:

  Variables: M, N, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross M' N)}*
  H4 : {ctm M1}
  ============================
   {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>apply IH to H3 H4.</b>
</pre>
<a name="545"></a>
<pre>
Subgoal 6:

  Variables: M, N, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross M' N)}*
  H4 : {ctm M1}
  H5 : {ctm (cross M' N)}
  ============================
   {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>case H5.</b>
</pre>
<a name="546"></a>
<pre>
Subgoal 6:

  Variables: M, N, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross M' N)}*
  H4 : {ctm M1}
  H6 : {ctm M'}
  H7 : {ctm N}
  ============================
   {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>search.</b>
</pre>
<a name="547"></a>
<pre>
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (capp M1 M2)}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>case H2.</b>
</pre>
<a name="548"></a>
<pre>
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>apply IH to H3 H6.</b>
</pre>
<a name="549"></a>
<pre>
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H8 : {ctm (cabs F)}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>apply IH to H4 H7.</b>
</pre>
<a name="550"></a>
<pre>
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H8 : {ctm (cabs F)}
  H9 : {ctm V2}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>case H8.</b>
</pre>
<a name="551"></a>
<pre>
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H9 : {ctm V2}
  H10 : {ctm n1 |- ctm (F n1)}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>inst H10 with n1 = V2.</b>
</pre>
<a name="552"></a>
<pre>
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H9 : {ctm V2}
  H10 : {ctm n1 |- ctm (F n1)}
  H11 : {ctm V2 |- ctm (F V2)}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>cut H11 with H9.</b>
</pre>
<a name="553"></a>
<pre>
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H9 : {ctm V2}
  H10 : {ctm n1 |- ctm (F n1)}
  H11 : {ctm V2 |- ctm (F V2)}
  H12 : {ctm (F V2)}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>apply IH to H5 H12.</b>
</pre>
<a name="554"></a>
<pre>
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H9 : {ctm V2}
  H10 : {ctm n1 |- ctm (F n1)}
  H11 : {ctm V2 |- ctm (F V2)}
  H12 : {ctm (F V2)}
  H13 : {ctm N}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>search.</b>
</pre>
<a name="555"></a>
<pre>
Subgoal 8:

  Variables: M, N, F
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (cabs F)}
  ============================
   {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>search.</b>
</pre>
<a name="556"></a>
<pre>
Subgoal 9:

  Variables: M, N, E', E, F', F
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (cpair F E)}
  H3 : {evalcc F F'}*
  H4 : {evalcc E E'}*
  ============================
   {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>case H2.</b>
</pre>
<a name="557"></a>
<pre>
Subgoal 9:

  Variables: M, N, E', E, F', F
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc F F'}*
  H4 : {evalcc E E'}*
  H5 : {ctm F}
  H6 : {ctm E}
  ============================
   {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>apply IH to H3 H5.</b>
</pre>
<a name="558"></a>
<pre>
Subgoal 9:

  Variables: M, N, E', E, F', F
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc F F'}*
  H4 : {evalcc E E'}*
  H5 : {ctm F}
  H6 : {ctm E}
  H7 : {ctm F'}
  ============================
   {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>apply IH to H4 H6.</b>
</pre>
<a name="559"></a>
<pre>
Subgoal 9:

  Variables: M, N, E', E, F', F
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc F F'}*
  H4 : {evalcc E E'}*
  H5 : {ctm F}
  H6 : {ctm E}
  H7 : {ctm F'}
  H8 : {ctm E'}
  ============================
   {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < <b>search.</b>
</pre>
<a name="560"></a>
<pre>
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (cunpair PPE' B)}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  ============================
   {ctm N}

evalcc_ctm_pres < <b>case H2.</b>
</pre>
<a name="561"></a>
<pre>
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  ============================
   {ctm N}

evalcc_ctm_pres < <b>apply IH to H3 H5.</b>
</pre>
<a name="562"></a>
<pre>
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H7 : {ctm (cpair F E)}
  ============================
   {ctm N}

evalcc_ctm_pres < <b>case H7.</b>
</pre>
<a name="563"></a>
<pre>
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  ============================
   {ctm N}

evalcc_ctm_pres < <b>inst H6 with n1 = F.</b>
</pre>
<a name="564"></a>
<pre>
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  H10 : {ctm F, ctm n2 |- ctm (B F n2)}
  ============================
   {ctm N}

evalcc_ctm_pres < <b>inst H10 with n2 = E.</b>
</pre>
<a name="565"></a>
<pre>
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  H10 : {ctm F, ctm n2 |- ctm (B F n2)}
  H11 : {ctm F, ctm E |- ctm (B F E)}
  ============================
   {ctm N}

evalcc_ctm_pres < <b>cut H11 with H8.</b>
</pre>
<a name="566"></a>
<pre>
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  H10 : {ctm F, ctm n2 |- ctm (B F n2)}
  H11 : {ctm F, ctm E |- ctm (B F E)}
  H12 : {ctm E |- ctm (B F E)}
  ============================
   {ctm N}

evalcc_ctm_pres < <b>cut H12 with H9.</b>
</pre>
<a name="567"></a>
<pre>
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  H10 : {ctm F, ctm n2 |- ctm (B F n2)}
  H11 : {ctm F, ctm E |- ctm (B F E)}
  H12 : {ctm E |- ctm (B F E)}
  H13 : {ctm (B F E)}
  ============================
   {ctm N}

evalcc_ctm_pres < <b>apply IH to H4 H13.</b>
</pre>
<a name="568"></a>
<pre>
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  H10 : {ctm F, ctm n2 |- ctm (B F n2)}
  H11 : {ctm F, ctm E |- ctm (B F E)}
  H12 : {ctm E |- ctm (B F E)}
  H13 : {ctm (B F E)}
  H14 : {ctm N}
  ============================
   {ctm N}

evalcc_ctm_pres < <b>search.</b>
Proof completed.
</pre>
<a name="569"></a>
<pre class="code">
Abella < <b>Theorem evalcc_capp_trans : 
forall E V F E1 V1, {evalcc E V} -> {evalcc (capp F (cross V E1)) V1} ->
  {evalcc (capp F (cross E E1)) V1}.</b>
</pre>
<a name="570"></a>
<pre>


  ============================
   forall E V F E1 V1, {evalcc E V} -> {evalcc (capp F (cross V E1)) V1} ->
     {evalcc (capp F (cross E E1)) V1}

evalcc_capp_trans < <b>intros.</b>
</pre>
<a name="571"></a>
<pre>

  Variables: E, V, F, E1, V1
  H1 : {evalcc E V}
  H2 : {evalcc (capp F (cross V E1)) V1}
  ============================
   {evalcc (capp F (cross E E1)) V1}

evalcc_capp_trans < <b>case H2.</b>
</pre>
<a name="572"></a>
<pre>

  Variables: E, V, F, E1, V1, V2, F1
  H1 : {evalcc E V}
  H3 : {evalcc F (cabs F1)}
  H4 : {evalcc (cross V E1) V2}
  H5 : {evalcc (F1 V2) V1}
  ============================
   {evalcc (capp F (cross E E1)) V1}

evalcc_capp_trans < <b>case H4.</b>
</pre>
<a name="573"></a>
<pre>

  Variables: E, V, F, E1, V1, V2, F1, ML', M'
  H1 : {evalcc E V}
  H3 : {evalcc F (cabs F1)}
  H5 : {evalcc (F1 (cross M' ML')) V1}
  H6 : {evalcc V M'}
  H7 : {evalcc E1 ML'}
  ============================
   {evalcc (capp F (cross E E1)) V1}

evalcc_capp_trans < <b>apply evalcc_trans to H1 H6.</b>
</pre>
<a name="574"></a>
<pre>

  Variables: E, V, F, E1, V1, V2, F1, ML', M'
  H1 : {evalcc E V}
  H3 : {evalcc F (cabs F1)}
  H5 : {evalcc (F1 (cross M' ML')) V1}
  H6 : {evalcc V M'}
  H7 : {evalcc E1 ML'}
  H8 : {evalcc E M'}
  ============================
   {evalcc (capp F (cross E E1)) V1}

evalcc_capp_trans < <b>search.</b>
Proof completed.
</pre>
<a name="575"></a>
<pre class="code">
Abella < <b>Define sctx' : olist -> prop by 
sctx' nil;
sctx' (of X T :: L) := sctx' L /\ tname X /\ (forall T', member (of X T') L -> T = T').</b>
</pre>
<a name="576"></a>
<pre class="code">
Abella < <b>Define cctx' : olist -> prop by 
cctx' nil;
cctx' (cof X T :: L) := cctx' L /\ ctname X /\ (forall T', member (cof X T') L -> T = T').</b>
</pre>
<a name="577"></a>
<pre class="code">
Abella < <b>Theorem sctx'_name : 
forall X T L, sctx' L -> member (of X T) L -> tname X.</b>
</pre>
<a name="578"></a>
<pre>


  ============================
   forall X T L, sctx' L -> member (of X T) L -> tname X

sctx'_name < <b>induction on 1.</b>
</pre>
<a name="579"></a>
<pre>


  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  ============================
   forall X T L, sctx' L @ -> member (of X T) L -> tname X

sctx'_name < <b>intros.</b>
</pre>
<a name="580"></a>
<pre>

  Variables: X, T, L
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H1 : sctx' L @
  H2 : member (of X T) L
  ============================
   tname X

sctx'_name < <b>case H1.</b>
</pre>
<a name="581"></a>
<pre>
Subgoal 1:

  Variables: X, T, L
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H2 : member (of X T) nil
  ============================
   tname X

Subgoal 2 is:
 tname X

sctx'_name < <b>case H2.</b>
</pre>
<a name="582"></a>
<pre>
Subgoal 2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H2 : member (of X T) (of X1 T1 :: L1)
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   tname X

sctx'_name < <b>case H2.</b>
</pre>
<a name="583"></a>
<pre>
Subgoal 2.1:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

sctx'_name < <b>search.</b>
</pre>
<a name="584"></a>
<pre>
Subgoal 2.2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  H6 : member (of X T) L1
  ============================
   tname X

sctx'_name < <b>apply IH to H3 H6.</b>
</pre>
<a name="585"></a>
<pre>
Subgoal 2.2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  H6 : member (of X T) L1
  H7 : tname X
  ============================
   tname X

sctx'_name < <b>search.</b>
Proof completed.
</pre>
<a name="586"></a>
<pre class="code">
Abella < <b>Theorem sctx'_mem : 
forall SL O, sctx' SL -> member O SL -> (exists X T, O = of X T /\ tname X).</b>
</pre>
<a name="587"></a>
<pre>


  ============================
   forall SL O, sctx' SL -> member O SL -> (exists X T, O = of X T /\
     tname X)

sctx'_mem < <b>induction on 1.</b>
</pre>
<a name="588"></a>
<pre>


  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  ============================
   forall SL O, sctx' SL @ -> member O SL -> (exists X T, O = of X T /\
     tname X)

sctx'_mem < <b>intros.</b>
</pre>
<a name="589"></a>
<pre>

  Variables: SL, O
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H1 : sctx' SL @
  H2 : member O SL
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < <b>case H1.</b>
</pre>
<a name="590"></a>
<pre>
Subgoal 1:

  Variables: SL, O
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H2 : member O nil
  ============================
   exists X T, O = of X T /\ tname X

Subgoal 2 is:
 exists X T, O = of X T /\ tname X

sctx'_mem < <b>case H2.</b>
</pre>
<a name="591"></a>
<pre>
Subgoal 2:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H2 : member O (of X T :: L)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < <b>case H2.</b>
</pre>
<a name="592"></a>
<pre>
Subgoal 2.1:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  ============================
   exists X1 T1, of X T = of X1 T1 /\ tname X1

Subgoal 2.2 is:
 exists X T, O = of X T /\ tname X

sctx'_mem < <b>search.</b>
</pre>
<a name="593"></a>
<pre>
Subgoal 2.2:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  H6 : member O L
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < <b>apply IH to H3 H6.</b>
</pre>
<a name="594"></a>
<pre>
Subgoal 2.2:

  Variables: SL, O, L, T, X, X1, T1
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  H6 : member (of X1 T1) L
  H7 : tname X1
  ============================
   exists X T, of X1 T1 = of X T /\ tname X

sctx'_mem < <b>search.</b>
Proof completed.
</pre>
<a name="595"></a>
<pre class="code">
Abella < <b>Theorem sctx'_extend : 
forall L T, nabla x, sctx' L -> sctx' (of x T :: L).</b>
</pre>
<a name="596"></a>
<pre>


  ============================
   forall L T, nabla x, sctx' L -> sctx' (of x T :: L)

sctx'_extend < <b>intros.</b>
</pre>
<a name="597"></a>
<pre>

  Variables: L, T
  H1 : sctx' L
  ============================
   sctx' (of n1 T :: L)

sctx'_extend < <b>unfold.</b>
</pre>
<a name="598"></a>
<pre>
Subgoal 1:

  Variables: L, T
  H1 : sctx' L
  ============================
   sctx' L

Subgoal 2 is:
 tname n1

Subgoal 3 is:
 forall T', member (of n1 T') L -> T = T'

sctx'_extend < <b>search.</b>
</pre>
<a name="599"></a>
<pre>
Subgoal 2:

  Variables: L, T
  H1 : sctx' L
  ============================
   tname n1

Subgoal 3 is:
 forall T', member (of n1 T') L -> T = T'

sctx'_extend < <b>search.</b>
</pre>
<a name="600"></a>
<pre>
Subgoal 3:

  Variables: L, T
  H1 : sctx' L
  ============================
   forall T', member (of n1 T') L -> T = T'

sctx'_extend < <b>intros.</b>
</pre>
<a name="601"></a>
<pre>
Subgoal 3:

  Variables: L, T, T'
  H1 : sctx' L
  H2 : member (of n1 T') L
  ============================
   T = T'

sctx'_extend < <b>apply mem_of_absurd to H2.</b>
Proof completed.
</pre>
<a name="602"></a>
<pre class="code">
Abella < <b>Theorem sctx'_equal : 
forall L X T T', sctx' L -> member (of X T) L -> member (of X T') L -> T = T'.</b>
</pre>
<a name="603"></a>
<pre>


  ============================
   forall L X T T', sctx' L -> member (of X T) L -> member (of X T') L ->
     T = T'

sctx'_equal < <b>induction on 1.</b>
</pre>
<a name="604"></a>
<pre>


  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  ============================
   forall L X T T', sctx' L @ -> member (of X T) L -> member (of X T') L ->
     T = T'

sctx'_equal < <b>intros.</b>
</pre>
<a name="605"></a>
<pre>

  Variables: L, X, T, T'
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H1 : sctx' L @
  H2 : member (of X T) L
  H3 : member (of X T') L
  ============================
   T = T'

sctx'_equal < <b>case H1.</b>
</pre>
<a name="606"></a>
<pre>
Subgoal 1:

  Variables: L, X, T, T'
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H2 : member (of X T) nil
  H3 : member (of X T') nil
  ============================
   T = T'

Subgoal 2 is:
 T = T'

sctx'_equal < <b>case H2.</b>
</pre>
<a name="607"></a>
<pre>
Subgoal 2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H2 : member (of X T) (of X1 T1 :: L1)
  H3 : member (of X T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T = T'

sctx'_equal < <b>case H2.</b>
</pre>
<a name="608"></a>
<pre>
Subgoal 2.1:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H3 : member (of X1 T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < <b>case H3.</b>
</pre>
<a name="609"></a>
<pre>
Subgoal 2.1.1:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T1 = T1

Subgoal 2.1.2 is:
 T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < <b>search.</b>
</pre>
<a name="610"></a>
<pre>
Subgoal 2.1.2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X1 T') L1
  ============================
   T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < <b>apply H6 to H7.</b>
</pre>
<a name="611"></a>
<pre>
Subgoal 2.1.2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T'1, member (of X1 T'1) L1 -> T' = T'1
  H7 : member (of X1 T') L1
  ============================
   T' = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < <b>search.</b>
</pre>
<a name="612"></a>
<pre>
Subgoal 2.2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H3 : member (of X T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T) L1
  ============================
   T = T'

sctx'_equal < <b>case H3.</b>
</pre>
<a name="613"></a>
<pre>
Subgoal 2.2.1:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X1 T) L1
  ============================
   T = T1

Subgoal 2.2.2 is:
 T = T'

sctx'_equal < <b>apply H6 to H7.</b>
</pre>
<a name="614"></a>
<pre>
Subgoal 2.2.1:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  H7 : member (of X1 T) L1
  ============================
   T = T

Subgoal 2.2.2 is:
 T = T'

sctx'_equal < <b>search.</b>
</pre>
<a name="615"></a>
<pre>
Subgoal 2.2.2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T) L1
  H8 : member (of X T') L1
  ============================
   T = T'

sctx'_equal < <b>apply IH to H4 H7 H8.</b>
</pre>
<a name="616"></a>
<pre>
Subgoal 2.2.2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T') L1
  H8 : member (of X T') L1
  ============================
   T' = T'

sctx'_equal < <b>search.</b>
Proof completed.
</pre>
<a name="617"></a>
<pre class="code">
Abella < <b>Theorem cctx'_mem : 
forall SL O, cctx' SL -> member O SL -> (exists X T, O = cof X T /\ ctname X).</b>
</pre>
<a name="618"></a>
<pre>


  ============================
   forall SL O, cctx' SL -> member O SL -> (exists X T, O = cof X T /\
     ctname X)

cctx'_mem < <b>induction on 1.</b>
</pre>
<a name="619"></a>
<pre>


  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  ============================
   forall SL O, cctx' SL @ -> member O SL -> (exists X T, O = cof X T /\
     ctname X)

cctx'_mem < <b>intros.</b>
</pre>
<a name="620"></a>
<pre>

  Variables: SL, O
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H1 : cctx' SL @
  H2 : member O SL
  ============================
   exists X T, O = cof X T /\ ctname X

cctx'_mem < <b>case H1.</b>
</pre>
<a name="621"></a>
<pre>
Subgoal 1:

  Variables: SL, O
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H2 : member O nil
  ============================
   exists X T, O = cof X T /\ ctname X

Subgoal 2 is:
 exists X T, O = cof X T /\ ctname X

cctx'_mem < <b>case H2.</b>
</pre>
<a name="622"></a>
<pre>
Subgoal 2:

  Variables: SL, O, L, T, X
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H2 : member O (cof X T :: L)
  H3 : cctx' L *
  H4 : ctname X
  H5 : forall T', member (cof X T') L -> T = T'
  ============================
   exists X T, O = cof X T /\ ctname X

cctx'_mem < <b>case H2.</b>
</pre>
<a name="623"></a>
<pre>
Subgoal 2.1:

  Variables: SL, O, L, T, X
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H3 : cctx' L *
  H4 : ctname X
  H5 : forall T', member (cof X T') L -> T = T'
  ============================
   exists X1 T1, cof X T = cof X1 T1 /\ ctname X1

Subgoal 2.2 is:
 exists X T, O = cof X T /\ ctname X

cctx'_mem < <b>search.</b>
</pre>
<a name="624"></a>
<pre>
Subgoal 2.2:

  Variables: SL, O, L, T, X
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H3 : cctx' L *
  H4 : ctname X
  H5 : forall T', member (cof X T') L -> T = T'
  H6 : member O L
  ============================
   exists X T, O = cof X T /\ ctname X

cctx'_mem < <b>apply IH to H3 H6.</b>
</pre>
<a name="625"></a>
<pre>
Subgoal 2.2:

  Variables: SL, O, L, T, X, X1, T1
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H3 : cctx' L *
  H4 : ctname X
  H5 : forall T', member (cof X T') L -> T = T'
  H6 : member (cof X1 T1) L
  H7 : ctname X1
  ============================
   exists X T, cof X1 T1 = cof X T /\ ctname X

cctx'_mem < <b>search.</b>
Proof completed.
</pre>
<a name="626"></a>
<pre class="code">
Abella < <b>Theorem cctx'_extend : 
forall L T, nabla x, cctx' L -> cctx' (cof x T :: L).</b>
</pre>
<a name="627"></a>
<pre>


  ============================
   forall L T, nabla x, cctx' L -> cctx' (cof x T :: L)

cctx'_extend < <b>intros.</b>
</pre>
<a name="628"></a>
<pre>

  Variables: L, T
  H1 : cctx' L
  ============================
   cctx' (cof n1 T :: L)

cctx'_extend < <b>unfold.</b>
</pre>
<a name="629"></a>
<pre>
Subgoal 1:

  Variables: L, T
  H1 : cctx' L
  ============================
   cctx' L

Subgoal 2 is:
 ctname n1

Subgoal 3 is:
 forall T', member (cof n1 T') L -> T = T'

cctx'_extend < <b>search.</b>
</pre>
<a name="630"></a>
<pre>
Subgoal 2:

  Variables: L, T
  H1 : cctx' L
  ============================
   ctname n1

Subgoal 3 is:
 forall T', member (cof n1 T') L -> T = T'

cctx'_extend < <b>search.</b>
</pre>
<a name="631"></a>
<pre>
Subgoal 3:

  Variables: L, T
  H1 : cctx' L
  ============================
   forall T', member (cof n1 T') L -> T = T'

cctx'_extend < <b>intros.</b>
</pre>
<a name="632"></a>
<pre>
Subgoal 3:

  Variables: L, T, T'
  H1 : cctx' L
  H2 : member (cof n1 T') L
  ============================
   T = T'

cctx'_extend < <b>apply mem_of_absurd' to H2.</b>
Proof completed.
</pre>
<a name="633"></a>
<pre class="code">
Abella < <b>Theorem of_mem : 
forall X T L, member (of X T) L -> {L |- of X T}.</b>
</pre>
<a name="634"></a>
<pre>


  ============================
   forall X T L, member (of X T) L -> {L |- of X T}

of_mem < <b>intros.</b>
</pre>
<a name="635"></a>
<pre>

  Variables: X, T, L
  H1 : member (of X T) L
  ============================
   {L |- of X T}

of_mem < <b>search.</b>
Proof completed.
</pre>
<a name="636"></a>
<pre class="code">
Abella < <b>Theorem of_nat : 
forall L N T, sctx' L -> {L |- of (lnat N) T} -> T = nat_t.</b>
</pre>
<a name="637"></a>
<pre>


  ============================
   forall L N T, sctx' L -> {L |- of (lnat N) T} -> T = nat_t

of_nat < <b>intros.</b>
</pre>
<a name="638"></a>
<pre>

  Variables: L, N, T
  H1 : sctx' L
  H2 : {L |- of (lnat N) T}
  ============================
   T = nat_t

of_nat < <b>case H2.</b>
</pre>
<a name="639"></a>
<pre>
Subgoal 1:

  Variables: L, N, T
  H1 : sctx' L
  ============================
   nat_t = nat_t

Subgoal 2 is:
 T = nat_t

of_nat < <b>search.</b>
</pre>
<a name="640"></a>
<pre>
Subgoal 2:

  Variables: L, N, T, F
  H1 : sctx' L
  H3 : {L, [F] |- of (lnat N) T}
  H4 : member F L
  ============================
   T = nat_t

of_nat < <b>apply sctx'_mem to H1 H4.</b>
</pre>
<a name="641"></a>
<pre>
Subgoal 2:

  Variables: L, N, T, F, X, T1
  H1 : sctx' L
  H3 : {L, [of X T1] |- of (lnat N) T}
  H4 : member (of X T1) L
  H5 : tname X
  ============================
   T = nat_t

of_nat < <b>case H3.</b>
</pre>
<a name="642"></a>
<pre>
Subgoal 2:

  Variables: L, N, T, F, X, T1
  H1 : sctx' L
  H4 : member (of (lnat N) T) L
  H5 : tname (lnat N)
  ============================
   T = nat_t

of_nat < <b>case H5.</b>
Proof completed.
</pre>
<a name="643"></a>
<pre class="code">
Abella < <b>Define sctx'_rst : o -> olist -> olist -> prop by 
nabla x, sctx'_rst (of x T) (of x T :: L) L;
nabla x, sctx'_rst (of x T) (of Y T' :: L x) (of Y T' :: L') := nabla x, sctx'_rst (of x T) (L x) L'.</b>
</pre>
<a name="644"></a>
<pre class="code">
Abella < <b>Theorem sctx'_rst_mem_str : 
forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' ->
  member (of E T') (L x) -> member (of E T') L'.</b>
</pre>
<a name="645"></a>
<pre>


  ============================
   forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' ->
     member (of E T') (L x) -> member (of E T') L'

sctx'_rst_mem_str < <b>induction on 1.</b>
</pre>
<a name="646"></a>
<pre>


  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  ============================
   forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' @ ->
     member (of E T') (L x) -> member (of E T') L'

sctx'_rst_mem_str < <b>intros.</b>
</pre>
<a name="647"></a>
<pre>

  Variables: T, T', L, L', E
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H1 : sctx'_rst (of n1 T) (L n1) L' @
  H2 : member (of E T') (L n1)
  ============================
   member (of E T') L'

sctx'_rst_mem_str < <b>case H1.</b>
</pre>
<a name="648"></a>
<pre>
Subgoal 1:

  Variables: T, T', L, L', E
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H2 : member (of E T') (of n1 T :: L')
  ============================
   member (of E T') L'

Subgoal 2 is:
 member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < <b>case H2.</b>
</pre>
<a name="649"></a>
<pre>
Subgoal 1:

  Variables: T, T', L, L', E
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H3 : member (of E T') L'
  ============================
   member (of E T') L'

Subgoal 2 is:
 member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < <b>search.</b>
</pre>
<a name="650"></a>
<pre>
Subgoal 2:

  Variables: T, T', L, L', E, L'1, T'1, Y, L1
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H2 : member (of E T') (of Y T'1 :: L1 n1)
  H3 : sctx'_rst (of n1 T) (L1 n1) L'1 *
  ============================
   member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < <b>case H2.</b>
</pre>
<a name="651"></a>
<pre>
Subgoal 2.1:

  Variables: T, T', L, L', E, L'1, T'1, Y, L1
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H3 : sctx'_rst (of n1 T) (L1 n1) L'1 *
  ============================
   member (of Y T'1) (of Y T'1 :: L'1)

Subgoal 2.2 is:
 member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < <b>search.</b>
</pre>
<a name="652"></a>
<pre>
Subgoal 2.2:

  Variables: T, T', L, L', E, L'1, T'1, Y, L1
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H3 : sctx'_rst (of n1 T) (L1 n1) L'1 *
  H4 : member (of E T') (L1 n1)
  ============================
   member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < <b>apply IH to H3 H4.</b>
</pre>
<a name="653"></a>
<pre>
Subgoal 2.2:

  Variables: T, T', L, L', E, L'1, T'1, Y, L1
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H3 : sctx'_rst (of n1 T) (L1 n1) L'1 *
  H4 : member (of E T') (L1 n1)
  H5 : member (of E T') L'1
  ============================
   member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < <b>search.</b>
Proof completed.
</pre>
<a name="654"></a>
<pre class="code">
Abella < <b>Theorem of_strenghten : 
forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'} ->
  sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}.</b>
</pre>
<a name="655"></a>
<pre>


  ============================
   forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'} ->
     sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}

of_strenghten < <b>induction on 2.</b>
</pre>
<a name="656"></a>
<pre>


  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  ============================
   forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}@ ->
     sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}

of_strenghten < <b>intros.</b>
</pre>
<a name="657"></a>
<pre>

  Variables: L, L', T, E, T'
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H2 : {L n1 |- of E T'}@
  H3 : sctx'_rst (of n1 T) (L n1) L'
  ============================
   {L' |- of E T'}

of_strenghten < <b>case H2.</b>
</pre>
<a name="658"></a>
<pre>
Subgoal 1:

  Variables: L, L', T, E, T', X
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  ============================
   {L' |- of (lnat X) nat_t}

Subgoal 2 is:
 {L' |- of (app E1 E2) T'}

Subgoal 3 is:
 {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < <b>search.</b>
</pre>
<a name="659"></a>
<pre>
Subgoal 2:

  Variables: L, L', T, E, T', T1, E2, E1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1 |- of E1 (arr T1 T')}*
  H5 : {L n1 |- of E2 T1}*
  ============================
   {L' |- of (app E1 E2) T'}

Subgoal 3 is:
 {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < <b>apply IH to H1 H4 H3.</b>
</pre>
<a name="660"></a>
<pre>
Subgoal 2:

  Variables: L, L', T, E, T', T1, E2, E1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1 |- of E1 (arr T1 T')}*
  H5 : {L n1 |- of E2 T1}*
  H6 : {L' |- of E1 (arr T1 T')}
  ============================
   {L' |- of (app E1 E2) T'}

Subgoal 3 is:
 {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < <b>apply IH to H1 H5 H3.</b>
</pre>
<a name="661"></a>
<pre>
Subgoal 2:

  Variables: L, L', T, E, T', T1, E2, E1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1 |- of E1 (arr T1 T')}*
  H5 : {L n1 |- of E2 T1}*
  H6 : {L' |- of E1 (arr T1 T')}
  H7 : {L' |- of E2 T1}
  ============================
   {L' |- of (app E1 E2) T'}

Subgoal 3 is:
 {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < <b>search.</b>
</pre>
<a name="662"></a>
<pre>
Subgoal 3:

  Variables: L, L', T, E, T', T2, E1, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, of n2 T1 |- of (E1 n2) T2}*
  ============================
   {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < <b>apply sctx'_extend to H1 with x = n2, T = T1.</b>
</pre>
<a name="663"></a>
<pre>
Subgoal 3:

  Variables: L, L', T, E, T', T2, E1, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, of n2 T1 |- of (E1 n2) T2}*
  H5 : sctx' (of n2 T1 :: L n1)
  ============================
   {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < <b>assert sctx'_rst (of n1 T) (of n2 T1 :: L n1) (of n2 T1 :: L').</b>
</pre>
<a name="664"></a>
<pre>
Subgoal 3:

  Variables: L, L', T, E, T', T2, E1, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, of n2 T1 |- of (E1 n2) T2}*
  H5 : sctx' (of n2 T1 :: L n1)
  H6 : sctx'_rst (of n1 T) (of n2 T1 :: L n1) (of n2 T1 :: L')
  ============================
   {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < <b>apply IH to H5 H4 H6.</b>
</pre>
<a name="665"></a>
<pre>
Subgoal 3:

  Variables: L, L', T, E, T', T2, E1, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, of n2 T1 |- of (E1 n2) T2}*
  H5 : sctx' (of n2 T1 :: L n1)
  H6 : sctx'_rst (of n1 T) (of n2 T1 :: L n1) (of n2 T1 :: L')
  H7 : {L', of n2 T1 |- of (E1 n2) T2}
  ============================
   {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < <b>search.</b>
</pre>
<a name="666"></a>
<pre>
Subgoal 4:

  Variables: L, L', T, E, T', F
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, [F n1] |- of E T'}*
  H5 : member (F n1) (L n1)
  ============================
   {L' |- of E T'}

of_strenghten < <b>apply sctx'_mem to H1 H5.</b>
</pre>
<a name="667"></a>
<pre>
Subgoal 4:

  Variables: L, L', T, E, T', F, X, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, [of (X n1) T1] |- of E T'}*
  H5 : member (of (X n1) T1) (L n1)
  H6 : tname (X n1)
  ============================
   {L' |- of E T'}

of_strenghten < <b>case H4.</b>
</pre>
<a name="668"></a>
<pre>
Subgoal 4:

  Variables: L, L', T, E, T', F, X, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H5 : member (of E T') (L n1)
  H6 : tname E
  ============================
   {L' |- of E T'}

of_strenghten < <b>apply sctx'_rst_mem_str to H3 H5.</b>
</pre>
<a name="669"></a>
<pre>
Subgoal 4:

  Variables: L, L', T, E, T', F, X, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H5 : member (of E T') (L n1)
  H6 : tname E
  H7 : member (of E T') L'
  ============================
   {L' |- of E T'}

of_strenghten < <b>search.</b>
Proof completed.
</pre>
<a name="670"></a>
<pre class="code">
Abella < <b>Theorem of_strenghten' : 
forall L T E T', nabla x, sctx' L -> {L, of x T |- of E T'} -> {L |- of E T'}.</b>
</pre>
<a name="671"></a>
<pre>


  ============================
   forall L T E T', nabla x, sctx' L -> {L, of x T |- of E T'} ->
     {L |- of E T'}

of_strenghten' < <b>intros.</b>
</pre>
<a name="672"></a>
<pre>

  Variables: L, T, E, T'
  H1 : sctx' L
  H2 : {L, of n1 T |- of E T'}
  ============================
   {L |- of E T'}

of_strenghten' < <b>apply sctx'_extend to H1 with x = n1, T = T.</b>
</pre>
<a name="673"></a>
<pre>

  Variables: L, T, E, T'
  H1 : sctx' L
  H2 : {L, of n1 T |- of E T'}
  H3 : sctx' (of n1 T :: L)
  ============================
   {L |- of E T'}

of_strenghten' < <b>assert sctx'_rst (of n1 T) (of n1 T :: L) L.</b>
</pre>
<a name="674"></a>
<pre>

  Variables: L, T, E, T'
  H1 : sctx' L
  H2 : {L, of n1 T |- of E T'}
  H3 : sctx' (of n1 T :: L)
  H4 : sctx'_rst (of n1 T) (of n1 T :: L) L
  ============================
   {L |- of E T'}

of_strenghten' < <b>apply of_strenghten to H3 H2 H4.</b>
</pre>
<a name="675"></a>
<pre>

  Variables: L, T, E, T'
  H1 : sctx' L
  H2 : {L, of n1 T |- of E T'}
  H3 : sctx' (of n1 T :: L)
  H4 : sctx'_rst (of n1 T) (of n1 T :: L) L
  H5 : {L |- of E T'}
  ============================
   {L |- of E T'}

of_strenghten' < <b>search.</b>
Proof completed.
</pre>
<a name="676"></a>
<pre class="code">
Abella < <b>Theorem of_var_mem : 
forall L F T, nabla x, sctx' (L x) -> {L x, [F x] |- of x T} ->
  member (F x) (L x) -> member (of x T) (L x).</b>
</pre>
<a name="677"></a>
<pre>


  ============================
   forall L F T, nabla x, sctx' (L x) -> {L x, [F x] |- of x T} ->
     member (F x) (L x) -> member (of x T) (L x)

of_var_mem < <b>intros.</b>
</pre>
<a name="678"></a>
<pre>

  Variables: L, F, T
  H1 : sctx' (L n1)
  H2 : {L n1, [F n1] |- of n1 T}
  H3 : member (F n1) (L n1)
  ============================
   member (of n1 T) (L n1)

of_var_mem < <b>apply sctx'_mem to H1 H3.</b>
</pre>
<a name="679"></a>
<pre>

  Variables: L, F, T, X, T1
  H1 : sctx' (L n1)
  H2 : {L n1, [of (X n1) T1] |- of n1 T}
  H3 : member (of (X n1) T1) (L n1)
  H4 : tname (X n1)
  ============================
   member (of n1 T) (L n1)

of_var_mem < <b>case H2.</b>
</pre>
<a name="680"></a>
<pre>

  Variables: L, F, T, X, T1
  H1 : sctx' (L n1)
  H3 : member (of n1 T) (L n1)
  H4 : tname n1
  ============================
   member (of n1 T) (L n1)

of_var_mem < <b>search.</b>
Proof completed.
</pre>
<a name="681"></a>
<pre class="code">
Abella < <b>Theorem of_var_inv : 
forall X T L T', sctx' (of X T :: L) -> {L, of X T |- of X T'} -> T = T'.</b>
</pre>
<a name="682"></a>
<pre>


  ============================
   forall X T L T', sctx' (of X T :: L) -> {L, of X T |- of X T'} -> T = T'

of_var_inv < <b>intros.</b>
</pre>
<a name="683"></a>
<pre>

  Variables: X, T, L, T'
  H1 : sctx' (of X T :: L)
  H2 : {L, of X T |- of X T'}
  ============================
   T = T'

of_var_inv < <b>case H1 (keep).</b>
</pre>
<a name="684"></a>
<pre>

  Variables: X, T, L, T'
  H1 : sctx' (of X T :: L)
  H2 : {L, of X T |- of X T'}
  H3 : sctx' L
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  ============================
   T = T'

of_var_inv < <b>case H4.</b>
</pre>
<a name="685"></a>
<pre>

  Variables: X, T, L, T'
  H1 : sctx' (of n1 T :: L n1)
  H2 : {L n1, of n1 T |- of n1 T'}
  H3 : sctx' (L n1)
  H5 : forall T', member (of n1 T') (L n1) -> T = T'
  ============================
   T = T'

of_var_inv < <b>case H2.</b>
</pre>
<a name="686"></a>
<pre>

  Variables: X, T, L, T', F
  H1 : sctx' (of n1 T :: L n1)
  H3 : sctx' (L n1)
  H5 : forall T', member (of n1 T') (L n1) -> T = T'
  H6 : {L n1, of n1 T, [F n1] |- of n1 T'}
  H7 : member (F n1) (of n1 T :: L n1)
  ============================
   T = T'

of_var_inv < <b>apply of_var_mem to H1 H6 H7.</b>
</pre>
<a name="687"></a>
<pre>

  Variables: X, T, L, T', F
  H1 : sctx' (of n1 T :: L n1)
  H3 : sctx' (L n1)
  H5 : forall T', member (of n1 T') (L n1) -> T = T'
  H6 : {L n1, of n1 T, [F n1] |- of n1 T'}
  H7 : member (F n1) (of n1 T :: L n1)
  H8 : member (of n1 T') (of n1 T :: L n1)
  ============================
   T = T'

of_var_inv < <b>case H8.</b>
</pre>
<a name="688"></a>
<pre>
Subgoal 1:

  Variables: X, T, L, T', F
  H1 : sctx' (of n1 T :: L n1)
  H3 : sctx' (L n1)
  H5 : forall T', member (of n1 T') (L n1) -> T = T'
  H6 : {L n1, of n1 T, [F n1] |- of n1 T}
  H7 : member (F n1) (of n1 T :: L n1)
  ============================
   T = T

Subgoal 2 is:
 T = T'

of_var_inv < <b>search.</b>
</pre>
<a name="689"></a>
<pre>
Subgoal 2:

  Variables: X, T, L, T', F
  H1 : sctx' (of n1 T :: L n1)
  H3 : sctx' (L n1)
  H5 : forall T', member (of n1 T') (L n1) -> T = T'
  H6 : {L n1, of n1 T, [F n1] |- of n1 T'}
  H7 : member (F n1) (of n1 T :: L n1)
  H9 : member (of n1 T') (L n1)
  ============================
   T = T'

of_var_inv < <b>apply H5 to H9.</b>
</pre>
<a name="690"></a>
<pre>
Subgoal 2:

  Variables: X, T, L, T', F
  H1 : sctx' (of n1 T' :: L n1)
  H3 : sctx' (L n1)
  H5 : forall T'1, member (of n1 T'1) (L n1) -> T' = T'1
  H6 : {L n1, of n1 T', [F n1] |- of n1 T'}
  H7 : member (F n1) (of n1 T' :: L n1)
  H9 : member (of n1 T') (L n1)
  ============================
   T' = T'

of_var_inv < <b>search.</b>
Proof completed.
</pre>
<a name="691"></a>
<pre class="code">
Abella < <b>Theorem of_var_strenghten : 
forall Y T L T' T'' X, sctx' (of Y T :: L) -> {L, of Y T |- of X T'} ->
  tname X -> member (of X T'') L -> {L |- of X T'}.</b>
</pre>
<a name="692"></a>
<pre>


  ============================
   forall Y T L T' T'' X, sctx' (of Y T :: L) -> {L, of Y T |- of X T'} ->
     tname X -> member (of X T'') L -> {L |- of X T'}

of_var_strenghten < <b>intros.</b>
</pre>
<a name="693"></a>
<pre>

  Variables: Y, T, L, T', T'', X
  H1 : sctx' (of Y T :: L)
  H2 : {L, of Y T |- of X T'}
  H3 : tname X
  H4 : member (of X T'') L
  ============================
   {L |- of X T'}

of_var_strenghten < <b>case H3.</b>
</pre>
<a name="694"></a>
<pre>

  Variables: Y, T, L, T', T'', X
  H1 : sctx' (of (Y n1) T :: L n1)
  H2 : {L n1, of (Y n1) T |- of n1 T'}
  H4 : member (of n1 T'') (L n1)
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < <b>case H2.</b>
</pre>
<a name="695"></a>
<pre>

  Variables: Y, T, L, T', T'', X, F
  H1 : sctx' (of (Y n1) T :: L n1)
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [F n1] |- of n1 T'}
  H6 : member (F n1) (of (Y n1) T :: L n1)
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < <b>case H6.</b>
</pre>
<a name="696"></a>
<pre>
Subgoal 1:

  Variables: Y, T, L, T', T'', X, F
  H1 : sctx' (of (Y n1) T :: L n1)
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [of (Y n1) T] |- of n1 T'}
  ============================
   {L n1 |- of n1 T'}

Subgoal 2 is:
 {L n1 |- of n1 T'}

of_var_strenghten < <b>case H5.</b>
</pre>
<a name="697"></a>
<pre>
Subgoal 1:

  Variables: Y, T, L, T', T'', X, F
  H1 : sctx' (of n1 T' :: L n1)
  H4 : member (of n1 T'') (L n1)
  ============================
   {L n1 |- of n1 T'}

Subgoal 2 is:
 {L n1 |- of n1 T'}

of_var_strenghten < <b>case H1.</b>
</pre>
<a name="698"></a>
<pre>
Subgoal 1:

  Variables: Y, T, L, T', T'', X, F
  H4 : member (of n1 T'') (L n1)
  H7 : sctx' (L n1)
  H8 : tname n1
  H9 : forall T'1, member (of n1 T'1) (L n1) -> T' = T'1
  ============================
   {L n1 |- of n1 T'}

Subgoal 2 is:
 {L n1 |- of n1 T'}

of_var_strenghten < <b>apply H9 to H4.</b>
</pre>
<a name="699"></a>
<pre>
Subgoal 1:

  Variables: Y, T, L, T', T'', X, F
  H4 : member (of n1 T'') (L n1)
  H7 : sctx' (L n1)
  H8 : tname n1
  H9 : forall T'1, member (of n1 T'1) (L n1) -> T'' = T'1
  ============================
   {L n1 |- of n1 T''}

Subgoal 2 is:
 {L n1 |- of n1 T'}

of_var_strenghten < <b>search.</b>
</pre>
<a name="700"></a>
<pre>
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F
  H1 : sctx' (of (Y n1) T :: L n1)
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [F n1] |- of n1 T'}
  H7 : member (F n1) (L n1)
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < <b>case H1.</b>
</pre>
<a name="701"></a>
<pre>
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [F n1] |- of n1 T'}
  H7 : member (F n1) (L n1)
  H8 : sctx' (L n1)
  H9 : tname (Y n1)
  H10 : forall T', member (of (Y n1) T') (L n1) -> T = T'
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < <b>clear H9.</b>
</pre>
<a name="702"></a>
<pre>
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [F n1] |- of n1 T'}
  H7 : member (F n1) (L n1)
  H8 : sctx' (L n1)
  H10 : forall T', member (of (Y n1) T') (L n1) -> T = T'
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < <b>clear H10.</b>
</pre>
<a name="703"></a>
<pre>
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [F n1] |- of n1 T'}
  H7 : member (F n1) (L n1)
  H8 : sctx' (L n1)
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < <b>apply sctx'_mem to H8 H7.</b>
</pre>
<a name="704"></a>
<pre>
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F, X1, T1
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [of (X1 n1) T1] |- of n1 T'}
  H7 : member (of (X1 n1) T1) (L n1)
  H8 : sctx' (L n1)
  H11 : tname (X1 n1)
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < <b>case H5.</b>
</pre>
<a name="705"></a>
<pre>
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F, X1, T1
  H4 : member (of n1 T'') (L n1)
  H7 : member (of n1 T') (L n1)
  H8 : sctx' (L n1)
  H11 : tname n1
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < <b>search.</b>
Proof completed.
</pre>
<a name="706"></a>
<pre class="code">
Abella < <b>Theorem of_abs_arrow_typ : 
forall L R T, sctx' L -> {L |- of (abs R) T} -> (exists T1 T2, T = arr T1 T2).</b>
</pre>
<a name="707"></a>
<pre>


  ============================
   forall L R T, sctx' L -> {L |- of (abs R) T} -> (exists T1 T2,
     T = arr T1 T2)

of_abs_arrow_typ < <b>intros.</b>
</pre>
<a name="708"></a>
<pre>

  Variables: L, R, T
  H1 : sctx' L
  H2 : {L |- of (abs R) T}
  ============================
   exists T1 T2, T = arr T1 T2

of_abs_arrow_typ < <b>case H2.</b>
</pre>
<a name="709"></a>
<pre>
Subgoal 1:

  Variables: L, R, T, T2, T1
  H1 : sctx' L
  H3 : {L, of n1 T1 |- of (R n1) T2}
  ============================
   exists T3 T4, arr T1 T2 = arr T3 T4

Subgoal 2 is:
 exists T1 T2, T = arr T1 T2

of_abs_arrow_typ < <b>search.</b>
</pre>
<a name="710"></a>
<pre>
Subgoal 2:

  Variables: L, R, T, F
  H1 : sctx' L
  H3 : {L, [F] |- of (abs R) T}
  H4 : member F L
  ============================
   exists T1 T2, T = arr T1 T2

of_abs_arrow_typ < <b>apply sctx'_mem to H1 H4.</b>
</pre>
<a name="711"></a>
<pre>
Subgoal 2:

  Variables: L, R, T, F, X, T1
  H1 : sctx' L
  H3 : {L, [of X T1] |- of (abs R) T}
  H4 : member (of X T1) L
  H5 : tname X
  ============================
   exists T1 T2, T = arr T1 T2

of_abs_arrow_typ < <b>case H3.</b>
</pre>
<a name="712"></a>
<pre>
Subgoal 2:

  Variables: L, R, T, F, X, T1
  H1 : sctx' L
  H4 : member (of (abs R) T) L
  H5 : tname (abs R)
  ============================
   exists T1 T2, T = arr T1 T2

of_abs_arrow_typ < <b>case H5.</b>
Proof completed.
</pre>
<a name="713"></a>
<pre class="code">
Abella < <b>Define sctx'_tmctx : olist -> olist -> prop by 
sctx'_tmctx nil nil;
nabla x, sctx'_tmctx (of x T :: L x) (tm x :: L' x) := nabla x, sctx'_tmctx (L x) (L' x).</b>
</pre>
<a name="714"></a>
<pre class="code">
Abella < <b>Theorem sctx'_tmctx_exists : 
forall L, sctx' L -> (exists L', sctx'_tmctx L L' /\ tmctx L').</b>
</pre>
<a name="715"></a>
<pre>


  ============================
   forall L, sctx' L -> (exists L', sctx'_tmctx L L' /\ tmctx L')

sctx'_tmctx_exists < <b>induction on 1.</b>
</pre>
<a name="716"></a>
<pre>


  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  ============================
   forall L, sctx' L @ -> (exists L', sctx'_tmctx L L' /\ tmctx L')

sctx'_tmctx_exists < <b>intros.</b>
</pre>
<a name="717"></a>
<pre>

  Variables: L
  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  H1 : sctx' L @
  ============================
   exists L', sctx'_tmctx L L' /\ tmctx L'

sctx'_tmctx_exists < <b>case H1.</b>
</pre>
<a name="718"></a>
<pre>
Subgoal 1:

  Variables: L
  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  ============================
   exists L', sctx'_tmctx nil L' /\ tmctx L'

Subgoal 2 is:
 exists L', sctx'_tmctx (of X T :: L1) L' /\ tmctx L'

sctx'_tmctx_exists < <b>search.</b>
</pre>
<a name="719"></a>
<pre>
Subgoal 2:

  Variables: L, L1, T, X
  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  H2 : sctx' L1 *
  H3 : tname X
  H4 : forall T', member (of X T') L1 -> T = T'
  ============================
   exists L', sctx'_tmctx (of X T :: L1) L' /\ tmctx L'

sctx'_tmctx_exists < <b>apply IH to H2.</b>
</pre>
<a name="720"></a>
<pre>
Subgoal 2:

  Variables: L, L1, T, X, L'
  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  H2 : sctx' L1 *
  H3 : tname X
  H4 : forall T', member (of X T') L1 -> T = T'
  H5 : sctx'_tmctx L1 L'
  H6 : tmctx L'
  ============================
   exists L', sctx'_tmctx (of X T :: L1) L' /\ tmctx L'

sctx'_tmctx_exists < <b>case H3.</b>
</pre>
<a name="721"></a>
<pre>
Subgoal 2:

  Variables: L, L1, T, X, L'
  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  H2 : sctx' (L1 n1) *
  H4 : forall T', member (of n1 T') (L1 n1) -> T = T'
  H5 : sctx'_tmctx (L1 n1) (L' n1)
  H6 : tmctx (L' n1)
  ============================
   exists L', sctx'_tmctx (of n1 T :: L1 n1) L' /\ tmctx L'

sctx'_tmctx_exists < <b>search.</b>
Proof completed.
</pre>
<a name="722"></a>
<pre class="code">
Abella < <b>Theorem sctx'_tmctx_mem1 : 
forall L L' F, sctx'_tmctx L L' -> member F L -> (exists X T, F = of X T /\
  tname X).</b>
</pre>
<a name="723"></a>
<pre>


  ============================
   forall L L' F, sctx'_tmctx L L' -> member F L -> (exists X T,
     F = of X T /\ tname X)

sctx'_tmctx_mem1 < <b>induction on 1.</b>
</pre>
<a name="724"></a>
<pre>


  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  ============================
   forall L L' F, sctx'_tmctx L L' @ -> member F L -> (exists X T,
     F = of X T /\ tname X)

sctx'_tmctx_mem1 < <b>intros.</b>
</pre>
<a name="725"></a>
<pre>

  Variables: L, L', F
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H1 : sctx'_tmctx L L' @
  H2 : member F L
  ============================
   exists X T, F = of X T /\ tname X

sctx'_tmctx_mem1 < <b>case H1.</b>
</pre>
<a name="726"></a>
<pre>
Subgoal 1:

  Variables: L, L', F
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H2 : member F nil
  ============================
   exists X T, F = of X T /\ tname X

Subgoal 2 is:
 exists X T, F n1 = of X T /\ tname X

sctx'_tmctx_mem1 < <b>case H2.</b>
</pre>
<a name="727"></a>
<pre>
Subgoal 2:

  Variables: L, L', F, L'1, L1, T
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H2 : member (F n1) (of n1 T :: L1 n1)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   exists X T, F n1 = of X T /\ tname X

sctx'_tmctx_mem1 < <b>case H2.</b>
</pre>
<a name="728"></a>
<pre>
Subgoal 2.1:

  Variables: L, L', F, L'1, L1, T
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   exists X T1, of n1 T = of X T1 /\ tname X

Subgoal 2.2 is:
 exists X T, F n1 = of X T /\ tname X

sctx'_tmctx_mem1 < <b>search.</b>
</pre>
<a name="729"></a>
<pre>
Subgoal 2.2:

  Variables: L, L', F, L'1, L1, T
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (F n1) (L1 n1)
  ============================
   exists X T, F n1 = of X T /\ tname X

sctx'_tmctx_mem1 < <b>apply IH to H3 H4.</b>
</pre>
<a name="730"></a>
<pre>
Subgoal 2.2:

  Variables: L, L', F, L'1, L1, T, X, T1
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (of (X n1) T1) (L1 n1)
  H5 : tname (X n1)
  ============================
   exists X1 T, of (X n1) T1 = of X1 T /\ tname X1

sctx'_tmctx_mem1 < <b>search.</b>
Proof completed.
</pre>
<a name="731"></a>
<pre class="code">
Abella < <b>Theorem sctx'_tmctx_sync1 : 
forall L L' X T, sctx'_tmctx L L' -> member (of X T) L -> member (tm X) L'.</b>
</pre>
<a name="732"></a>
<pre>


  ============================
   forall L L' X T, sctx'_tmctx L L' -> member (of X T) L -> member (tm X) L'

sctx'_tmctx_sync1 < <b>induction on 1.</b>
</pre>
<a name="733"></a>
<pre>


  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  ============================
   forall L L' X T, sctx'_tmctx L L' @ -> member (of X T) L ->
     member (tm X) L'

sctx'_tmctx_sync1 < <b>intros.</b>
</pre>
<a name="734"></a>
<pre>

  Variables: L, L', X, T
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H1 : sctx'_tmctx L L' @
  H2 : member (of X T) L
  ============================
   member (tm X) L'

sctx'_tmctx_sync1 < <b>case H1.</b>
</pre>
<a name="735"></a>
<pre>
Subgoal 1:

  Variables: L, L', X, T
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H2 : member (of X T) nil
  ============================
   member (tm X) nil

Subgoal 2 is:
 member (tm (X n1)) (tm n1 :: L'1 n1)

sctx'_tmctx_sync1 < <b>case H2.</b>
</pre>
<a name="736"></a>
<pre>
Subgoal 2:

  Variables: L, L', X, T, L'1, L1, T1
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H2 : member (of (X n1) T) (of n1 T1 :: L1 n1)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   member (tm (X n1)) (tm n1 :: L'1 n1)

sctx'_tmctx_sync1 < <b>case H2.</b>
</pre>
<a name="737"></a>
<pre>
Subgoal 2.1:

  Variables: L, L', X, T, L'1, L1, T1
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   member (tm n1) (tm n1 :: L'1 n1)

Subgoal 2.2 is:
 member (tm (X n1)) (tm n1 :: L'1 n1)

sctx'_tmctx_sync1 < <b>search.</b>
</pre>
<a name="738"></a>
<pre>
Subgoal 2.2:

  Variables: L, L', X, T, L'1, L1, T1
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (of (X n1) T) (L1 n1)
  ============================
   member (tm (X n1)) (tm n1 :: L'1 n1)

sctx'_tmctx_sync1 < <b>apply IH to H3 H4.</b>
</pre>
<a name="739"></a>
<pre>
Subgoal 2.2:

  Variables: L, L', X, T, L'1, L1, T1
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (of (X n1) T) (L1 n1)
  H5 : member (tm (X n1)) (L'1 n1)
  ============================
   member (tm (X n1)) (tm n1 :: L'1 n1)

sctx'_tmctx_sync1 < <b>search.</b>
Proof completed.
</pre>
<a name="740"></a>
<pre class="code">
Abella < <b>Theorem sctx'_tmctx_sync2 : 
forall L L' X, sctx'_tmctx L L' -> member (tm X) L' -> (exists T,
  member (of X T) L).</b>
</pre>
<a name="741"></a>
<pre>


  ============================
   forall L L' X, sctx'_tmctx L L' -> member (tm X) L' -> (exists T,
     member (of X T) L)

sctx'_tmctx_sync2 < <b>induction on 1.</b>
</pre>
<a name="742"></a>
<pre>


  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  ============================
   forall L L' X, sctx'_tmctx L L' @ -> member (tm X) L' -> (exists T,
     member (of X T) L)

sctx'_tmctx_sync2 < <b>intros.</b>
</pre>
<a name="743"></a>
<pre>

  Variables: L, L', X
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H1 : sctx'_tmctx L L' @
  H2 : member (tm X) L'
  ============================
   exists T, member (of X T) L

sctx'_tmctx_sync2 < <b>case H1.</b>
</pre>
<a name="744"></a>
<pre>
Subgoal 1:

  Variables: L, L', X
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H2 : member (tm X) nil
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of (X n1) T1) (of n1 T :: L1 n1)

sctx'_tmctx_sync2 < <b>case H2.</b>
</pre>
<a name="745"></a>
<pre>
Subgoal 2:

  Variables: L, L', X, L'1, L1, T
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H2 : member (tm (X n1)) (tm n1 :: L'1 n1)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   exists T1, member (of (X n1) T1) (of n1 T :: L1 n1)

sctx'_tmctx_sync2 < <b>case H2.</b>
</pre>
<a name="746"></a>
<pre>
Subgoal 2.1:

  Variables: L, L', X, L'1, L1, T
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   exists T1, member (of n1 T1) (of n1 T :: L1 n1)

Subgoal 2.2 is:
 exists T1, member (of (X n1) T1) (of n1 T :: L1 n1)

sctx'_tmctx_sync2 < <b>search.</b>
</pre>
<a name="747"></a>
<pre>
Subgoal 2.2:

  Variables: L, L', X, L'1, L1, T
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (tm (X n1)) (L'1 n1)
  ============================
   exists T1, member (of (X n1) T1) (of n1 T :: L1 n1)

sctx'_tmctx_sync2 < <b>apply IH to H3 H4.</b>
</pre>
<a name="748"></a>
<pre>
Subgoal 2.2:

  Variables: L, L', X, L'1, L1, T, T1
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (tm (X n1)) (L'1 n1)
  H5 : member (of (X n1) T1) (L1 n1)
  ============================
   exists T1, member (of (X n1) T1) (of n1 T :: L1 n1)

sctx'_tmctx_sync2 < <b>search.</b>
Proof completed.
</pre>
<a name="749"></a>
<pre class="code">
Abella < <b>Theorem of_tm : 
forall L L' M T, sctx'_tmctx L L' -> {L |- of M T} -> {L' |- tm M}.</b>
</pre>
<a name="750"></a>
<pre>


  ============================
   forall L L' M T, sctx'_tmctx L L' -> {L |- of M T} -> {L' |- tm M}

of_tm < <b>induction on 2.</b>
</pre>
<a name="751"></a>
<pre>


  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  ============================
   forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}@ -> {L' |- tm M}

of_tm < <b>intros.</b>
</pre>
<a name="752"></a>
<pre>

  Variables: L, L', M, T
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H2 : {L |- of M T}@
  ============================
   {L' |- tm M}

of_tm < <b>case H2.</b>
</pre>
<a name="753"></a>
<pre>
Subgoal 1:

  Variables: L, L', M, T, X
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  ============================
   {L' |- tm (lnat X)}

Subgoal 2 is:
 {L' |- tm (app M1 N)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < <b>search.</b>
</pre>
<a name="754"></a>
<pre>
Subgoal 2:

  Variables: L, L', M, T, T1, N, M1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L |- of M1 (arr T1 T)}*
  H4 : {L |- of N T1}*
  ============================
   {L' |- tm (app M1 N)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < <b>apply IH to H1 H3.</b>
</pre>
<a name="755"></a>
<pre>
Subgoal 2:

  Variables: L, L', M, T, T1, N, M1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L |- of M1 (arr T1 T)}*
  H4 : {L |- of N T1}*
  H5 : {L' |- tm M1}
  ============================
   {L' |- tm (app M1 N)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < <b>apply IH to H1 H4.</b>
</pre>
<a name="756"></a>
<pre>
Subgoal 2:

  Variables: L, L', M, T, T1, N, M1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L |- of M1 (arr T1 T)}*
  H4 : {L |- of N T1}*
  H5 : {L' |- tm M1}
  H6 : {L' |- tm N}
  ============================
   {L' |- tm (app M1 N)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < <b>search.</b>
</pre>
<a name="757"></a>
<pre>
Subgoal 3:

  Variables: L, L', M, T, T2, M1, T1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L, of n1 T1 |- of (M1 n1) T2}*
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < <b>apply IH to _ H3.</b>
</pre>
<a name="758"></a>
<pre>
Subgoal 3:

  Variables: L, L', M, T, T2, M1, T1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L, of n1 T1 |- of (M1 n1) T2}*
  H4 : {L', tm n1 |- tm (M1 n1)}
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < <b>search.</b>
</pre>
<a name="759"></a>
<pre>
Subgoal 4:

  Variables: L, L', M, T, F
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L, [F] |- of M T}*
  H4 : member F L
  ============================
   {L' |- tm M}

of_tm < <b>apply sctx'_tmctx_mem1 to H1 H4.</b>
</pre>
<a name="760"></a>
<pre>
Subgoal 4:

  Variables: L, L', M, T, F, X, T1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L, [of X T1] |- of M T}*
  H4 : member (of X T1) L
  H5 : tname X
  ============================
   {L' |- tm M}

of_tm < <b>case H3.</b>
</pre>
<a name="761"></a>
<pre>
Subgoal 4:

  Variables: L, L', M, T, F, X, T1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H4 : member (of M T) L
  H5 : tname M
  ============================
   {L' |- tm M}

of_tm < <b>apply sctx'_tmctx_sync1 to H1 H4.</b>
</pre>
<a name="762"></a>
<pre>
Subgoal 4:

  Variables: L, L', M, T, F, X, T1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H4 : member (of M T) L
  H5 : tname M
  H6 : member (tm M) L'
  ============================
   {L' |- tm M}

of_tm < <b>search.</b>
Proof completed.
</pre>
<a name="763"></a>
<pre class="code">
Abella < <b>Theorem of_closed_tm : 
forall M T, {of M T} -> {tm M}.</b>
</pre>
<a name="764"></a>
<pre>


  ============================
   forall M T, {of M T} -> {tm M}

of_closed_tm < <b>intros.</b>
</pre>
<a name="765"></a>
<pre>

  Variables: M, T
  H1 : {of M T}
  ============================
   {tm M}

of_closed_tm < <b>apply of_tm to _ H1.</b>
</pre>
<a name="766"></a>
<pre>

  Variables: M, T
  H1 : {of M T}
  H2 : {tm M}
  ============================
   {tm M}

of_closed_tm < <b>search.</b>
Proof completed.
</pre>
<a name="767"></a>
<pre class="code">
Abella < <b>Define vars_of_sctx : olist -> tm_list -> prop by 
vars_of_sctx nil tl_nil;
vars_of_sctx (of X T :: L) (tl_cons X Vs) := vars_of_sctx L Vs.</b>
</pre>
<a name="768"></a>
<pre class="code">
Abella < <b>Theorem vars_of_sctx_mem_exists : 
forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
  (exists T, member (of X T) SL).</b>
</pre>
<a name="769"></a>
<pre>


  ============================
   forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     (exists T, member (of X T) SL)

vars_of_sctx_mem_exists < <b>induction on 1.</b>
</pre>
<a name="770"></a>
<pre>


  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  ============================
   forall SL Vs X, sctx' SL @ -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     (exists T, member (of X T) SL)

vars_of_sctx_mem_exists < <b>intros.</b>
</pre>
<a name="771"></a>
<pre>

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H1 : sctx' SL @
  H2 : vars_of_sctx SL Vs
  H3 : {tl_member X Vs}
  ============================
   exists T, member (of X T) SL

vars_of_sctx_mem_exists < <b>case H1.</b>
</pre>
<a name="772"></a>
<pre>
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H2 : vars_of_sctx nil Vs
  H3 : {tl_member X Vs}
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>case H2.</b>
</pre>
<a name="773"></a>
<pre>
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H3 : {tl_member X tl_nil}
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>case H3.</b>
</pre>
<a name="774"></a>
<pre>
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H2 : vars_of_sctx (of X1 T :: L) Vs
  H3 : {tl_member X Vs}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>case H2.</b>
</pre>
<a name="775"></a>
<pre>
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H3 : {tl_member X (tl_cons X1 Vs1)}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>case H3.</b>
</pre>
<a name="776"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   exists T1, member (of X1 T1) (of X1 T :: L)

Subgoal 2.2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>search.</b>
</pre>
<a name="777"></a>
<pre>
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>apply IH to H4 H7 H8.</b>
</pre>
<a name="778"></a>
<pre>
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1, T1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  H9 : member (of X T1) L
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>search.</b>
Proof completed.
</pre>
<a name="779"></a>
<pre class="code">
Abella < <b>Theorem sctx_env_sync : 
forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL ->
  {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
  member (of E T) L /\ tname E).</b>
</pre>
<a name="780"></a>
<pre>


  ============================
   forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL ->
     {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
     member (of E T) L /\ tname E)

sctx_env_sync < <b>induction on 2.</b>
</pre>
<a name="781"></a>
<pre>


  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  ============================
   forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL @ ->
     {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
     member (of E T) L /\ tname E)

sctx_env_sync < <b>intros.</b>
</pre>
<a name="782"></a>
<pre>

  Variables: L, TL, Map, E, V
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' L
  H2 : vars_of_sctx L TL @
  H3 : {mapvar TL Map}
  H4 : {ml_member (map E (V n1)) (Map n1)}
  ============================
   exists T, member (of E T) L /\ tname E

sctx_env_sync < <b>case H2.</b>
</pre>
<a name="783"></a>
<pre>
Subgoal 1:

  Variables: L, TL, Map, E, V
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' nil
  H3 : {mapvar tl_nil Map}
  H4 : {ml_member (map E (V n1)) (Map n1)}
  ============================
   exists T, member (of E T) nil /\ tname E

Subgoal 2 is:
 exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>case H3.</b>
</pre>
<a name="784"></a>
<pre>
Subgoal 1:

  Variables: L, TL, Map, E, V
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' nil
  H4 : {ml_member (map E (V n1)) ml_nil}
  ============================
   exists T, member (of E T) nil /\ tname E

Subgoal 2 is:
 exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>case H4.</b>
</pre>
<a name="785"></a>
<pre>
Subgoal 2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H3 : {mapvar (tl_cons X Vs) Map}
  H4 : {ml_member (map E (V n1)) (Map n1)}
  H5 : vars_of_sctx L1 Vs *
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>case H3.</b>
</pre>
<a name="786"></a>
<pre>
Subgoal 2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H4 : {ml_member (map E (V n1)) (ml_cons (map X (fst n1)) (Map1 (rst n1)))}
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>case H4.</b>
</pre>
<a name="787"></a>
<pre>
Subgoal 2.1:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  ============================
   exists T1, member (of X T1) (of X T :: L1) /\ tname X

Subgoal 2.2 is:
 exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>case H1.</b>
</pre>
<a name="788"></a>
<pre>
Subgoal 2.1:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : sctx' L1
  H9 : tname X
  H10 : forall T', member (of X T') L1 -> T = T'
  ============================
   exists T1, member (of X T1) (of X T :: L1) /\ tname X

Subgoal 2.2 is:
 exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>search.</b>
</pre>
<a name="789"></a>
<pre>
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>apply eq_ml_member to H7 H8.</b>
</pre>
<a name="790"></a>
<pre>
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>apply mapvar_mem to H6 H9.</b>
</pre>
<a name="791"></a>
<pre>
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2, E'
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  H10 : V n1 = E' n1 n2 (rst n1)
  H11 : env_elem (E' n1 n2)
  H12 : {ml_member (map E (E' n1 n2 n2)) (Map1 n2)}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>apply env_elem_closed to H11.</b>
</pre>
<a name="792"></a>
<pre>
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2, E', E'1
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  H10 : V n1 = E'1 n2 (rst n1)
  H11 : env_elem (E'1 n2)
  H12 : {ml_member (map E (E'1 n2 n2)) (Map1 n2)}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>apply env_elem_closed to H11.</b>
</pre>
<a name="793"></a>
<pre>
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2, E', E'1, E'2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  H10 : V n1 = E'2 (rst n1)
  H11 : env_elem E'2
  H12 : {ml_member (map E (E'2 n2)) (Map1 n2)}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>case H1.</b>
</pre>
<a name="794"></a>
<pre>
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2, E', E'1, E'2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  H10 : V n1 = E'2 (rst n1)
  H11 : env_elem E'2
  H12 : {ml_member (map E (E'2 n2)) (Map1 n2)}
  H13 : sctx' L1
  H14 : tname X
  H15 : forall T', member (of X T') L1 -> T = T'
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>apply IH to H13 H5 H6 H12.</b>
</pre>
<a name="795"></a>
<pre>
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2, E', E'1, E'2, T1
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  H10 : V n1 = E'2 (rst n1)
  H11 : env_elem E'2
  H12 : {ml_member (map E (E'2 n2)) (Map1 n2)}
  H13 : sctx' L1
  H14 : tname X
  H15 : forall T', member (of X T') L1 -> T = T'
  H16 : member (of E T1) L1
  H17 : tname E
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < <b>search.</b>
Proof completed.
</pre>
<a name="796"></a>
<pre class="code">
Abella < <b>Define bvars : olist -> prop by 
bvars nil;
nabla x, bvars (notfree x :: L) := bvars L.</b>
</pre>
<a name="797"></a>
<pre class="code">
Abella < <b>Theorem bvars_mem : 
forall BVs E, bvars BVs -> member E BVs -> (exists X, E = notfree X /\
  tname X).</b>
</pre>
<a name="798"></a>
<pre>


  ============================
   forall BVs E, bvars BVs -> member E BVs -> (exists X, E = notfree X /\
     tname X)

bvars_mem < <b>induction on 1.</b>
</pre>
<a name="799"></a>
<pre>


  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  ============================
   forall BVs E, bvars BVs @ -> member E BVs -> (exists X, E = notfree X /\
     tname X)

bvars_mem < <b>intros.</b>
</pre>
<a name="800"></a>
<pre>

  Variables: BVs, E
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H1 : bvars BVs @
  H2 : member E BVs
  ============================
   exists X, E = notfree X /\ tname X

bvars_mem < <b>case H1.</b>
</pre>
<a name="801"></a>
<pre>
Subgoal 1:

  Variables: BVs, E
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H2 : member E nil
  ============================
   exists X, E = notfree X /\ tname X

Subgoal 2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>case H2.</b>
</pre>
<a name="802"></a>
<pre>
Subgoal 2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H2 : member (E n1) (notfree n1 :: L)
  H3 : bvars L *
  ============================
   exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>case H2.</b>
</pre>
<a name="803"></a>
<pre>
Subgoal 2.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   exists X, notfree n1 = notfree X /\ tname X

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>exists n1.</b>
</pre>
<a name="804"></a>
<pre>
Subgoal 2.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   notfree n1 = notfree n1 /\ tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>split.</b>
</pre>
<a name="805"></a>
<pre>
Subgoal 2.1.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   notfree n1 = notfree n1

Subgoal 2.1.2 is:
 tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>search.</b>
</pre>
<a name="806"></a>
<pre>
Subgoal 2.1.2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>search.</b>
</pre>
<a name="807"></a>
<pre>
Subgoal 2.2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (E n1) L
  ============================
   exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>apply IH to H3 H4.</b>
</pre>
<a name="808"></a>
<pre>
Subgoal 2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   exists X1, notfree (X n1) = notfree X1 /\ tname X1

bvars_mem < <b>exists X n1.</b>
</pre>
<a name="809"></a>
<pre>
Subgoal 2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   notfree (X n1) = notfree (X n1) /\ tname (X n1)

bvars_mem < <b>split.</b>
</pre>
<a name="810"></a>
<pre>
Subgoal 2.2.1:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   notfree (X n1) = notfree (X n1)

Subgoal 2.2.2 is:
 tname (X n1)

bvars_mem < <b>search.</b>
</pre>
<a name="811"></a>
<pre>
Subgoal 2.2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   tname (X n1)

bvars_mem < <b>search.</b>
Proof completed.
</pre>
<a name="812"></a>
<pre class="code">
Abella < <b>Theorem vars_of_sctx_mem_name : 
forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} -> tname X.</b>
</pre>
<a name="813"></a>
<pre>


  ============================
   forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     tname X

vars_of_sctx_mem_name < <b>induction on 1.</b>
</pre>
<a name="814"></a>
<pre>


  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  ============================
   forall SL Vs X, sctx' SL @ -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     tname X

vars_of_sctx_mem_name < <b>intros.</b>
</pre>
<a name="815"></a>
<pre>

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H1 : sctx' SL @
  H2 : vars_of_sctx SL Vs
  H3 : {tl_member X Vs}
  ============================
   tname X

vars_of_sctx_mem_name < <b>case H1.</b>
</pre>
<a name="816"></a>
<pre>
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H2 : vars_of_sctx nil Vs
  H3 : {tl_member X Vs}
  ============================
   tname X

Subgoal 2 is:
 tname X

vars_of_sctx_mem_name < <b>case H2.</b>
</pre>
<a name="817"></a>
<pre>
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H3 : {tl_member X tl_nil}
  ============================
   tname X

Subgoal 2 is:
 tname X

vars_of_sctx_mem_name < <b>case H3.</b>
</pre>
<a name="818"></a>
<pre>
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H2 : vars_of_sctx (of X1 T :: L) Vs
  H3 : {tl_member X Vs}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  ============================
   tname X

vars_of_sctx_mem_name < <b>case H2.</b>
</pre>
<a name="819"></a>
<pre>
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H3 : {tl_member X (tl_cons X1 Vs1)}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   tname X

vars_of_sctx_mem_name < <b>case H3.</b>
</pre>
<a name="820"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

vars_of_sctx_mem_name < <b>search.</b>
</pre>
<a name="821"></a>
<pre>
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  ============================
   tname X

vars_of_sctx_mem_name < <b>apply IH to H4 H7 H8.</b>
</pre>
<a name="822"></a>
<pre>
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  H9 : tname X
  ============================
   tname X

vars_of_sctx_mem_name < <b>search.</b>
Proof completed.
</pre>
<a name="823"></a>
<pre class="code">
Abella < <b>Theorem bvars_notfree : 
forall BVs X, bvars BVs -> {BVs |- notfree X} -> tname X.</b>
</pre>
<a name="824"></a>
<pre>


  ============================
   forall BVs X, bvars BVs -> {BVs |- notfree X} -> tname X

bvars_notfree < <b>intros.</b>
</pre>
<a name="825"></a>
<pre>

  Variables: BVs, X
  H1 : bvars BVs
  H2 : {BVs |- notfree X}
  ============================
   tname X

bvars_notfree < <b>case H2.</b>
</pre>
<a name="826"></a>
<pre>

  Variables: BVs, X, F
  H1 : bvars BVs
  H3 : {BVs, [F] |- notfree X}
  H4 : member F BVs
  ============================
   tname X

bvars_notfree < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="827"></a>
<pre>

  Variables: BVs, X, F, X1
  H1 : bvars BVs
  H3 : {BVs, [notfree X1] |- notfree X}
  H4 : member (notfree X1) BVs
  H5 : tname X1
  ============================
   tname X

bvars_notfree < <b>case H3.</b>
</pre>
<a name="828"></a>
<pre>

  Variables: BVs, X, F, X1
  H1 : bvars BVs
  H4 : member (notfree X) BVs
  H5 : tname X
  ============================
   tname X

bvars_notfree < <b>search.</b>
Proof completed.
</pre>
<a name="829"></a>
<pre class="code">
Abella < <b>Define subset : tm_list -> tm_list -> prop by 
subset tl_nil L;
subset (tl_cons X L1) L2 := {tl_member X L2} /\ subset L1 L2.</b>
</pre>
<a name="830"></a>
<pre class="code">
Abella < <b>Define islist : tm_list -> prop by 
islist tl_nil;
islist (tl_cons X L) := islist L.</b>
</pre>
<a name="831"></a>
<pre class="code">
Abella < <b>Theorem combine_islist : 
forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> islist L3.</b>
</pre>
<a name="832"></a>
<pre>


  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> islist L3

combine_islist < <b>induction on 3.</b>
</pre>
<a name="833"></a>
<pre>


  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     islist L3

combine_islist < <b>intros.</b>
</pre>
<a name="834"></a>
<pre>

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  ============================
   islist L3

combine_islist < <b>case H3.</b>
</pre>
<a name="835"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist tl_nil
  H2 : islist L3
  ============================
   islist L3

Subgoal 2 is:
 islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < <b>search.</b>
</pre>
<a name="836"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < <b>case H1.</b>
</pre>
<a name="837"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : islist Fvs1
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < <b>apply IH to H6 H2 H5.</b>
</pre>
<a name="838"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : islist Fvs1
  H7 : islist L3
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < <b>search.</b>
</pre>
<a name="839"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  ============================
   islist (tl_cons X Fvs)

combine_islist < <b>case H1.</b>
</pre>
<a name="840"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  ============================
   islist (tl_cons X Fvs)

combine_islist < <b>apply IH to H5 H2 H4.</b>
</pre>
<a name="841"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : islist Fvs
  ============================
   islist (tl_cons X Fvs)

combine_islist < <b>search.</b>
Proof completed.
</pre>
<a name="842"></a>
<pre class="code">
Abella < <b>Theorem tl_mem_bvar : 
forall Ps X L, bvars Ps -> {Ps |- tl_member X L} -> {tl_member X L}.</b>
</pre>
<a name="843"></a>
<pre>


  ============================
   forall Ps X L, bvars Ps -> {Ps |- tl_member X L} -> {tl_member X L}

tl_mem_bvar < <b>induction on 2.</b>
</pre>
<a name="844"></a>
<pre>


  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  ============================
   forall Ps X L, bvars Ps -> {Ps |- tl_member X L}@ -> {tl_member X L}

tl_mem_bvar < <b>intros.</b>
</pre>
<a name="845"></a>
<pre>

  Variables: Ps, X, L
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H2 : {Ps |- tl_member X L}@
  ============================
   {tl_member X L}

tl_mem_bvar < <b>case H2.</b>
</pre>
<a name="846"></a>
<pre>
Subgoal 1:

  Variables: Ps, X, L, L1
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  ============================
   {tl_member X (tl_cons X L1)}

Subgoal 2 is:
 {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < <b>search.</b>
</pre>
<a name="847"></a>
<pre>
Subgoal 2:

  Variables: Ps, X, L, L1, Y
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L1}*
  ============================
   {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < <b>apply IH to H1 H3.</b>
</pre>
<a name="848"></a>
<pre>
Subgoal 2:

  Variables: Ps, X, L, L1, Y
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L1}*
  H4 : {tl_member X L1}
  ============================
   {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < <b>search.</b>
</pre>
<a name="849"></a>
<pre>
Subgoal 3:

  Variables: Ps, X, L, F
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps, [F] |- tl_member X L}*
  H4 : member F Ps
  ============================
   {tl_member X L}

tl_mem_bvar < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="850"></a>
<pre>
Subgoal 3:

  Variables: Ps, X, L, F, X1
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps, [notfree X1] |- tl_member X L}*
  H4 : member (notfree X1) Ps
  H5 : tname X1
  ============================
   {tl_member X L}

tl_mem_bvar < <b>case H3.</b>
Proof completed.
</pre>
<a name="851"></a>
<pre class="code">
Abella < <b>Theorem combine_bvar : 
forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3} ->
  {combine L1 L2 L3}.</b>
</pre>
<a name="852"></a>
<pre>


  ============================
   forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3} ->
     {combine L1 L2 L3}

combine_bvar < <b>induction on 2.</b>
</pre>
<a name="853"></a>
<pre>


  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  ============================
   forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}@ ->
     {combine L1 L2 L3}

combine_bvar < <b>intros.</b>
</pre>
<a name="854"></a>
<pre>

  Variables: L1, L2, L3, Ps
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H2 : {Ps |- combine L1 L2 L3}@
  ============================
   {combine L1 L2 L3}

combine_bvar < <b>case H2.</b>
</pre>
<a name="855"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3, Ps
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  ============================
   {combine tl_nil L3 L3}

Subgoal 2 is:
 {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>search.</b>
</pre>
<a name="856"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>apply IH to H1 H4.</b>
</pre>
<a name="857"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  H5 : {combine Fvs1 L2 L3}
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>apply tl_mem_bvar to H1 H3.</b>
</pre>
<a name="858"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  H5 : {combine Fvs1 L2 L3}
  H6 : {tl_member X L2}
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>search.</b>
</pre>
<a name="859"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Ps, Fvs, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- combine Fvs1 L2 Fvs}*
  ============================
   {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>apply IH to H1 H3.</b>
</pre>
<a name="860"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Ps, Fvs, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- combine Fvs1 L2 Fvs}*
  H4 : {combine Fvs1 L2 Fvs}
  ============================
   {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>search.</b>
</pre>
<a name="861"></a>
<pre>
Subgoal 4:

  Variables: L1, L2, L3, Ps, F
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps, [F] |- combine L1 L2 L3}*
  H4 : member F Ps
  ============================
   {combine L1 L2 L3}

combine_bvar < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="862"></a>
<pre>
Subgoal 4:

  Variables: L1, L2, L3, Ps, F, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- combine L1 L2 L3}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   {combine L1 L2 L3}

combine_bvar < <b>case H3.</b>
Proof completed.
</pre>
<a name="863"></a>
<pre class="code">
Abella < <b>Theorem subset_mem : 
forall L1 L2 X, subset L1 L2 -> {tl_member X L1} -> {tl_member X L2}.</b>
</pre>
<a name="864"></a>
<pre>


  ============================
   forall L1 L2 X, subset L1 L2 -> {tl_member X L1} -> {tl_member X L2}

subset_mem < <b>induction on 2.</b>
</pre>
<a name="865"></a>
<pre>


  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  ============================
   forall L1 L2 X, subset L1 L2 -> {tl_member X L1}@ -> {tl_member X L2}

subset_mem < <b>intros.</b>
</pre>
<a name="866"></a>
<pre>

  Variables: L1, L2, X
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset L1 L2
  H2 : {tl_member X L1}@
  ============================
   {tl_member X L2}

subset_mem < <b>case H2.</b>
</pre>
<a name="867"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, X, L
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset (tl_cons X L) L2
  ============================
   {tl_member X L2}

Subgoal 2 is:
 {tl_member X L2}

subset_mem < <b>case H1.</b>
</pre>
<a name="868"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, X, L
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L2}
  H4 : subset L L2
  ============================
   {tl_member X L2}

Subgoal 2 is:
 {tl_member X L2}

subset_mem < <b>search.</b>
</pre>
<a name="869"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset (tl_cons Y L) L2
  H3 : {tl_member X L}*
  ============================
   {tl_member X L2}

subset_mem < <b>case H1.</b>
</pre>
<a name="870"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L}*
  H4 : {tl_member Y L2}
  H5 : subset L L2
  ============================
   {tl_member X L2}

subset_mem < <b>apply IH to H5 H3.</b>
</pre>
<a name="871"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L}*
  H4 : {tl_member Y L2}
  H5 : subset L L2
  H6 : {tl_member X L2}
  ============================
   {tl_member X L2}

subset_mem < <b>search.</b>
Proof completed.
</pre>
<a name="872"></a>
<pre class="code">
Abella < <b>Theorem subset_one : 
forall L1 L2 X, islist L1 -> subset L1 L2 -> subset L1 (tl_cons X L2).</b>
</pre>
<a name="873"></a>
<pre>


  ============================
   forall L1 L2 X, islist L1 -> subset L1 L2 -> subset L1 (tl_cons X L2)

subset_one < <b>induction on 1.</b>
</pre>
<a name="874"></a>
<pre>


  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 -> subset L1 (tl_cons X L2)
  ============================
   forall L1 L2 X, islist L1 @ -> subset L1 L2 -> subset L1 (tl_cons X L2)

subset_one < <b>intros.</b>
</pre>
<a name="875"></a>
<pre>

  Variables: L1, L2, X
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H1 : islist L1 @
  H2 : subset L1 L2
  ============================
   subset L1 (tl_cons X L2)

subset_one < <b>case H1.</b>
</pre>
<a name="876"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, X
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H2 : subset tl_nil L2
  ============================
   subset tl_nil (tl_cons X L2)

Subgoal 2 is:
 subset (tl_cons X1 L) (tl_cons X L2)

subset_one < <b>search.</b>
</pre>
<a name="877"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H2 : subset (tl_cons X1 L) L2
  H3 : islist L *
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < <b>case H2.</b>
</pre>
<a name="878"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < <b>apply IH to H3 H5 with X = X.</b>
</pre>
<a name="879"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < <b>unfold.</b>
</pre>
<a name="880"></a>
<pre>
Subgoal 2.1:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   {tl_member X1 (tl_cons X L2)}

Subgoal 2.2 is:
 subset L (tl_cons X L2)

subset_one < <b>search.</b>
</pre>
<a name="881"></a>
<pre>
Subgoal 2.2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   subset L (tl_cons X L2)

subset_one < <b>search.</b>
Proof completed.
</pre>
<a name="882"></a>
<pre class="code">
Abella < <b>Theorem subset_refl : 
forall L, islist L -> subset L L.</b>
</pre>
<a name="883"></a>
<pre>


  ============================
   forall L, islist L -> subset L L

subset_refl < <b>induction on 1.</b>
</pre>
<a name="884"></a>
<pre>


  IH : forall L, islist L * -> subset L L
  ============================
   forall L, islist L @ -> subset L L

subset_refl < <b>intros.</b>
</pre>
<a name="885"></a>
<pre>

  Variables: L
  IH : forall L, islist L * -> subset L L
  H1 : islist L @
  ============================
   subset L L

subset_refl < <b>case H1 (keep).</b>
</pre>
<a name="886"></a>
<pre>
Subgoal 1:

  Variables: L
  IH : forall L, islist L * -> subset L L
  H1 : islist tl_nil @
  ============================
   subset tl_nil tl_nil

Subgoal 2 is:
 subset (tl_cons X L1) (tl_cons X L1)

subset_refl < <b>search.</b>
</pre>
<a name="887"></a>
<pre>
Subgoal 2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   subset (tl_cons X L1) (tl_cons X L1)

subset_refl < <b>unfold.</b>
</pre>
<a name="888"></a>
<pre>
Subgoal 2.1:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   {tl_member X (tl_cons X L1)}

Subgoal 2.2 is:
 subset L1 (tl_cons X L1)

subset_refl < <b>search.</b>
</pre>
<a name="889"></a>
<pre>
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   subset L1 (tl_cons X L1)

subset_refl < <b>apply IH to H2.</b>
</pre>
<a name="890"></a>
<pre>
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  H3 : subset L1 L1
  ============================
   subset L1 (tl_cons X L1)

subset_refl < <b>apply subset_one to H2 H3 with X = X.</b>
</pre>
<a name="891"></a>
<pre>
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  H3 : subset L1 L1
  H4 : subset L1 (tl_cons X L1)
  ============================
   subset L1 (tl_cons X L1)

subset_refl < <b>search.</b>
Proof completed.
</pre>
<a name="892"></a>
<pre class="code">
Abella < <b>Theorem subset_trans : 
forall L1 L2 L3, subset L1 L2 -> subset L2 L3 -> subset L1 L3.</b>
</pre>
<a name="893"></a>
<pre>


  ============================
   forall L1 L2 L3, subset L1 L2 -> subset L2 L3 -> subset L1 L3

subset_trans < <b>induction on 1.</b>
</pre>
<a name="894"></a>
<pre>


  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  ============================
   forall L1 L2 L3, subset L1 L2 @ -> subset L2 L3 -> subset L1 L3

subset_trans < <b>intros.</b>
</pre>
<a name="895"></a>
<pre>

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H1 : subset L1 L2 @
  H2 : subset L2 L3
  ============================
   subset L1 L3

subset_trans < <b>case H1.</b>
</pre>
<a name="896"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  ============================
   subset tl_nil L3

Subgoal 2 is:
 subset (tl_cons X L4) L3

subset_trans < <b>search.</b>
</pre>
<a name="897"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   subset (tl_cons X L4) L3

subset_trans < <b>unfold.</b>
</pre>
<a name="898"></a>
<pre>
Subgoal 2.1:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   {tl_member X L3}

Subgoal 2.2 is:
 subset L4 L3

subset_trans < <b>apply subset_mem to H2 H3.</b>
</pre>
<a name="899"></a>
<pre>
Subgoal 2.1:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  H5 : {tl_member X L3}
  ============================
   {tl_member X L3}

Subgoal 2.2 is:
 subset L4 L3

subset_trans < <b>search.</b>
</pre>
<a name="900"></a>
<pre>
Subgoal 2.2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   subset L4 L3

subset_trans < <b>apply IH to H4 H2.</b>
</pre>
<a name="901"></a>
<pre>
Subgoal 2.2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  H5 : subset L4 L3
  ============================
   subset L4 L3

subset_trans < <b>search.</b>
Proof completed.
</pre>
<a name="902"></a>
<pre class="code">
Abella < <b>Theorem combine_subset1 : 
forall L1 L2 L3, islist L2 -> {combine L1 L2 L3} -> subset L2 L3.</b>
</pre>
<a name="903"></a>
<pre>


  ============================
   forall L1 L2 L3, islist L2 -> {combine L1 L2 L3} -> subset L2 L3

combine_subset1 < <b>induction on 2.</b>
</pre>
<a name="904"></a>
<pre>


  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  ============================
   forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}@ -> subset L2 L3

combine_subset1 < <b>intros.</b>
</pre>
<a name="905"></a>
<pre>

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H2 : {combine L1 L2 L3}@
  ============================
   subset L2 L3

combine_subset1 < <b>case H2.</b>
</pre>
<a name="906"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L3
  ============================
   subset L3 L3

Subgoal 2 is:
 subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < <b>apply subset_refl to H1.</b>
</pre>
<a name="907"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L3
  H3 : subset L3 L3
  ============================
   subset L3 L3

Subgoal 2 is:
 subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < <b>search.</b>
</pre>
<a name="908"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {tl_member X L2}*
  H4 : {combine Fvs1 L2 L3}*
  ============================
   subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < <b>apply IH to H1 H4 with L1 = Fvs1.</b>
</pre>
<a name="909"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {tl_member X L2}*
  H4 : {combine Fvs1 L2 L3}*
  H5 : subset L2 L3
  ============================
   subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < <b>search.</b>
</pre>
<a name="910"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < <b>apply IH to H1 H3 with L1 = Fvs1.</b>
</pre>
<a name="911"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  H4 : subset L2 Fvs
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < <b>apply subset_one to H1 H4 with X = X.</b>
</pre>
<a name="912"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  H4 : subset L2 Fvs
  H5 : subset L2 (tl_cons X Fvs)
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < <b>search.</b>
Proof completed.
</pre>
<a name="913"></a>
<pre class="code">
Abella < <b>Theorem combine_subset2 : 
forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> subset L1 L3.</b>
</pre>
<a name="914"></a>
<pre>


  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
     subset L1 L3

combine_subset2 < <b>induction on 3.</b>
</pre>
<a name="915"></a>
<pre>


  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     subset L1 L3

combine_subset2 < <b>intros.</b>
</pre>
<a name="916"></a>
<pre>

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  ============================
   subset L1 L3

combine_subset2 < <b>case H3.</b>
</pre>
<a name="917"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist tl_nil
  H2 : islist L3
  ============================
   subset tl_nil L3

Subgoal 2 is:
 subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>search.</b>
</pre>
<a name="918"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>apply combine_subset1 to H2 H5.</b>
</pre>
<a name="919"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>apply subset_mem to H6 H4.</b>
</pre>
<a name="920"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>case H1.</b>
</pre>
<a name="921"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  H8 : islist Fvs1
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>apply IH to H8 H2 H5.</b>
</pre>
<a name="922"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  H8 : islist Fvs1
  H9 : subset Fvs1 L3
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>search.</b>
</pre>
<a name="923"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>case H1.</b>
</pre>
<a name="924"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>apply IH to H5 H2 H4.</b>
</pre>
<a name="925"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : subset Fvs1 Fvs
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>apply subset_one to H5 H6 with X = X.</b>
</pre>
<a name="926"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : subset Fvs1 Fvs
  H7 : subset Fvs1 (tl_cons X Fvs)
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>search.</b>
Proof completed.
</pre>
<a name="927"></a>
<pre class="code">
Abella < <b>Theorem subset_combine : 
forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
  subset L1 L4 -> subset L2 L4 -> subset L3 L4.</b>
</pre>
<a name="928"></a>
<pre>


  ============================
   forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
     subset L1 L4 -> subset L2 L4 -> subset L3 L4

subset_combine < <b>induction on 3.</b>
</pre>
<a name="929"></a>
<pre>


  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  ============================
   forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     subset L1 L4 -> subset L2 L4 -> subset L3 L4

subset_combine < <b>intros.</b>
</pre>
<a name="930"></a>
<pre>

  Variables: L1, L2, L3, L4
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  H4 : subset L1 L4
  H5 : subset L2 L4
  ============================
   subset L3 L4

subset_combine < <b>case H3.</b>
</pre>
<a name="931"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3, L4
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist tl_nil
  H2 : islist L3
  H4 : subset tl_nil L4
  H5 : subset L3 L4
  ============================
   subset L3 L4

Subgoal 2 is:
 subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < <b>search.</b>
</pre>
<a name="932"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < <b>case H1.</b>
</pre>
<a name="933"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < <b>case H4.</b>
</pre>
<a name="934"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  H9 : {tl_member X L4}
  H10 : subset Fvs1 L4
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < <b>apply IH to H8 H2 H7 H10 H5.</b>
</pre>
<a name="935"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  H9 : {tl_member X L4}
  H10 : subset Fvs1 L4
  H11 : subset L3 L4
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < <b>search.</b>
</pre>
<a name="936"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  ============================
   subset (tl_cons X Fvs) L4

subset_combine < <b>case H4.</b>
</pre>
<a name="937"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   subset (tl_cons X Fvs) L4

subset_combine < <b>unfold.</b>
</pre>
<a name="938"></a>
<pre>
Subgoal 3.1:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   {tl_member X L4}

Subgoal 3.2 is:
 subset Fvs L4

subset_combine < <b>search.</b>
</pre>
<a name="939"></a>
<pre>
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   subset Fvs L4

subset_combine < <b>case H1.</b>
</pre>
<a name="940"></a>
<pre>
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  H9 : islist Fvs1
  ============================
   subset Fvs L4

subset_combine < <b>apply IH to H9 H2 H6 H8 H5.</b>
</pre>
<a name="941"></a>
<pre>
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  H9 : islist Fvs1
  H10 : subset Fvs L4
  ============================
   subset Fvs L4

subset_combine < <b>search.</b>
Proof completed.
</pre>
<a name="942"></a>
<pre class="code">
Abella < <b>Theorem fvars_islist : 
forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> islist Vs'.</b>
</pre>
<a name="943"></a>
<pre>


  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> islist Vs'

fvars_islist < <b>induction on 2.</b>
</pre>
<a name="944"></a>
<pre>


  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}@ -> islist Vs'

fvars_islist < <b>intros.</b>
</pre>
<a name="945"></a>
<pre>

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   islist Vs'

fvars_islist < <b>case H2.</b>
</pre>
<a name="946"></a>
<pre>
Subgoal 1:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   islist tl_nil

Subgoal 2 is:
 islist tl_nil

Subgoal 3 is:
 islist (tl_cons M tl_nil)

Subgoal 4 is:
 islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < <b>search.</b>
</pre>
<a name="947"></a>
<pre>
Subgoal 2:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  ============================
   islist tl_nil

Subgoal 3 is:
 islist (tl_cons M tl_nil)

Subgoal 4 is:
 islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < <b>search.</b>
</pre>
<a name="948"></a>
<pre>
Subgoal 3:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   islist (tl_cons M tl_nil)

Subgoal 4 is:
 islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < <b>search.</b>
</pre>
<a name="949"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < <b>apply IH to H1 H3.</b>
</pre>
<a name="950"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  ============================
   islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < <b>apply IH to H1 H4.</b>
</pre>
<a name="951"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  ============================
   islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < <b>apply combine_bvar to H1 H5.</b>
</pre>
<a name="952"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  H8 : {combine Fvs1 Fvs2 Vs'}
  ============================
   islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < <b>apply combine_islist to H6 H7 H8.</b>
</pre>
<a name="953"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  H8 : {combine Fvs1 Fvs2 Vs'}
  H9 : islist Vs'
  ============================
   islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < <b>search.</b>
</pre>
<a name="954"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < <b>assert bvars (notfree n1 :: Ps).</b>
</pre>
<a name="955"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < <b>apply IH to H4 H3.</b>
</pre>
<a name="956"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : islist Vs'
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < <b>search.</b>
</pre>
<a name="957"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, F
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   islist Vs'

fvars_islist < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="958"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, F, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- fvars M Vs Vs'}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   islist Vs'

fvars_islist < <b>case H3.</b>
Proof completed.
</pre>
<a name="959"></a>
<pre class="code">
Abella < <b>Theorem fvars_subset : 
forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> subset Vs' Vs.</b>
</pre>
<a name="960"></a>
<pre>


  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> subset Vs' Vs

fvars_subset < <b>induction on 2.</b>
</pre>
<a name="961"></a>
<pre>


  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}@ -> subset Vs' Vs

fvars_subset < <b>intros.</b>
</pre>
<a name="962"></a>
<pre>

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   subset Vs' Vs

fvars_subset < <b>case H2.</b>
</pre>
<a name="963"></a>
<pre>
Subgoal 1:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   subset tl_nil Vs

Subgoal 2 is:
 subset tl_nil Vs

Subgoal 3 is:
 subset (tl_cons M tl_nil) Vs

Subgoal 4 is:
 subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>search.</b>
</pre>
<a name="964"></a>
<pre>
Subgoal 2:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  ============================
   subset tl_nil Vs

Subgoal 3 is:
 subset (tl_cons M tl_nil) Vs

Subgoal 4 is:
 subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>search.</b>
</pre>
<a name="965"></a>
<pre>
Subgoal 3:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   subset (tl_cons M tl_nil) Vs

Subgoal 4 is:
 subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>apply tl_mem_bvar to H1 H3.</b>
</pre>
<a name="966"></a>
<pre>
Subgoal 3:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  H4 : {tl_member M Vs}
  ============================
   subset (tl_cons M tl_nil) Vs

Subgoal 4 is:
 subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>search.</b>
</pre>
<a name="967"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>apply IH to H1 H3.</b>
</pre>
<a name="968"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>apply IH to H1 H4.</b>
</pre>
<a name="969"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>apply fvars_islist to H1 H3.</b>
</pre>
<a name="970"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>apply fvars_islist to H1 H4.</b>
</pre>
<a name="971"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>apply combine_bvar to H1 H5.</b>
</pre>
<a name="972"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  H10 : {combine Fvs1 Fvs2 Vs'}
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>apply subset_combine to H8 H9 H10 H6 H7.</b>
</pre>
<a name="973"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  H10 : {combine Fvs1 Fvs2 Vs'}
  H11 : subset Vs' Vs
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>search.</b>
</pre>
<a name="974"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>assert bvars (notfree n1 :: Ps).</b>
</pre>
<a name="975"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>apply IH to H4 H3.</b>
</pre>
<a name="976"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : subset Vs' Vs
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < <b>search.</b>
</pre>
<a name="977"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, F
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   subset Vs' Vs

fvars_subset < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="978"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, F, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- fvars M Vs Vs'}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   subset Vs' Vs

fvars_subset < <b>case H3.</b>
Proof completed.
</pre>
<a name="979"></a>
<pre class="code">
Abella < <b>Theorem fvars_extend : 
forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'} ->
  {Ps |- fvars M (tl_cons X Vs) Vs'}.</b>
</pre>
<a name="980"></a>
<pre>


  ============================
   forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'} ->
     {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>induction on 2.</b>
</pre>
<a name="981"></a>
<pre>


  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  ============================
   forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}@ ->
     {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>intros.</b>
</pre>
<a name="982"></a>
<pre>

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>case H2.</b>
</pre>
<a name="983"></a>
<pre>
Subgoal 1:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   {Ps |- fvars M (tl_cons X Vs) tl_nil}

Subgoal 2 is:
 {Ps |- fvars (lnat X2) (tl_cons X Vs) tl_nil}

Subgoal 3 is:
 {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>search.</b>
</pre>
<a name="984"></a>
<pre>
Subgoal 2:

  Variables: M, Vs, Vs', Ps, X, X2
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  ============================
   {Ps |- fvars (lnat X2) (tl_cons X Vs) tl_nil}

Subgoal 3 is:
 {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>search.</b>
</pre>
<a name="985"></a>
<pre>
Subgoal 3:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>search.</b>
</pre>
<a name="986"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>apply IH to H1 H3 with X = X.</b>
</pre>
<a name="987"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : {Ps |- fvars M1 (tl_cons X Vs) Fvs1}
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>apply IH to H1 H4 with X = X.</b>
</pre>
<a name="988"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : {Ps |- fvars M1 (tl_cons X Vs) Fvs1}
  H7 : {Ps |- fvars M2 (tl_cons X Vs) Fvs2}
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>search.</b>
</pre>
<a name="989"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>assert bvars (notfree n1 :: Ps).</b>
</pre>
<a name="990"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>apply IH to H4 H3 with X = X.</b>
</pre>
<a name="991"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : {Ps, notfree n1 |- fvars (M1 n1) (tl_cons X Vs) Vs'}
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>search.</b>
</pre>
<a name="992"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, X, F
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="993"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, X, F, X1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, [notfree X1] |- fvars M Vs Vs'}*
  H4 : member (notfree X1) Ps
  H5 : tname X1
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>case H3.</b>
Proof completed.
</pre>
<a name="994"></a>
<pre class="code">
Abella < <b>Define pruned_env : olist -> tm_list -> olist -> olist -> prop by 
pruned_env nil tl_nil SL nil;
pruned_env nil (tl_cons X FVs) SL (of X T :: SL') := member (of X T) SL /\ pruned_env nil FVs SL SL';
nabla x, pruned_env (notfree x :: BVs) FVs (of x T :: SL) (of x T :: SL') := pruned_env BVs FVs SL SL'.</b>
</pre>
<a name="995"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_vars : 
forall FVs SL SL', pruned_env nil FVs SL SL' -> vars_of_sctx SL' FVs.</b>
</pre>
<a name="996"></a>
<pre>


  ============================
   forall FVs SL SL', pruned_env nil FVs SL SL' -> vars_of_sctx SL' FVs

pruned_env_vars < <b>induction on 1.</b>
</pre>
<a name="997"></a>
<pre>


  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  ============================
   forall FVs SL SL', pruned_env nil FVs SL SL' @ -> vars_of_sctx SL' FVs

pruned_env_vars < <b>intros.</b>
</pre>
<a name="998"></a>
<pre>

  Variables: FVs, SL, SL'
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H1 : pruned_env nil FVs SL SL' @
  ============================
   vars_of_sctx SL' FVs

pruned_env_vars < <b>case H1.</b>
</pre>
<a name="999"></a>
<pre>
Subgoal 1:

  Variables: FVs, SL, SL'
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  ============================
   vars_of_sctx nil tl_nil

Subgoal 2 is:
 vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < <b>search.</b>
</pre>
<a name="1000"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', SL'1, T, X, FVs1
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H2 : member (of X T) SL
  H3 : pruned_env nil FVs1 SL SL'1 *
  ============================
   vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < <b>apply IH to H3.</b>
</pre>
<a name="1001"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', SL'1, T, X, FVs1
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H2 : member (of X T) SL
  H3 : pruned_env nil FVs1 SL SL'1 *
  H4 : vars_of_sctx SL'1 FVs1
  ============================
   vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < <b>search.</b>
Proof completed.
</pre>
<a name="1002"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_sctx_source : 
forall FV SL SL' X T, pruned_env nil FV SL SL' -> member (of X T) SL' ->
  member (of X T) SL.</b>
</pre>
<a name="1003"></a>
<pre>


  ============================
   forall FV SL SL' X T, pruned_env nil FV SL SL' -> member (of X T) SL' ->
     member (of X T) SL

pruned_env_sctx_source < <b>induction on 1.</b>
</pre>
<a name="1004"></a>
<pre>


  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  ============================
   forall FV SL SL' X T, pruned_env nil FV SL SL' @ -> member (of X T) SL' ->
     member (of X T) SL

pruned_env_sctx_source < <b>intros.</b>
</pre>
<a name="1005"></a>
<pre>

  Variables: FV, SL, SL', X, T
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H1 : pruned_env nil FV SL SL' @
  H2 : member (of X T) SL'
  ============================
   member (of X T) SL

pruned_env_sctx_source < <b>case H1.</b>
</pre>
<a name="1006"></a>
<pre>
Subgoal 1:

  Variables: FV, SL, SL', X, T
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H2 : member (of X T) nil
  ============================
   member (of X T) SL

Subgoal 2 is:
 member (of X T) SL

pruned_env_sctx_source < <b>case H2.</b>
</pre>
<a name="1007"></a>
<pre>
Subgoal 2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H2 : member (of X T) (of X1 T1 :: SL'1)
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  ============================
   member (of X T) SL

pruned_env_sctx_source < <b>case H2.</b>
</pre>
<a name="1008"></a>
<pre>
Subgoal 2.1:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  ============================
   member (of X1 T1) SL

Subgoal 2.2 is:
 member (of X T) SL

pruned_env_sctx_source < <b>search.</b>
</pre>
<a name="1009"></a>
<pre>
Subgoal 2.2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  H5 : member (of X T) SL'1
  ============================
   member (of X T) SL

pruned_env_sctx_source < <b>apply IH to H4 H5.</b>
</pre>
<a name="1010"></a>
<pre>
Subgoal 2.2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  H5 : member (of X T) SL'1
  H6 : member (of X T) SL
  ============================
   member (of X T) SL

pruned_env_sctx_source < <b>search.</b>
Proof completed.
</pre>
<a name="1011"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_sctx : 
forall SL BVL FVs SL', sctx' SL -> bvars BVL -> pruned_env BVL FVs SL SL' ->
  sctx' SL'.</b>
</pre>
<a name="1012"></a>
<pre>


  ============================
   forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
     pruned_env BVL FVs SL SL' -> sctx' SL'

pruned_env_sctx < <b>induction on 3.</b>
</pre>
<a name="1013"></a>
<pre>


  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  ============================
   forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
     pruned_env BVL FVs SL SL' @ -> sctx' SL'

pruned_env_sctx < <b>intros.</b>
</pre>
<a name="1014"></a>
<pre>

  Variables: SL, BVL, FVs, SL'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars BVL
  H3 : pruned_env BVL FVs SL SL' @
  ============================
   sctx' SL'

pruned_env_sctx < <b>case H3.</b>
</pre>
<a name="1015"></a>
<pre>
Subgoal 1:

  Variables: SL, BVL, FVs, SL'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  ============================
   sctx' nil

Subgoal 2 is:
 sctx' (of X T :: SL'1)

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>search.</b>
</pre>
<a name="1016"></a>
<pre>
Subgoal 2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   sctx' (of X T :: SL'1)

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>unfold.</b>
</pre>
<a name="1017"></a>
<pre>
Subgoal 2.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   sctx' SL'1

Subgoal 2.2 is:
 tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>apply IH to H1 H2 H5.</b>
</pre>
<a name="1018"></a>
<pre>
Subgoal 2.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : sctx' SL'1
  ============================
   sctx' SL'1

Subgoal 2.2 is:
 tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>search.</b>
</pre>
<a name="1019"></a>
<pre>
Subgoal 2.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>apply sctx'_name to H1 H4.</b>
</pre>
<a name="1020"></a>
<pre>
Subgoal 2.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : tname X
  ============================
   tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>search.</b>
</pre>
<a name="1021"></a>
<pre>
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>intros.</b>
</pre>
<a name="1022"></a>
<pre>
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  ============================
   T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>apply pruned_env_sctx_source to H5 H6.</b>
</pre>
<a name="1023"></a>
<pre>
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  H7 : member (of X T') SL
  ============================
   T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>apply sctx'_equal to H1 H4 H7.</b>
</pre>
<a name="1024"></a>
<pre>
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T') SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  H7 : member (of X T') SL
  ============================
   T' = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>search.</b>
</pre>
<a name="1025"></a>
<pre>
Subgoal 3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>unfold.</b>
</pre>
<a name="1026"></a>
<pre>
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>case H1.</b>
</pre>
<a name="1027"></a>
<pre>
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>case H2.</b>
</pre>
<a name="1028"></a>
<pre>
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  H8 : bvars BVs
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>apply IH to H5 H8 H4.</b>
</pre>
<a name="1029"></a>
<pre>
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  H8 : bvars BVs
  H9 : sctx' SL'1
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>search.</b>
</pre>
<a name="1030"></a>
<pre>
Subgoal 3.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>search.</b>
</pre>
<a name="1031"></a>
<pre>
Subgoal 3.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>intros.</b>
</pre>
<a name="1032"></a>
<pre>
Subgoal 3.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (of n1 T') SL'1
  ============================
   T = T'

pruned_env_sctx < <b>apply mem_of_absurd to H5.</b>
Proof completed.
</pre>
<a name="1033"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_bound : 
forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' ->
  member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'.</b>
</pre>
<a name="1034"></a>
<pre>


  ============================
   forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' ->
     member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'

pruned_env_bound < <b>induction on 1.</b>
</pre>
<a name="1035"></a>
<pre>


  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  ============================
   forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' @ ->
     member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'

pruned_env_bound < <b>intros.</b>
</pre>
<a name="1036"></a>
<pre>

  Variables: BVL, FVs, SL, SL', X, T
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H1 : pruned_env BVL FVs SL SL' @
  H2 : member (notfree X) BVL
  H3 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_bound < <b>case H1.</b>
</pre>
<a name="1037"></a>
<pre>
Subgoal 1:

  Variables: BVL, FVs, SL, SL', X, T
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree X) nil
  H3 : member (of X T) SL
  ============================
   member (of X T) nil

Subgoal 2 is:
 member (of X T) (of X1 T1 :: SL'1)

Subgoal 3 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>case H2.</b>
</pre>
<a name="1038"></a>
<pre>
Subgoal 2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, X1, FVs1
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree X) nil
  H3 : member (of X T) SL
  H4 : member (of X1 T1) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   member (of X T) (of X1 T1 :: SL'1)

Subgoal 3 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>case H2.</b>
</pre>
<a name="1039"></a>
<pre>
Subgoal 3:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree (X n1)) (notfree n1 :: BVs)
  H3 : member (of (X n1) T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>case H2.</b>
</pre>
<a name="1040"></a>
<pre>
Subgoal 3.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H3 : member (of n1 T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>case H3.</b>
</pre>
<a name="1041"></a>
<pre>
Subgoal 3.1.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 3.1.2 is:
 member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>search.</b>
</pre>
<a name="1042"></a>
<pre>
Subgoal 3.1.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (of n1 T) SL1
  ============================
   member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>apply mem_of_absurd to H5.</b>
</pre>
<a name="1043"></a>
<pre>
Subgoal 3.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H3 : member (of (X n1) T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>case H3.</b>
</pre>
<a name="1044"></a>
<pre>
Subgoal 3.2.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree n1) BVs
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 3.2.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>search.</b>
</pre>
<a name="1045"></a>
<pre>
Subgoal 3.2.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  H6 : member (of (X n1) T) SL1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>apply IH to H4 H5 H6.</b>
</pre>
<a name="1046"></a>
<pre>
Subgoal 3.2.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  H6 : member (of (X n1) T) SL1
  H7 : member (of (X n1) T) SL'1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>search.</b>
Proof completed.
</pre>
<a name="1047"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_free_aux : 
forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
  {tl_member X FVs} -> member (of X T) SL -> member (of X T) SL'.</b>
</pre>
<a name="1048"></a>
<pre>


  ============================
   forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
     {tl_member X FVs} -> member (of X T) SL -> member (of X T) SL'

pruned_env_free_aux < <b>induction on 3.</b>
</pre>
<a name="1049"></a>
<pre>


  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  ============================
   forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
     {tl_member X FVs}@ -> member (of X T) SL -> member (of X T) SL'

pruned_env_free_aux < <b>intros.</b>
</pre>
<a name="1050"></a>
<pre>

  Variables: FVs, SL, SL', X, T
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil FVs SL SL'
  H3 : {tl_member X FVs}@
  H4 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_free_aux < <b>case H3.</b>
</pre>
<a name="1051"></a>
<pre>
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil (tl_cons X L) SL SL'
  H4 : member (of X T) SL
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < <b>case H2.</b>
</pre>
<a name="1052"></a>
<pre>
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : member (of X T1) SL
  H6 : pruned_env nil L SL SL'1
  ============================
   member (of X T) (of X T1 :: SL'1)

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < <b>apply sctx'_equal to H1 H4 H5.</b>
</pre>
<a name="1053"></a>
<pre>
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T1) SL
  H5 : member (of X T1) SL
  H6 : pruned_env nil L SL SL'1
  ============================
   member (of X T1) (of X T1 :: SL'1)

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < <b>search.</b>
</pre>
<a name="1054"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil (tl_cons Y L) SL SL'
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  ============================
   member (of X T) SL'

pruned_env_free_aux < <b>case H2.</b>
</pre>
<a name="1055"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  H6 : member (of Y T1) SL
  H7 : pruned_env nil L SL SL'1
  ============================
   member (of X T) (of Y T1 :: SL'1)

pruned_env_free_aux < <b>apply IH to H1 H7 H5 H4.</b>
</pre>
<a name="1056"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  H6 : member (of Y T1) SL
  H7 : pruned_env nil L SL SL'1
  H8 : member (of X T) SL'1
  ============================
   member (of X T) (of Y T1 :: SL'1)

pruned_env_free_aux < <b>search.</b>
Proof completed.
</pre>
<a name="1057"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_free : 
forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
  pruned_env BVLs FVs SL SL' -> {tl_member X FVs} -> member (of X T) SL ->
  member (of X T) SL'.</b>
</pre>
<a name="1058"></a>
<pre>


  ============================
   forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
     pruned_env BVLs FVs SL SL' -> {tl_member X FVs} -> member (of X T) SL ->
     member (of X T) SL'

pruned_env_free < <b>induction on 3.</b>
</pre>
<a name="1059"></a>
<pre>


  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  ============================
   forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
     pruned_env BVLs FVs SL SL' @ -> {tl_member X FVs} ->
     member (of X T) SL -> member (of X T) SL'

pruned_env_free < <b>intros.</b>
</pre>
<a name="1060"></a>
<pre>

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : bvars BVLs
  H3 : pruned_env BVLs FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_free < <b>case H2.</b>
</pre>
<a name="1061"></a>
<pre>
Subgoal 1:

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H3 : pruned_env nil FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of (X n1) T) (SL' n1)

pruned_env_free < <b>apply pruned_env_free_aux to H1 H3 H4 H5.</b>
</pre>
<a name="1062"></a>
<pre>
Subgoal 1:

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H3 : pruned_env nil FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  H6 : member (of X T) SL'
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of (X n1) T) (SL' n1)

pruned_env_free < <b>search.</b>
</pre>
<a name="1063"></a>
<pre>
Subgoal 2:

  Variables: BVLs, FVs, SL, SL', X, T, L
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (SL n1)
  H3 : pruned_env (notfree n1 :: L) (FVs n1) (SL n1) (SL' n1) @
  H4 : {tl_member (X n1) (FVs n1)}
  H5 : member (of (X n1) T) (SL n1)
  H6 : bvars L
  ============================
   member (of (X n1) T) (SL' n1)

pruned_env_free < <b>case H3.</b>
</pre>
<a name="1064"></a>
<pre>
Subgoal 2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H5 : member (of (X n1) T) (of n1 T1 :: SL1)
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>case H5.</b>
</pre>
<a name="1065"></a>
<pre>
Subgoal 2.1:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member n1 FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 2.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>search.</b>
</pre>
<a name="1066"></a>
<pre>
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>assert bvars (notfree n1 :: L).</b>
</pre>
<a name="1067"></a>
<pre>
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>case H1.</b>
</pre>
<a name="1068"></a>
<pre>
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  H10 : sctx' SL1
  H11 : tname n1
  H12 : forall T', member (of n1 T') SL1 -> T1 = T'
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>apply IH to H10 H6 H7 H4 H8.</b>
</pre>
<a name="1069"></a>
<pre>
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  H10 : sctx' SL1
  H11 : tname n1
  H12 : forall T', member (of n1 T') SL1 -> T1 = T'
  H13 : member (of (X n1) T) SL'1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>search.</b>
Proof completed.
</pre>
<a name="1070"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_typing : 
forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T} ->
  vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
  subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}.</b>
</pre>
<a name="1071"></a>
<pre>


  ============================
   forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T} ->
     vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
     subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}

pruned_env_typing < <b>induction on 2.</b>
</pre>
<a name="1072"></a>
<pre>


  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  ============================
   forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}@ ->
     vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
     subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}

pruned_env_typing < <b>intros.</b>
</pre>
<a name="1073"></a>
<pre>

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs''
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H2 : {SL |- of M T}@
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  ============================
   {SL' |- of M T}

pruned_env_typing < <b>case H2.</b>
</pre>
<a name="1074"></a>
<pre>
Subgoal 1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (lnat X) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  ============================
   {SL' |- of (lnat X) nat_t}

Subgoal 2 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>search.</b>
</pre>
<a name="1075"></a>
<pre>
Subgoal 2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (app M1 N) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H5.</b>
</pre>
<a name="1076"></a>
<pre>
Subgoal 2.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- notfree (app M1 N)}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.2 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply bvars_notfree to H4 H10.</b>
</pre>
<a name="1077"></a>
<pre>
Subgoal 2.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- notfree (app M1 N)}
  H11 : tname (app M1 N)
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.2 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H11.</b>
</pre>
<a name="1078"></a>
<pre>
Subgoal 2.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply tl_mem_bvar to H4 H10.</b>
</pre>
<a name="1079"></a>
<pre>
Subgoal 2.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  H11 : {tl_member (app M1 N) FVs}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply vars_of_sctx_mem_name to H1 H3 H11.</b>
</pre>
<a name="1080"></a>
<pre>
Subgoal 2.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  H11 : {tl_member (app M1 N) FVs}
  H12 : tname (app M1 N)
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H12.</b>
</pre>
<a name="1081"></a>
<pre>
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply fvars_islist to H4 H10.</b>
</pre>
<a name="1082"></a>
<pre>
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply fvars_islist to H4 H11.</b>
</pre>
<a name="1083"></a>
<pre>
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply combine_bvar to H4 H12.</b>
</pre>
<a name="1084"></a>
<pre>
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply combine_islist to H13 H14 H15.</b>
</pre>
<a name="1085"></a>
<pre>
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply combine_subset2 to H13 H14 H15.</b>
</pre>
<a name="1086"></a>
<pre>
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply subset_trans to H17 H6.</b>
</pre>
<a name="1087"></a>
<pre>
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply IH to H1 H8 H3 H4 H10 H18 H7.</b>
</pre>
<a name="1088"></a>
<pre>
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply combine_subset1 to H14 H15.</b>
</pre>
<a name="1089"></a>
<pre>
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply subset_trans to H20 H6.</b>
</pre>
<a name="1090"></a>
<pre>
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  H21 : subset Fvs2 FVs''
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply IH to H1 H9 H3 H4 H11 H21 H7.</b>
</pre>
<a name="1091"></a>
<pre>
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  H21 : subset Fvs2 FVs''
  H22 : {SL' |- of N T1}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>search.</b>
</pre>
<a name="1092"></a>
<pre>
Subgoal 2.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL, [F] |- fvars (app M1 N) FVs FVs'}
  H11 : member F BVL
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply bvars_mem to H4 H11.</b>
</pre>
<a name="1093"></a>
<pre>
Subgoal 2.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, F, X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL, [notfree X] |- fvars (app M1 N) FVs FVs'}
  H11 : member (notfree X) BVL
  H12 : tname X
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H10.</b>
</pre>
<a name="1094"></a>
<pre>
Subgoal 3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (abs M1) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H5.</b>
</pre>
<a name="1095"></a>
<pre>
Subgoal 3.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- notfree (abs M1)}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.2 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply bvars_notfree to H4 H9.</b>
</pre>
<a name="1096"></a>
<pre>
Subgoal 3.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- notfree (abs M1)}
  H10 : tname (abs M1)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.2 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H10.</b>
</pre>
<a name="1097"></a>
<pre>
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply tl_mem_bvar to H4 H9.</b>
</pre>
<a name="1098"></a>
<pre>
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  H10 : {tl_member (abs M1) FVs}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply vars_of_sctx_mem_name to H1 H3 H10.</b>
</pre>
<a name="1099"></a>
<pre>
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  H10 : {tl_member (abs M1) FVs}
  H11 : tname (abs M1)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H11.</b>
</pre>
<a name="1100"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>assert pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL').</b>
</pre>
<a name="1101"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>assert bvars (notfree n1 :: BVL).</b>
</pre>
<a name="1102"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>assert vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs).</b>
</pre>
<a name="1103"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply sctx'_extend to H1 with T = T1.</b>
</pre>
<a name="1104"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply fvars_extend to H11 H9 with X = n1.</b>
</pre>
<a name="1105"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  H14 : {BVL, notfree n1 |- fvars (M1 n1) (tl_cons n1 FVs) FVs'}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply IH to H13 H8 H12 H11 H14 H6 H10.</b>
</pre>
<a name="1106"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  H14 : {BVL, notfree n1 |- fvars (M1 n1) (tl_cons n1 FVs) FVs'}
  H15 : {SL', of n1 T1 |- of (M1 n1) T2}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>search.</b>
</pre>
<a name="1107"></a>
<pre>
Subgoal 3.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1, F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, [F] |- fvars (abs M1) FVs FVs'}
  H10 : member F BVL
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply bvars_mem to H4 H10.</b>
</pre>
<a name="1108"></a>
<pre>
Subgoal 3.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1, F, X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, [notfree X] |- fvars (abs M1) FVs FVs'}
  H10 : member (notfree X) BVL
  H11 : tname X
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H9.</b>
</pre>
<a name="1109"></a>
<pre>
Subgoal 4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, [F] |- of M T}*
  H9 : member F SL
  ============================
   {SL' |- of M T}

pruned_env_typing < <b>apply sctx'_mem to H1 H9.</b>
</pre>
<a name="1110"></a>
<pre>
Subgoal 4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, [of X T1] |- of M T}*
  H9 : member (of X T1) SL
  H10 : tname X
  ============================
   {SL' |- of M T}

pruned_env_typing < <b>case H8.</b>
</pre>
<a name="1111"></a>
<pre>
Subgoal 4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H9 : member (of M T) SL
  H10 : tname M
  ============================
   {SL' |- of M T}

pruned_env_typing < <b>case H10.</b>
</pre>
<a name="1112"></a>
<pre>
Subgoal 4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H5 : {BVL n1 |- fvars n1 (FVs n1) (FVs' n1)}
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H5.</b>
</pre>
<a name="1113"></a>
<pre>
Subgoal 4.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- notfree n1}
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H11.</b>
</pre>
<a name="1114"></a>
<pre>
Subgoal 4.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [F1 n1] |- notfree n1}
  H13 : member (F1 n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>apply bvars_mem to H4 H13.</b>
</pre>
<a name="1115"></a>
<pre>
Subgoal 4.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree (X1 n1)] |- notfree n1}
  H13 : member (notfree (X1 n1)) (BVL n1)
  H14 : tname (X1 n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H14.</b>
</pre>
<a name="1116"></a>
<pre>
Subgoal 4.1.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n2 n1)
  H3 : vars_of_sctx (SL n2 n1) (FVs n2 n1)
  H4 : bvars (BVL n2 n1)
  H6 : subset tl_nil (FVs'' n2 n1)
  H7 : pruned_env (BVL n2 n1) (FVs'' n2 n1) (SL n2 n1) (SL' n2 n1)
  H9 : member (of n1 T) (SL n2 n1)
  H12 : {BVL n2 n1, [notfree n2] |- notfree n1}
  H13 : member (notfree n2) (BVL n2 n1)
  ============================
   {SL' n2 n1 |- of n1 T}

Subgoal 4.1.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H12.</b>
</pre>
<a name="1117"></a>
<pre>
Subgoal 4.1.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree n1] |- notfree n1}
  H13 : member (notfree n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>apply pruned_env_bound to H7 H13 H9.</b>
</pre>
<a name="1118"></a>
<pre>
Subgoal 4.1.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree n1] |- notfree n1}
  H13 : member (notfree n1) (BVL n1)
  H15 : member (of n1 T) (SL' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>search.</b>
</pre>
<a name="1119"></a>
<pre>
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (tl_cons n1 tl_nil) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H6.</b>
</pre>
<a name="1120"></a>
<pre>
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  H12 : {tl_member n1 (FVs'' n1)}
  H13 : subset tl_nil (FVs'' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>apply pruned_env_free to H1 H4 H7 H12 H9.</b>
</pre>
<a name="1121"></a>
<pre>
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  H12 : {tl_member n1 (FVs'' n1)}
  H13 : subset tl_nil (FVs'' n1)
  H14 : member (of n1 T) (SL' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>search.</b>
</pre>
<a name="1122"></a>
<pre>
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1, [F1 n1] |- fvars n1 (FVs n1) (FVs' n1)}
  H12 : member (F1 n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < <b>apply bvars_mem to H4 H12.</b>
</pre>
<a name="1123"></a>
<pre>
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1, [notfree (X1 n1)] |- fvars n1 (FVs n1) (FVs' n1)}
  H12 : member (notfree (X1 n1)) (BVL n1)
  H13 : tname (X1 n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H11.</b>
Proof completed.
</pre>
<a name="1124"></a>
<pre class="code">
Abella < <b>Theorem mapvar_named_map : 
forall L FVs Map X, sctx' L -> vars_of_sctx L FVs -> {mapvar FVs Map} ->
  name_map (Map X).</b>
</pre>
<a name="1125"></a>
<pre>


  ============================
   forall L FVs Map X, sctx' L -> vars_of_sctx L FVs -> {mapvar FVs Map} ->
     name_map (Map X)

mapvar_named_map < <b>induction on 1.</b>
</pre>
<a name="1126"></a>
<pre>


  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  ============================
   forall L FVs Map X, sctx' L @ -> vars_of_sctx L FVs -> {mapvar FVs Map} ->
     name_map (Map X)

mapvar_named_map < <b>intros.</b>
</pre>
<a name="1127"></a>
<pre>

  Variables: L, FVs, Map, X
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H1 : sctx' L @
  H2 : vars_of_sctx L FVs
  H3 : {mapvar FVs Map}
  ============================
   name_map (Map X)

mapvar_named_map < <b>case H1.</b>
</pre>
<a name="1128"></a>
<pre>
Subgoal 1:

  Variables: L, FVs, Map, X
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H2 : vars_of_sctx nil FVs
  H3 : {mapvar FVs Map}
  ============================
   name_map (Map X)

Subgoal 2 is:
 name_map (Map X)

mapvar_named_map < <b>case H2.</b>
</pre>
<a name="1129"></a>
<pre>
Subgoal 1:

  Variables: L, FVs, Map, X
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H3 : {mapvar tl_nil Map}
  ============================
   name_map (Map X)

Subgoal 2 is:
 name_map (Map X)

mapvar_named_map < <b>case H3.</b>
</pre>
<a name="1130"></a>
<pre>
Subgoal 1:

  Variables: L, FVs, Map, X
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  ============================
   name_map ml_nil

Subgoal 2 is:
 name_map (Map X)

mapvar_named_map < <b>search.</b>
</pre>
<a name="1131"></a>
<pre>
Subgoal 2:

  Variables: L, FVs, Map, X, L1, T, X1
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H2 : vars_of_sctx (of X1 T :: L1) FVs
  H3 : {mapvar FVs Map}
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  ============================
   name_map (Map X)

mapvar_named_map < <b>case H2.</b>
</pre>
<a name="1132"></a>
<pre>
Subgoal 2:

  Variables: L, FVs, Map, X, L1, T, X1, Vs
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H3 : {mapvar (tl_cons X1 Vs) Map}
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  H7 : vars_of_sctx L1 Vs
  ============================
   name_map (Map X)

mapvar_named_map < <b>case H3.</b>
</pre>
<a name="1133"></a>
<pre>
Subgoal 2:

  Variables: L, FVs, Map, X, L1, T, X1, Vs, Map1
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  H7 : vars_of_sctx L1 Vs
  H8 : {mapvar Vs Map1}
  ============================
   name_map (ml_cons (map X1 (fst X)) (Map1 (rst X)))

mapvar_named_map < <b>apply IH to H4 H7 H8 with X = rst X.</b>
</pre>
<a name="1134"></a>
<pre>
Subgoal 2:

  Variables: L, FVs, Map, X, L1, T, X1, Vs, Map1
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  H7 : vars_of_sctx L1 Vs
  H8 : {mapvar Vs Map1}
  H9 : name_map (Map1 (rst X))
  ============================
   name_map (ml_cons (map X1 (fst X)) (Map1 (rst X)))

mapvar_named_map < <b>search.</b>
Proof completed.
</pre>
<a name="1135"></a>
<pre class="code">
Abella < <b>Define sim : ty -> tm -> ctm -> prop,	
equiv : ty -> tm -> ctm -> prop by 
sim T M N := exists V V', {eval M V} /\ {evalcc N V'} /\ equiv T V V';
equiv nat_t (lnat N) (clnat N);
equiv (arr T1 T2) M N := {tm M} /\ {ctm N} /\ {val M} /\ {cval N} /\ (forall V1 V1',
  equiv T1 V1 V1' ->
  sim T2 (app M V1) (cunpair N (f\env\capp f (cross V1' env)))).</b>
Warning: Definition might not be stratified
</pre>
<a name="1136"></a>
<pre class="code">
Abella < <b>Theorem equiv_val : 
forall T V V', equiv T V V' -> {val V}.</b>
</pre>
<a name="1137"></a>
<pre>


  ============================
   forall T V V', equiv T V V' -> {val V}

equiv_val < <b>intros.</b>
</pre>
<a name="1138"></a>
<pre>

  Variables: T, V, V'
  H1 : equiv T V V'
  ============================
   {val V}

equiv_val < <b>case H1.</b>
</pre>
<a name="1139"></a>
<pre>
Subgoal 1:

  Variables: T, V, V', N
  ============================
   {val (lnat N)}

Subgoal 2 is:
 {val V}

equiv_val < <b>search.</b>
</pre>
<a name="1140"></a>
<pre>
Subgoal 2:

  Variables: T, V, V', T2, T1
  H2 : {tm V}
  H3 : {ctm V'}
  H4 : {val V}
  H5 : {cval V'}
  H6 : forall V1 V1', equiv T1 V1 V1' ->
         sim T2 (app V V1) (cunpair V' (f\env\capp f (cross V1' env)))
  ============================
   {val V}

equiv_val < <b>search.</b>
Proof completed.
</pre>
<a name="1141"></a>
<pre class="code">
Abella < <b>Theorem equiv_cval : 
forall T V V', equiv T V V' -> {cval V'}.</b>
</pre>
<a name="1142"></a>
<pre>


  ============================
   forall T V V', equiv T V V' -> {cval V'}

equiv_cval < <b>intros.</b>
</pre>
<a name="1143"></a>
<pre>

  Variables: T, V, V'
  H1 : equiv T V V'
  ============================
   {cval V'}

equiv_cval < <b>case H1.</b>
</pre>
<a name="1144"></a>
<pre>
Subgoal 1:

  Variables: T, V, V', N
  ============================
   {cval (clnat N)}

Subgoal 2 is:
 {cval V'}

equiv_cval < <b>search.</b>
</pre>
<a name="1145"></a>
<pre>
Subgoal 2:

  Variables: T, V, V', T2, T1
  H2 : {tm V}
  H3 : {ctm V'}
  H4 : {val V}
  H5 : {cval V'}
  H6 : forall V1 V1', equiv T1 V1 V1' ->
         sim T2 (app V V1) (cunpair V' (f\env\capp f (cross V1' env)))
  ============================
   {cval V'}

equiv_cval < <b>search.</b>
Proof completed.
</pre>
<a name="1146"></a>
<pre class="code">
Abella < <b>Theorem equiv_closed_tm : 
forall T V V', equiv T V V' -> {tm V}.</b>
</pre>
<a name="1147"></a>
<pre>


  ============================
   forall T V V', equiv T V V' -> {tm V}

equiv_closed_tm < <b>intros.</b>
</pre>
<a name="1148"></a>
<pre>

  Variables: T, V, V'
  H1 : equiv T V V'
  ============================
   {tm V}

equiv_closed_tm < <b>case H1.</b>
</pre>
<a name="1149"></a>
<pre>
Subgoal 1:

  Variables: T, V, V', N
  ============================
   {tm (lnat N)}

Subgoal 2 is:
 {tm V}

equiv_closed_tm < <b>search.</b>
</pre>
<a name="1150"></a>
<pre>
Subgoal 2:

  Variables: T, V, V', T2, T1
  H2 : {tm V}
  H3 : {ctm V'}
  H4 : {val V}
  H5 : {cval V'}
  H6 : forall V1 V1', equiv T1 V1 V1' ->
         sim T2 (app V V1) (cunpair V' (f\env\capp f (cross V1' env)))
  ============================
   {tm V}

equiv_closed_tm < <b>search.</b>
Proof completed.
</pre>
<a name="1151"></a>
<pre class="code">
Abella < <b>Theorem equiv_closed_ctm : 
forall T V V', equiv T V V' -> {ctm V'}.</b>
</pre>
<a name="1152"></a>
<pre>


  ============================
   forall T V V', equiv T V V' -> {ctm V'}

equiv_closed_ctm < <b>intros.</b>
</pre>
<a name="1153"></a>
<pre>

  Variables: T, V, V'
  H1 : equiv T V V'
  ============================
   {ctm V'}

equiv_closed_ctm < <b>case H1.</b>
</pre>
<a name="1154"></a>
<pre>
Subgoal 1:

  Variables: T, V, V', N
  ============================
   {ctm (clnat N)}

Subgoal 2 is:
 {ctm V'}

equiv_closed_ctm < <b>search.</b>
</pre>
<a name="1155"></a>
<pre>
Subgoal 2:

  Variables: T, V, V', T2, T1
  H2 : {tm V}
  H3 : {ctm V'}
  H4 : {val V}
  H5 : {cval V'}
  H6 : forall V1 V1', equiv T1 V1 V1' ->
         sim T2 (app V V1) (cunpair V' (f\env\capp f (cross V1' env)))
  ============================
   {ctm V'}

equiv_closed_ctm < <b>search.</b>
Proof completed.
</pre>
<a name="1156"></a>
<pre class="code">
Abella < <b>Theorem equiv_to_sim : 
forall T M N, equiv T M N -> sim T M N.</b>
</pre>
<a name="1157"></a>
<pre>


  ============================
   forall T M N, equiv T M N -> sim T M N

equiv_to_sim < <b>intros.</b>
</pre>
<a name="1158"></a>
<pre>

  Variables: T, M, N
  H1 : equiv T M N
  ============================
   sim T M N

equiv_to_sim < <b>apply equiv_val to H1.</b>
</pre>
<a name="1159"></a>
<pre>

  Variables: T, M, N
  H1 : equiv T M N
  H2 : {val M}
  ============================
   sim T M N

equiv_to_sim < <b>apply equiv_cval to H1.</b>
</pre>
<a name="1160"></a>
<pre>

  Variables: T, M, N
  H1 : equiv T M N
  H2 : {val M}
  H3 : {cval N}
  ============================
   sim T M N

equiv_to_sim < <b>apply val_eval to H2.</b>
</pre>
<a name="1161"></a>
<pre>

  Variables: T, M, N
  H1 : equiv T M N
  H2 : {val M}
  H3 : {cval N}
  H4 : {eval M M}
  ============================
   sim T M N

equiv_to_sim < <b>apply val_evalcc to H3.</b>
</pre>
<a name="1162"></a>
<pre>

  Variables: T, M, N
  H1 : equiv T M N
  H2 : {val M}
  H3 : {cval N}
  H4 : {eval M M}
  H5 : {evalcc N N}
  ============================
   sim T M N

equiv_to_sim < <b>search.</b>
Proof completed.
</pre>
<a name="1163"></a>
<pre class="code">
Abella < <b>Define subst : smap_list -> prop by 
subst sml_nil;
subst (sml_cons (smap X V) ML) := subst ML /\ tname X /\ {tm V} /\ {val V} /\ (forall V',
  {sml_member (smap X V') ML} -> V' = V).</b>
</pre>
<a name="1164"></a>
<pre class="code">
Abella < <b>Theorem subst_mem : 
forall ML E, subst ML -> {sml_member E ML} -> (exists X V, E = smap X V /\
  tname X /\ {val V} /\ {tm V}).</b>
</pre>
<a name="1165"></a>
<pre>


  ============================
   forall ML E, subst ML -> {sml_member E ML} -> (exists X V, E = smap X V /\
     tname X /\ {val V} /\ {tm V})

subst_mem < <b>induction on 1.</b>
</pre>
<a name="1166"></a>
<pre>


  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  ============================
   forall ML E, subst ML @ -> {sml_member E ML} -> (exists X V,
     E = smap X V /\ tname X /\ {val V} /\ {tm V})

subst_mem < <b>intros.</b>
</pre>
<a name="1167"></a>
<pre>

  Variables: ML, E
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H1 : subst ML @
  H2 : {sml_member E ML}
  ============================
   exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < <b>case H1.</b>
</pre>
<a name="1168"></a>
<pre>
Subgoal 1:

  Variables: ML, E
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H2 : {sml_member E sml_nil}
  ============================
   exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

Subgoal 2 is:
 exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < <b>case H2.</b>
</pre>
<a name="1169"></a>
<pre>
Subgoal 2:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H2 : {sml_member E (sml_cons (smap X V) ML1)}
  H3 : subst ML1 *
  H4 : tname X
  H5 : {tm V}
  H6 : {val V}
  H7 : forall V', {sml_member (smap X V') ML1} -> V' = V
  ============================
   exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < <b>case H2.</b>
</pre>
<a name="1170"></a>
<pre>
Subgoal 2.1:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H3 : subst ML1 *
  H4 : tname X
  H5 : {tm V}
  H6 : {val V}
  H7 : forall V', {sml_member (smap X V') ML1} -> V' = V
  ============================
   exists X1 V1, smap X V = smap X1 V1 /\ tname X1 /\ {val V1} /\ {tm V1}

Subgoal 2.2 is:
 exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < <b>search.</b>
</pre>
<a name="1171"></a>
<pre>
Subgoal 2.2:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H3 : subst ML1 *
  H4 : tname X
  H5 : {tm V}
  H6 : {val V}
  H7 : forall V', {sml_member (smap X V') ML1} -> V' = V
  H8 : {sml_member E ML1}
  ============================
   exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < <b>apply IH to H3 H8.</b>
</pre>
<a name="1172"></a>
<pre>
Subgoal 2.2:

  Variables: ML, E, ML1, V, X, X1, V1
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H3 : subst ML1 *
  H4 : tname X
  H5 : {tm V}
  H6 : {val V}
  H7 : forall V', {sml_member (smap X V') ML1} -> V' = V
  H8 : {sml_member (smap X1 V1) ML1}
  H9 : tname X1
  H10 : {val V1}
  H11 : {tm V1}
  ============================
   exists X V, smap X1 V1 = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < <b>search.</b>
Proof completed.
</pre>
<a name="1173"></a>
<pre class="code">
Abella < <b>Theorem subst_extend : 
forall ML V, nabla x, subst ML -> {tm V} -> {val V} ->
  subst (sml_cons (smap x V) ML).</b>
</pre>
<a name="1174"></a>
<pre>


  ============================
   forall ML V, nabla x, subst ML -> {tm V} -> {val V} ->
     subst (sml_cons (smap x V) ML)

subst_extend < <b>intros.</b>
</pre>
<a name="1175"></a>
<pre>

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   subst (sml_cons (smap n1 V) ML)

subst_extend < <b>unfold.</b>
</pre>
<a name="1176"></a>
<pre>
Subgoal 1:

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   subst ML

Subgoal 2 is:
 tname n1

Subgoal 3 is:
 {tm V}

Subgoal 4 is:
 {val V}

Subgoal 5 is:
 forall V', {sml_member (smap n1 V') ML} -> V' = V

subst_extend < <b>search.</b>
</pre>
<a name="1177"></a>
<pre>
Subgoal 2:

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   tname n1

Subgoal 3 is:
 {tm V}

Subgoal 4 is:
 {val V}

Subgoal 5 is:
 forall V', {sml_member (smap n1 V') ML} -> V' = V

subst_extend < <b>search.</b>
</pre>
<a name="1178"></a>
<pre>
Subgoal 3:

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   {tm V}

Subgoal 4 is:
 {val V}

Subgoal 5 is:
 forall V', {sml_member (smap n1 V') ML} -> V' = V

subst_extend < <b>search.</b>
</pre>
<a name="1179"></a>
<pre>
Subgoal 4:

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   {val V}

Subgoal 5 is:
 forall V', {sml_member (smap n1 V') ML} -> V' = V

subst_extend < <b>search.</b>
</pre>
<a name="1180"></a>
<pre>
Subgoal 5:

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   forall V', {sml_member (smap n1 V') ML} -> V' = V

subst_extend < <b>intros.</b>
</pre>
<a name="1181"></a>
<pre>
Subgoal 5:

  Variables: ML, V, V'
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  H4 : {sml_member (smap n1 (V' n1)) ML}
  ============================
   V' n1 = V

subst_extend < <b>apply sml_mem_absurd to H4.</b>
Proof completed.
</pre>
<a name="1182"></a>
<pre class="code">
Abella < <b>Define csubst : cmap_list -> prop by 
csubst cml_nil;
csubst (cml_cons (cmap X V) ML) := csubst ML /\ ctname X /\ {ctm V} /\ {cval V} /\ (forall V',
  {cml_member (cmap X V') ML} -> V' = V).</b>
</pre>
<a name="1183"></a>
<pre class="code">
Abella < <b>Theorem csubst_mem : 
forall ML E, csubst ML -> {cml_member E ML} -> (exists X V, E = cmap X V /\
  ctname X /\ {cval V} /\ {ctm V}).</b>
</pre>
<a name="1184"></a>
<pre>


  ============================
   forall ML E, csubst ML -> {cml_member E ML} -> (exists X V,
     E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})

csubst_mem < <b>induction on 1.</b>
</pre>
<a name="1185"></a>
<pre>


  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  ============================
   forall ML E, csubst ML @ -> {cml_member E ML} -> (exists X V,
     E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})

csubst_mem < <b>intros.</b>
</pre>
<a name="1186"></a>
<pre>

  Variables: ML, E
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H1 : csubst ML @
  H2 : {cml_member E ML}
  ============================
   exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < <b>case H1.</b>
</pre>
<a name="1187"></a>
<pre>
Subgoal 1:

  Variables: ML, E
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H2 : {cml_member E cml_nil}
  ============================
   exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

Subgoal 2 is:
 exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < <b>case H2.</b>
</pre>
<a name="1188"></a>
<pre>
Subgoal 2:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H2 : {cml_member E (cml_cons (cmap X V) ML1)}
  H3 : csubst ML1 *
  H4 : ctname X
  H5 : {ctm V}
  H6 : {cval V}
  H7 : forall V', {cml_member (cmap X V') ML1} -> V' = V
  ============================
   exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < <b>case H2.</b>
</pre>
<a name="1189"></a>
<pre>
Subgoal 2.1:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H3 : csubst ML1 *
  H4 : ctname X
  H5 : {ctm V}
  H6 : {cval V}
  H7 : forall V', {cml_member (cmap X V') ML1} -> V' = V
  ============================
   exists X1 V1, cmap X V = cmap X1 V1 /\ ctname X1 /\ {cval V1} /\ {ctm V1}

Subgoal 2.2 is:
 exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < <b>search.</b>
</pre>
<a name="1190"></a>
<pre>
Subgoal 2.2:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H3 : csubst ML1 *
  H4 : ctname X
  H5 : {ctm V}
  H6 : {cval V}
  H7 : forall V', {cml_member (cmap X V') ML1} -> V' = V
  H8 : {cml_member E ML1}
  ============================
   exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < <b>apply IH to H3 H8.</b>
</pre>
<a name="1191"></a>
<pre>
Subgoal 2.2:

  Variables: ML, E, ML1, V, X, X1, V1
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H3 : csubst ML1 *
  H4 : ctname X
  H5 : {ctm V}
  H6 : {cval V}
  H7 : forall V', {cml_member (cmap X V') ML1} -> V' = V
  H8 : {cml_member (cmap X1 V1) ML1}
  H9 : ctname X1
  H10 : {cval V1}
  H11 : {ctm V1}
  ============================
   exists X V, cmap X1 V1 = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < <b>search.</b>
Proof completed.
</pre>
<a name="1192"></a>
<pre class="code">
Abella < <b>Theorem csubst_extend : 
forall ML V, nabla x, csubst ML -> {ctm V} -> {cval V} ->
  csubst (cml_cons (cmap x V) ML).</b>
</pre>
<a name="1193"></a>
<pre>


  ============================
   forall ML V, nabla x, csubst ML -> {ctm V} -> {cval V} ->
     csubst (cml_cons (cmap x V) ML)

csubst_extend < <b>intros.</b>
</pre>
<a name="1194"></a>
<pre>

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   csubst (cml_cons (cmap n1 V) ML)

csubst_extend < <b>unfold.</b>
</pre>
<a name="1195"></a>
<pre>
Subgoal 1:

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   csubst ML

Subgoal 2 is:
 ctname n1

Subgoal 3 is:
 {ctm V}

Subgoal 4 is:
 {cval V}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') ML} -> V' = V

csubst_extend < <b>search.</b>
</pre>
<a name="1196"></a>
<pre>
Subgoal 2:

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   ctname n1

Subgoal 3 is:
 {ctm V}

Subgoal 4 is:
 {cval V}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') ML} -> V' = V

csubst_extend < <b>search.</b>
</pre>
<a name="1197"></a>
<pre>
Subgoal 3:

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   {ctm V}

Subgoal 4 is:
 {cval V}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') ML} -> V' = V

csubst_extend < <b>search.</b>
</pre>
<a name="1198"></a>
<pre>
Subgoal 4:

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   {cval V}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') ML} -> V' = V

csubst_extend < <b>search.</b>
</pre>
<a name="1199"></a>
<pre>
Subgoal 5:

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   forall V', {cml_member (cmap n1 V') ML} -> V' = V

csubst_extend < <b>intros.</b>
</pre>
<a name="1200"></a>
<pre>
Subgoal 5:

  Variables: ML, V, V'
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  H4 : {cml_member (cmap n1 (V' n1)) ML}
  ============================
   V' n1 = V

csubst_extend < <b>apply cml_mem_absurd to H4.</b>
Proof completed.
</pre>
<a name="1201"></a>
<pre class="code">
Abella < <b>Theorem csubst_single_inv : 
forall V VL, nabla x, csubst (cml_cons (cmap x (cross V VL)) cml_nil) ->
  csubst (cml_cons (cmap x VL) cml_nil).</b>
</pre>
<a name="1202"></a>
<pre>


  ============================
   forall V VL, nabla x, csubst (cml_cons (cmap x (cross V VL)) cml_nil) ->
     csubst (cml_cons (cmap x VL) cml_nil)

csubst_single_inv < <b>intros.</b>
</pre>
<a name="1203"></a>
<pre>

  Variables: V, VL
  H1 : csubst (cml_cons (cmap n1 (cross V VL)) cml_nil)
  ============================
   csubst (cml_cons (cmap n1 VL) cml_nil)

csubst_single_inv < <b>case H1.</b>
</pre>
<a name="1204"></a>
<pre>

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   csubst (cml_cons (cmap n1 VL) cml_nil)

csubst_single_inv < <b>unfold.</b>
</pre>
<a name="1205"></a>
<pre>
Subgoal 1:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   csubst cml_nil

Subgoal 2 is:
 ctname n1

Subgoal 3 is:
 {ctm VL}

Subgoal 4 is:
 {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < <b>search.</b>
</pre>
<a name="1206"></a>
<pre>
Subgoal 2:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   ctname n1

Subgoal 3 is:
 {ctm VL}

Subgoal 4 is:
 {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < <b>search.</b>
</pre>
<a name="1207"></a>
<pre>
Subgoal 3:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   {ctm VL}

Subgoal 4 is:
 {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < <b>case H4.</b>
</pre>
<a name="1208"></a>
<pre>
Subgoal 3:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  H7 : {ctm V}
  H8 : {ctm VL}
  ============================
   {ctm VL}

Subgoal 4 is:
 {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < <b>search.</b>
</pre>
<a name="1209"></a>
<pre>
Subgoal 4:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < <b>case H5.</b>
</pre>
<a name="1210"></a>
<pre>
Subgoal 4:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  H7 : {cval V}
  H8 : {cval VL}
  ============================
   {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < <b>search.</b>
</pre>
<a name="1211"></a>
<pre>
Subgoal 5:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < <b>intros.</b>
</pre>
<a name="1212"></a>
<pre>
Subgoal 5:

  Variables: V, VL, V'
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  H7 : {cml_member (cmap n1 (V' n1)) cml_nil}
  ============================
   V' n1 = VL

csubst_single_inv < <b>case H7.</b>
Proof completed.
</pre>
<a name="1213"></a>
<pre class="code">
Abella < <b>Define app_subst : smap_list -> tm -> tm -> prop by 
app_subst sml_nil M M;
nabla x, app_subst (sml_cons (smap x V) (ML x)) (R x) M := nabla x, app_subst (ML x) (R V) M.</b>
</pre>
<a name="1214"></a>
<pre class="code">
Abella < <b>Theorem subst_closed_tm' : 
forall M ML, {tm M} -> subst ML -> app_subst ML M M.</b>
</pre>
<a name="1215"></a>
<pre>


  ============================
   forall M ML, {tm M} -> subst ML -> app_subst ML M M

subst_closed_tm' < <b>induction on 2.</b>
</pre>
<a name="1216"></a>
<pre>


  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  ============================
   forall M ML, {tm M} -> subst ML @ -> app_subst ML M M

subst_closed_tm' < <b>intros.</b>
</pre>
<a name="1217"></a>
<pre>

  Variables: M, ML
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M}
  H2 : subst ML @
  ============================
   app_subst ML M M

subst_closed_tm' < <b>case H2.</b>
</pre>
<a name="1218"></a>
<pre>
Subgoal 1:

  Variables: M, ML
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M}
  ============================
   app_subst sml_nil M M

Subgoal 2 is:
 app_subst (sml_cons (smap X V) ML1) M M

subst_closed_tm' < <b>search.</b>
</pre>
<a name="1219"></a>
<pre>
Subgoal 2:

  Variables: M, ML, ML1, V, X
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M}
  H3 : subst ML1 *
  H4 : tname X
  H5 : {tm V}
  H6 : {val V}
  H7 : forall V', {sml_member (smap X V') ML1} -> V' = V
  ============================
   app_subst (sml_cons (smap X V) ML1) M M

subst_closed_tm' < <b>case H4.</b>
</pre>
<a name="1220"></a>
<pre>
Subgoal 2:

  Variables: M, ML, ML1, V, X
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm (M n1)}
  H3 : subst (ML1 n1) *
  H5 : {tm (V n1)}
  H6 : {val (V n1)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V n1
  ============================
   app_subst (sml_cons (smap n1 (V n1)) (ML1 n1)) (M n1) (M n1)

subst_closed_tm' < <b>apply closed_tm_prune to H1.</b>
</pre>
<a name="1221"></a>
<pre>
Subgoal 2:

  Variables: M, ML, ML1, V, X, M'
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M'}
  H3 : subst (ML1 n1) *
  H5 : {tm (V n1)}
  H6 : {val (V n1)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V n1
  ============================
   app_subst (sml_cons (smap n1 (V n1)) (ML1 n1)) M' M'

subst_closed_tm' < <b>apply closed_tm_prune to H5.</b>
</pre>
<a name="1222"></a>
<pre>
Subgoal 2:

  Variables: M, ML, ML1, V, X, M', M'1
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M'}
  H3 : subst (ML1 n1) *
  H5 : {tm M'1}
  H6 : {val M'1}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'1
  ============================
   app_subst (sml_cons (smap n1 M'1) (ML1 n1)) M' M'

subst_closed_tm' < <b>apply IH to H1 H3.</b>
</pre>
<a name="1223"></a>
<pre>
Subgoal 2:

  Variables: M, ML, ML1, V, X, M', M'1
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M'}
  H3 : subst (ML1 n1) *
  H5 : {tm M'1}
  H6 : {val M'1}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'1
  H8 : app_subst (ML1 n1) M' M'
  ============================
   app_subst (sml_cons (smap n1 M'1) (ML1 n1)) M' M'

subst_closed_tm' < <b>search.</b>
Proof completed.
</pre>
<a name="1224"></a>
<pre class="code">
Abella < <b>Theorem subst_closed_tm : 
forall M ML M', {tm M} -> app_subst ML M M' -> M = M'.</b>
</pre>
<a name="1225"></a>
<pre>


  ============================
   forall M ML M', {tm M} -> app_subst ML M M' -> M = M'

subst_closed_tm < <b>induction on 2.</b>
</pre>
<a name="1226"></a>
<pre>


  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  ============================
   forall M ML M', {tm M} -> app_subst ML M M' @ -> M = M'

subst_closed_tm < <b>intros.</b>
</pre>
<a name="1227"></a>
<pre>

  Variables: M, ML, M'
  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  H1 : {tm M}
  H2 : app_subst ML M M' @
  ============================
   M = M'

subst_closed_tm < <b>case H2.</b>
</pre>
<a name="1228"></a>
<pre>
Subgoal 1:

  Variables: M, ML, M'
  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  H1 : {tm M'}
  ============================
   M' = M'

Subgoal 2 is:
 M n1 = M1

subst_closed_tm < <b>search.</b>
</pre>
<a name="1229"></a>
<pre>
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V
  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  H1 : {tm (M n1)}
  H3 : app_subst (ML1 n1) (M V) M1 *
  ============================
   M n1 = M1

subst_closed_tm < <b>apply closed_tm_prune to H1.</b>
</pre>
<a name="1230"></a>
<pre>
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V, M'1
  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  H1 : {tm M'1}
  H3 : app_subst (ML1 n1) M'1 M1 *
  ============================
   M'1 = M1

subst_closed_tm < <b>apply IH to H1 H3.</b>
</pre>
<a name="1231"></a>
<pre>
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V, M'1
  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  H1 : {tm M1}
  H3 : app_subst (ML1 n1) M1 M1 *
  ============================
   M1 = M1

subst_closed_tm < <b>search.</b>
Proof completed.
</pre>
<a name="1232"></a>
<pre class="code">
Abella < <b>Theorem subst_var' : 
forall V ML X, subst ML -> {sml_member (smap X V) ML} -> app_subst ML X V.</b>
</pre>
<a name="1233"></a>
<pre>


  ============================
   forall V ML X, subst ML -> {sml_member (smap X V) ML} -> app_subst ML X V

subst_var' < <b>induction on 1.</b>
</pre>
<a name="1234"></a>
<pre>


  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  ============================
   forall V ML X, subst ML @ -> {sml_member (smap X V) ML} ->
     app_subst ML X V

subst_var' < <b>intros.</b>
</pre>
<a name="1235"></a>
<pre>

  Variables: V, ML, X
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H1 : subst ML @
  H2 : {sml_member (smap X V) ML}
  ============================
   app_subst ML X V

subst_var' < <b>case H1.</b>
</pre>
<a name="1236"></a>
<pre>
Subgoal 1:

  Variables: V, ML, X
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H2 : {sml_member (smap X V) sml_nil}
  ============================
   app_subst sml_nil X V

Subgoal 2 is:
 app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < <b>case H2.</b>
</pre>
<a name="1237"></a>
<pre>
Subgoal 2:

  Variables: V, ML, X, ML1, V1, X1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H2 : {sml_member (smap X V) (sml_cons (smap X1 V1) ML1)}
  H3 : subst ML1 *
  H4 : tname X1
  H5 : {tm V1}
  H6 : {val V1}
  H7 : forall V', {sml_member (smap X1 V') ML1} -> V' = V1
  ============================
   app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < <b>case H2.</b>
</pre>
<a name="1238"></a>
<pre>
Subgoal 2.1:

  Variables: V, ML, X, ML1, V1, X1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst ML1 *
  H4 : tname X1
  H5 : {tm V1}
  H6 : {val V1}
  H7 : forall V', {sml_member (smap X1 V') ML1} -> V' = V1
  ============================
   app_subst (sml_cons (smap X1 V1) ML1) X1 V1

Subgoal 2.2 is:
 app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < <b>case H4.</b>
</pre>
<a name="1239"></a>
<pre>
Subgoal 2.1:

  Variables: V, ML, X, ML1, V1, X1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm (V1 n1)}
  H6 : {val (V1 n1)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1 n1
  ============================
   app_subst (sml_cons (smap n1 (V1 n1)) (ML1 n1)) n1 (V1 n1)

Subgoal 2.2 is:
 app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < <b>apply subst_closed_tm' to H5 H3.</b>
</pre>
<a name="1240"></a>
<pre>
Subgoal 2.1:

  Variables: V, ML, X, ML1, V1, X1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm (V1 n1)}
  H6 : {val (V1 n1)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1 n1
  H8 : app_subst (ML1 n1) (V1 n1) (V1 n1)
  ============================
   app_subst (sml_cons (smap n1 (V1 n1)) (ML1 n1)) n1 (V1 n1)

Subgoal 2.2 is:
 app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < <b>apply closed_tm_prune to H5.</b>
</pre>
<a name="1241"></a>
<pre>
Subgoal 2.1:

  Variables: V, ML, X, ML1, V1, X1, M'
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : app_subst (ML1 n1) M' M'
  ============================
   app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'

Subgoal 2.2 is:
 app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < <b>search.</b>
</pre>
<a name="1242"></a>
<pre>
Subgoal 2.2:

  Variables: V, ML, X, ML1, V1, X1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst ML1 *
  H4 : tname X1
  H5 : {tm V1}
  H6 : {val V1}
  H7 : forall V', {sml_member (smap X1 V') ML1} -> V' = V1
  H8 : {sml_member (smap X V) ML1}
  ============================
   app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < <b>apply subst_mem to H3 H8.</b>
</pre>
<a name="1243"></a>
<pre>
Subgoal 2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst ML1 *
  H4 : tname X1
  H5 : {tm V1}
  H6 : {val V1}
  H7 : forall V', {sml_member (smap X1 V') ML1} -> V' = V1
  H8 : {sml_member (smap X2 V2) ML1}
  H9 : tname X2
  H10 : {val V2}
  H11 : {tm V2}
  ============================
   app_subst (sml_cons (smap X1 V1) ML1) X2 V2

subst_var' < <b>case H4.</b>
</pre>
<a name="1244"></a>
<pre>
Subgoal 2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm (V1 n1)}
  H6 : {val (V1 n1)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1 n1
  H8 : {sml_member (smap (X2 n1) (V2 n1)) (ML1 n1)}
  H9 : tname (X2 n1)
  H10 : {val (V2 n1)}
  H11 : {tm (V2 n1)}
  ============================
   app_subst (sml_cons (smap n1 (V1 n1)) (ML1 n1)) (X2 n1) (V2 n1)

subst_var' < <b>apply closed_tm_prune to H5.</b>
</pre>
<a name="1245"></a>
<pre>
Subgoal 2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M'
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap (X2 n1) (V2 n1)) (ML1 n1)}
  H9 : tname (X2 n1)
  H10 : {val (V2 n1)}
  H11 : {tm (V2 n1)}
  ============================
   app_subst (sml_cons (smap n1 M') (ML1 n1)) (X2 n1) (V2 n1)

subst_var' < <b>apply closed_tm_prune to H11.</b>
</pre>
<a name="1246"></a>
<pre>
Subgoal 2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap (X2 n1) M'1) (ML1 n1)}
  H9 : tname (X2 n1)
  H10 : {val M'1}
  H11 : {tm M'1}
  ============================
   app_subst (sml_cons (smap n1 M') (ML1 n1)) (X2 n1) M'1

subst_var' < <b>case H9.</b>
</pre>
<a name="1247"></a>
<pre>
Subgoal 2.2.1:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n2 n1) *
  H5 : {tm (M' n2)}
  H6 : {val (M' n2)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n2 n1)} -> V' = M' n2
  H8 : {sml_member (smap n2 (M'1 n2)) (ML1 n2 n1)}
  H10 : {val (M'1 n2)}
  H11 : {tm (M'1 n2)}
  ============================
   app_subst (sml_cons (smap n1 (M' n2)) (ML1 n2 n1)) n2 (M'1 n2)

Subgoal 2.2.2 is:
 app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'1

subst_var' < <b>apply closed_tm_prune to H11.</b>
</pre>
<a name="1248"></a>
<pre>
Subgoal 2.2.1:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1, M'2
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n2 n1) *
  H5 : {tm (M' n2)}
  H6 : {val (M' n2)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n2 n1)} -> V' = M' n2
  H8 : {sml_member (smap n2 M'2) (ML1 n2 n1)}
  H10 : {val M'2}
  H11 : {tm M'2}
  ============================
   app_subst (sml_cons (smap n1 (M' n2)) (ML1 n2 n1)) n2 M'2

Subgoal 2.2.2 is:
 app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'1

subst_var' < <b>apply IH to H3 H8.</b>
</pre>
<a name="1249"></a>
<pre>
Subgoal 2.2.1:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1, M'2
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n2 n1) *
  H5 : {tm (M' n2)}
  H6 : {val (M' n2)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n2 n1)} -> V' = M' n2
  H8 : {sml_member (smap n2 M'2) (ML1 n2 n1)}
  H10 : {val M'2}
  H11 : {tm M'2}
  H12 : app_subst (ML1 n2 n1) n2 M'2
  ============================
   app_subst (sml_cons (smap n1 (M' n2)) (ML1 n2 n1)) n2 M'2

Subgoal 2.2.2 is:
 app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'1

subst_var' < <b>search.</b>
</pre>
<a name="1250"></a>
<pre>
Subgoal 2.2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap n1 M'1) (ML1 n1)}
  H10 : {val M'1}
  H11 : {tm M'1}
  ============================
   app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'1

subst_var' < <b>apply H7 to H8.</b>
</pre>
<a name="1251"></a>
<pre>
Subgoal 2.2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap n1 M') (ML1 n1)}
  H10 : {val M'}
  H11 : {tm M'}
  ============================
   app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'

subst_var' < <b>unfold.</b>
</pre>
<a name="1252"></a>
<pre>
Subgoal 2.2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap n1 M') (ML1 n1)}
  H10 : {val M'}
  H11 : {tm M'}
  ============================
   nabla x, app_subst (ML1 x) M' M'

subst_var' < <b>intros.</b>
</pre>
<a name="1253"></a>
<pre>
Subgoal 2.2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap n1 M') (ML1 n1)}
  H10 : {val M'}
  H11 : {tm M'}
  ============================
   app_subst (ML1 n1) M' M'

subst_var' < <b>apply subst_closed_tm' to H5 H3.</b>
</pre>
<a name="1254"></a>
<pre>
Subgoal 2.2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap n1 M') (ML1 n1)}
  H10 : {val M'}
  H11 : {tm M'}
  H12 : app_subst (ML1 n1) M' M'
  ============================
   app_subst (ML1 n1) M' M'

subst_var' < <b>search.</b>
Proof completed.
</pre>
<a name="1255"></a>
<pre class="code">
Abella < <b>Theorem subst_det : 
forall ML M M' M'', subst ML -> app_subst ML M M' -> app_subst ML M M'' ->
  M' = M''.</b>
</pre>
<a name="1256"></a>
<pre>


  ============================
   forall ML M M' M'', subst ML -> app_subst ML M M' -> app_subst ML M M'' ->
     M' = M''

subst_det < <b>induction on 1.</b>
</pre>
<a name="1257"></a>
<pre>


  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  ============================
   forall ML M M' M'', subst ML @ -> app_subst ML M M' ->
     app_subst ML M M'' -> M' = M''

subst_det < <b>intros.</b>
</pre>
<a name="1258"></a>
<pre>

  Variables: ML, M, M', M''
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H1 : subst ML @
  H2 : app_subst ML M M'
  H3 : app_subst ML M M''
  ============================
   M' = M''

subst_det < <b>case H1.</b>
</pre>
<a name="1259"></a>
<pre>
Subgoal 1:

  Variables: ML, M, M', M''
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H2 : app_subst sml_nil M M'
  H3 : app_subst sml_nil M M''
  ============================
   M' = M''

Subgoal 2 is:
 M' = M''

subst_det < <b>case H2.</b>
</pre>
<a name="1260"></a>
<pre>
Subgoal 1:

  Variables: ML, M, M', M''
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H3 : app_subst sml_nil M' M''
  ============================
   M' = M''

Subgoal 2 is:
 M' = M''

subst_det < <b>case H3.</b>
</pre>
<a name="1261"></a>
<pre>
Subgoal 1:

  Variables: ML, M, M', M''
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  ============================
   M'' = M''

Subgoal 2 is:
 M' = M''

subst_det < <b>search.</b>
</pre>
<a name="1262"></a>
<pre>
Subgoal 2:

  Variables: ML, M, M', M'', ML1, V, X
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H2 : app_subst (sml_cons (smap X V) ML1) M M'
  H3 : app_subst (sml_cons (smap X V) ML1) M M''
  H4 : subst ML1 *
  H5 : tname X
  H6 : {tm V}
  H7 : {val V}
  H8 : forall V', {sml_member (smap X V') ML1} -> V' = V
  ============================
   M' = M''

subst_det < <b>case H2.</b>
</pre>
<a name="1263"></a>
<pre>
Subgoal 2:

  Variables: ML, M, M', M'', ML1, V, X, M1, V1
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H3 : app_subst (sml_cons (smap n1 V1) (ML1 n1)) (M n1) (M'' n1)
  H4 : subst (ML1 n1) *
  H5 : tname n1
  H6 : {tm V1}
  H7 : {val V1}
  H8 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1
  H9 : app_subst (ML1 n1) (M V1) M1
  ============================
   M1 = M'' n1

subst_det < <b>case H3.</b>
</pre>
<a name="1264"></a>
<pre>
Subgoal 2:

  Variables: ML, M, M', M'', ML1, V, X, M1, V1, M2
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H4 : subst (ML1 n1) *
  H5 : tname n1
  H6 : {tm V1}
  H7 : {val V1}
  H8 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1
  H9 : app_subst (ML1 n1) (M V1) M1
  H10 : app_subst (ML1 n1) (M V1) M2
  ============================
   M1 = M2

subst_det < <b>apply IH to H4 H9 H10.</b>
</pre>
<a name="1265"></a>
<pre>
Subgoal 2:

  Variables: ML, M, M', M'', ML1, V, X, M1, V1, M2
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H4 : subst (ML1 n1) *
  H5 : tname n1
  H6 : {tm V1}
  H7 : {val V1}
  H8 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1
  H9 : app_subst (ML1 n1) (M V1) M2
  H10 : app_subst (ML1 n1) (M V1) M2
  ============================
   M2 = M2

subst_det < <b>search.</b>
Proof completed.
</pre>
<a name="1266"></a>
<pre class="code">
Abella < <b>Theorem subst_var : 
forall V ML E X, subst ML -> {sml_member (smap X V) ML} ->
  app_subst ML X E -> E = V.</b>
</pre>
<a name="1267"></a>
<pre>


  ============================
   forall V ML E X, subst ML -> {sml_member (smap X V) ML} ->
     app_subst ML X E -> E = V

subst_var < <b>intros.</b>
</pre>
<a name="1268"></a>
<pre>

  Variables: V, ML, E, X
  H1 : subst ML
  H2 : {sml_member (smap X V) ML}
  H3 : app_subst ML X E
  ============================
   E = V

subst_var < <b>apply subst_var' to H1 H2.</b>
</pre>
<a name="1269"></a>
<pre>

  Variables: V, ML, E, X
  H1 : subst ML
  H2 : {sml_member (smap X V) ML}
  H3 : app_subst ML X E
  H4 : app_subst ML X V
  ============================
   E = V

subst_var < <b>apply subst_det to H1 H3 H4.</b>
</pre>
<a name="1270"></a>
<pre>

  Variables: V, ML, E, X
  H1 : subst ML
  H2 : {sml_member (smap X V) ML}
  H3 : app_subst ML X V
  H4 : app_subst ML X V
  ============================
   V = V

subst_var < <b>search.</b>
Proof completed.
</pre>
<a name="1271"></a>
<pre class="code">
Abella < <b>Theorem subst_abs : 
forall ML M E, app_subst ML (abs M) E -> (exists M', E = abs M' /\ (nabla x,
  app_subst ML (M x) (M' x))).</b>
</pre>
<a name="1272"></a>
<pre>


  ============================
   forall ML M E, app_subst ML (abs M) E -> (exists M', E = abs M' /\
     (nabla x, app_subst ML (M x) (M' x)))

subst_abs < <b>induction on 1.</b>
</pre>
<a name="1273"></a>
<pre>


  IH : forall ML M E, app_subst ML (abs M) E * -> (exists M', E = abs M' /\
         (nabla x, app_subst ML (M x) (M' x)))
  ============================
   forall ML M E, app_subst ML (abs M) E @ -> (exists M', E = abs M' /\
     (nabla x, app_subst ML (M x) (M' x)))

subst_abs < <b>intros.</b>
</pre>
<a name="1274"></a>
<pre>

  Variables: ML, M, E
  IH : forall ML M E, app_subst ML (abs M) E * -> (exists M', E = abs M' /\
         (nabla x, app_subst ML (M x) (M' x)))
  H1 : app_subst ML (abs M) E @
  ============================
   exists M', E = abs M' /\ (nabla x, app_subst ML (M x) (M' x))

subst_abs < <b>case H1.</b>
</pre>
<a name="1275"></a>
<pre>
Subgoal 1:

  Variables: ML, M, E
  IH : forall ML M E, app_subst ML (abs M) E * -> (exists M', E = abs M' /\
         (nabla x, app_subst ML (M x) (M' x)))
  ============================
   exists M', abs M = abs M' /\ (nabla x, app_subst sml_nil (M x) (M' x))

Subgoal 2 is:
 exists M', M1 = abs M' /\ (nabla x,
   app_subst (sml_cons (smap n1 V) (ML1 n1)) (M n1 x) (M' x))

subst_abs < <b>search.</b>
</pre>
<a name="1276"></a>
<pre>
Subgoal 2:

  Variables: ML, M, E, M1, ML1, V
  IH : forall ML M E, app_subst ML (abs M) E * -> (exists M', E = abs M' /\
         (nabla x, app_subst ML (M x) (M' x)))
  H2 : app_subst (ML1 n1) (abs (M V)) M1 *
  ============================
   exists M', M1 = abs M' /\ (nabla x,
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M n1 x) (M' x))

subst_abs < <b>apply IH to H2.</b>
</pre>
<a name="1277"></a>
<pre>
Subgoal 2:

  Variables: ML, M, E, M1, ML1, V, M', M2
  IH : forall ML M E, app_subst ML (abs M) E * -> (exists M', E = abs M' /\
         (nabla x, app_subst ML (M x) (M' x)))
  H2 : app_subst (ML1 n1) (abs (M V)) (abs M2) *
  H3 : app_subst (ML1 n1) (M V n2) (M2 n2)
  ============================
   exists M', abs M2 = abs M' /\ (nabla x,
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M n1 x) (M' x))

subst_abs < <b>search.</b>
Proof completed.
</pre>
<a name="1278"></a>
<pre class="code">
Abella < <b>Theorem subst_app : 
forall ML M1 M2 E, app_subst ML (app M1 M2) E -> (exists M1' M2',
  E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2').</b>
</pre>
<a name="1279"></a>
<pre>


  ============================
   forall ML M1 M2 E, app_subst ML (app M1 M2) E -> (exists M1' M2',
     E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')

subst_app < <b>induction on 1.</b>
</pre>
<a name="1280"></a>
<pre>


  IH : forall ML M1 M2 E, app_subst ML (app M1 M2) E * -> (exists M1' M2',
         E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')
  ============================
   forall ML M1 M2 E, app_subst ML (app M1 M2) E @ -> (exists M1' M2',
     E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')

subst_app < <b>intros.</b>
</pre>
<a name="1281"></a>
<pre>

  Variables: ML, M1, M2, E
  IH : forall ML M1 M2 E, app_subst ML (app M1 M2) E * -> (exists M1' M2',
         E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')
  H1 : app_subst ML (app M1 M2) E @
  ============================
   exists M1' M2', E = app M1' M2' /\ app_subst ML M1 M1' /\
     app_subst ML M2 M2'

subst_app < <b>case H1.</b>
</pre>
<a name="1282"></a>
<pre>
Subgoal 1:

  Variables: ML, M1, M2, E
  IH : forall ML M1 M2 E, app_subst ML (app M1 M2) E * -> (exists M1' M2',
         E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')
  ============================
   exists M1' M2', app M1 M2 = app M1' M2' /\ app_subst sml_nil M1 M1' /\
     app_subst sml_nil M2 M2'

Subgoal 2 is:
 exists M1' M2', M = app M1' M2' /\
   app_subst (sml_cons (smap n1 V) (ML1 n1)) (M1 n1) M1' /\
   app_subst (sml_cons (smap n1 V) (ML1 n1)) (M2 n1) M2'

subst_app < <b>search.</b>
</pre>
<a name="1283"></a>
<pre>
Subgoal 2:

  Variables: ML, M1, M2, E, M, ML1, V
  IH : forall ML M1 M2 E, app_subst ML (app M1 M2) E * -> (exists M1' M2',
         E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')
  H2 : app_subst (ML1 n1) (app (M1 V) (M2 V)) M *
  ============================
   exists M1' M2', M = app M1' M2' /\
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M1 n1) M1' /\
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M2 n1) M2'

subst_app < <b>apply IH to H2.</b>
</pre>
<a name="1284"></a>
<pre>
Subgoal 2:

  Variables: ML, M1, M2, E, M, ML1, V, M1', M2', M4, M3
  IH : forall ML M1 M2 E, app_subst ML (app M1 M2) E * -> (exists M1' M2',
         E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')
  H2 : app_subst (ML1 n1) (app (M1 V) (M2 V)) (app M3 M4) *
  H3 : app_subst (ML1 n1) (M1 V) M3
  H4 : app_subst (ML1 n1) (M2 V) M4
  ============================
   exists M1' M2', app M3 M4 = app M1' M2' /\
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M1 n1) M1' /\
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M2 n1) M2'

subst_app < <b>search.</b>
Proof completed.
</pre>
<a name="1285"></a>
<pre class="code">
Abella < <b>Theorem subst_result_closed_tm : 
forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
  member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
  app_subst ML M M' -> {tm M'}.</b>
</pre>
<a name="1286"></a>
<pre>


  ============================
   forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
     member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
     app_subst ML M M' -> {tm M'}

subst_result_closed_tm < <b>induction on 5.</b>
</pre>
<a name="1287"></a>
<pre>


  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  ============================
   forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
     member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
     app_subst ML M M' @ -> {tm M'}

subst_result_closed_tm < <b>intros.</b>
</pre>
<a name="1288"></a>
<pre>

  Variables: ML, L, M, M'
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst ML
  H2 : tmctx L
  H3 : {L |- tm M}
  H4 : forall X, member (tm X) L -> (exists V'1,
         {sml_member (smap X V'1) ML})
  H5 : app_subst ML M M' @
  ============================
   {tm M'}

subst_result_closed_tm < <b>case H5.</b>
</pre>
<a name="1289"></a>
<pre>
Subgoal 1:

  Variables: ML, L, M, M'
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst sml_nil
  H2 : tmctx L
  H3 : {L |- tm M'}
  H4 : forall X, member (tm X) L -> (exists V'1,
         {sml_member (smap X V'1) sml_nil})
  ============================
   {tm M'}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < <b>case H2.</b>
</pre>
<a name="1290"></a>
<pre>
Subgoal 1.1:

  Variables: ML, L, M, M'
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst sml_nil
  H3 : {tm M'}
  H4 : forall X, member (tm X) nil -> (exists V'1,
         {sml_member (smap X V'1) sml_nil})
  ============================
   {tm M'}

Subgoal 1.2 is:
 {tm (M' n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < <b>search.</b>
</pre>
<a name="1291"></a>
<pre>
Subgoal 1.2:

  Variables: ML, L, M, M', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst sml_nil
  H3 : {L1 n1, tm n1 |- tm (M' n1)}
  H4 : forall X, member (tm X) (tm n1 :: L1 n1) -> (exists V'1,
         {sml_member (smap X V'1) sml_nil})
  H6 : tmctx (L1 n1)
  ============================
   {tm (M' n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < <b>assert member (tm n1) (tm n1 :: L1 n1).</b>
</pre>
<a name="1292"></a>
<pre>
Subgoal 1.2:

  Variables: ML, L, M, M', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst sml_nil
  H3 : {L1 n1, tm n1 |- tm (M' n1)}
  H4 : forall X, member (tm X) (tm n1 :: L1 n1) -> (exists V'1,
         {sml_member (smap X V'1) sml_nil})
  H6 : tmctx (L1 n1)
  H7 : member (tm n1) (tm n1 :: L1 n1)
  ============================
   {tm (M' n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < <b>apply H4 to H7.</b>
</pre>
<a name="1293"></a>
<pre>
Subgoal 1.2:

  Variables: ML, L, M, M', L1, V'1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst sml_nil
  H3 : {L1 n1, tm n1 |- tm (M' n1)}
  H4 : forall X, member (tm X) (tm n1 :: L1 n1) -> (exists V'1,
         {sml_member (smap X V'1) sml_nil})
  H6 : tmctx (L1 n1)
  H7 : member (tm n1) (tm n1 :: L1 n1)
  H8 : {sml_member (smap n1 (V'1 n1)) sml_nil}
  ============================
   {tm (M' n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < <b>case H8.</b>
</pre>
<a name="1294"></a>
<pre>
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst (sml_cons (smap n1 V) (ML1 n1))
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  ============================
   {tm M1}

subst_result_closed_tm < <b>case H1.</b>
</pre>
<a name="1295"></a>
<pre>
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  ============================
   {tm M1}

subst_result_closed_tm < <b>apply tmctx_rst_exists to H2 with x = n1.</b>
</pre>
<a name="1296"></a>
<pre>
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L'
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) (L' n1)
  H13 : fresh_tmctx n1 (L' n1)
  ============================
   {tm M1}

subst_result_closed_tm < <b>case H13.</b>
</pre>
<a name="1297"></a>
<pre>
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  ============================
   {tm M1}

subst_result_closed_tm < <b>apply tm_cut to H2 H3 H12 H9.</b>
</pre>
<a name="1298"></a>
<pre>
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  ============================
   {tm M1}

subst_result_closed_tm < <b>assert forall X, member (tm X) L1 -> (exists V, {sml_member (smap X V) (ML1 n1)}).</b>
</pre>
<a name="1299"></a>
<pre>
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  ============================
   forall X, member (tm X) L1 -> (exists V1,
     {sml_member (smap X V1) (ML1 n1)})

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < <b>intros.</b>
</pre>
<a name="1300"></a>
<pre>
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1, X
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : member (tm (X n1)) L1
  ============================
   exists V1, {sml_member (smap (X n1) V1) (ML1 n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < <b>apply tmctx_rst_mem_inv to H12 H15.</b>
</pre>
<a name="1301"></a>
<pre>
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1, X
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : member (tm (X n1)) L1
  H16 : member (tm (X n1)) (L n1)
  ============================
   exists V1, {sml_member (smap (X n1) V1) (ML1 n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < <b>apply member_prune_tm to H15.</b>
</pre>
<a name="1302"></a>
<pre>
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1, X, M'1, M'2
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : member (tm M'2) L1
  H16 : member (tm M'2) (L n1)
  ============================
   exists V1, {sml_member (smap M'2 V1) (ML1 n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < <b>apply H4 to H16.</b>
</pre>
<a name="1303"></a>
<pre>
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1, X, M'1, M'2, V'1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : member (tm M'2) L1
  H16 : member (tm M'2) (L n1)
  H17 : {sml_member (smap M'2 (V'1 n1)) (sml_cons (smap n1 V) (ML1 n1))}
  ============================
   exists V1, {sml_member (smap M'2 V1) (ML1 n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < <b>case H17.</b>
</pre>
<a name="1304"></a>
<pre>
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1, X, M'1, M'2, V'1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : member (tm M'2) L1
  H16 : member (tm M'2) (L n1)
  H18 : {sml_member (smap M'2 (V'1 n1)) (ML1 n1)}
  ============================
   exists V1, {sml_member (smap M'2 V1) (ML1 n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < <b>search.</b>
</pre>
<a name="1305"></a>
<pre>
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : forall X, member (tm X) L1 -> (exists V1,
          {sml_member (smap X V1) (ML1 n1)})
  ============================
   {tm M1}

subst_result_closed_tm < <b>apply tmctx_rst_pres to H2 H12.</b>
</pre>
<a name="1306"></a>
<pre>
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : forall X, member (tm X) L1 -> (exists V1,
          {sml_member (smap X V1) (ML1 n1)})
  H16 : tmctx L1
  ============================
   {tm M1}

subst_result_closed_tm < <b>apply IH to H7 H16 H14 H15 H6.</b>
</pre>
<a name="1307"></a>
<pre>
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : forall X, member (tm X) L1 -> (exists V1,
          {sml_member (smap X V1) (ML1 n1)})
  H16 : tmctx L1
  H17 : {tm M1}
  ============================
   {tm M1}

subst_result_closed_tm < <b>search.</b>
Proof completed.
</pre>
<a name="1308"></a>
<pre class="code">
Abella < <b>Theorem subst_inst : 
forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) ->
  app_subst ML (M V) (M' V).</b>
</pre>
<a name="1309"></a>
<pre>


  ============================
   forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) ->
     app_subst ML (M V) (M' V)

subst_inst < <b>induction on 2.</b>
</pre>
<a name="1310"></a>
<pre>


  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  ============================
   forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) @ ->
     app_subst ML (M V) (M' V)

subst_inst < <b>intros.</b>
</pre>
<a name="1311"></a>
<pre>

  Variables: ML, M, M', V
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm V}
  H2 : app_subst ML (M n1) (M' n1) @
  ============================
   app_subst ML (M V) (M' V)

subst_inst < <b>case H2.</b>
</pre>
<a name="1312"></a>
<pre>
Subgoal 1:

  Variables: ML, M, M', V
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm V}
  ============================
   app_subst sml_nil (M' V) (M' V)

Subgoal 2 is:
 app_subst (sml_cons (smap n2 ML2) (ML3 n2)) (M n2 (V n2)) (M2 (V n2))

subst_inst < <b>search.</b>
</pre>
<a name="1313"></a>
<pre>
Subgoal 2:

  Variables: ML, M, M', V, M2, ML3, ML2
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm (V n2)}
  H3 : app_subst (ML3 n2) (M ML2 n1) (M2 n1) *
  ============================
   app_subst (sml_cons (smap n2 ML2) (ML3 n2)) (M n2 (V n2)) (M2 (V n2))

subst_inst < <b>apply closed_tm_prune to H1.</b>
</pre>
<a name="1314"></a>
<pre>
Subgoal 2:

  Variables: ML, M, M', V, M2, ML3, ML2, M'1
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm M'1}
  H3 : app_subst (ML3 n2) (M ML2 n1) (M2 n1) *
  ============================
   app_subst (sml_cons (smap n2 ML2) (ML3 n2)) (M n2 M'1) (M2 M'1)

subst_inst < <b>unfold.</b>
</pre>
<a name="1315"></a>
<pre>
Subgoal 2:

  Variables: ML, M, M', V, M2, ML3, ML2, M'1
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm M'1}
  H3 : app_subst (ML3 n2) (M ML2 n1) (M2 n1) *
  ============================
   nabla x, app_subst (ML3 x) (M ML2 M'1) (M2 M'1)

subst_inst < <b>intros.</b>
</pre>
<a name="1316"></a>
<pre>
Subgoal 2:

  Variables: ML, M, M', V, M2, ML3, ML2, M'1
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm M'1}
  H3 : app_subst (ML3 n2) (M ML2 n1) (M2 n1) *
  ============================
   app_subst (ML3 n1) (M ML2 M'1) (M2 M'1)

subst_inst < <b>apply IH to H1 H3.</b>
</pre>
<a name="1317"></a>
<pre>
Subgoal 2:

  Variables: ML, M, M', V, M2, ML3, ML2, M'1
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm M'1}
  H3 : app_subst (ML3 n2) (M ML2 n1) (M2 n1) *
  H4 : app_subst (ML3 n2) (M ML2 M'1) (M2 M'1)
  ============================
   app_subst (ML3 n1) (M ML2 M'1) (M2 M'1)

subst_inst < <b>search.</b>
Proof completed.
</pre>
<a name="1318"></a>
<pre class="code">
Abella < <b>Define app_csubst : cmap_list -> ctm -> ctm -> prop by 
app_csubst cml_nil M M;
nabla x, app_csubst (cml_cons (cmap x V) (ML x)) (R x) M := nabla x, app_csubst (ML x) (R V) M.</b>
</pre>
<a name="1319"></a>
<pre class="code">
Abella < <b>Theorem csubst_closed_ctm : 
forall M ML M', {ctm M} -> app_csubst ML M M' -> M = M'.</b>
</pre>
<a name="1320"></a>
<pre>


  ============================
   forall M ML M', {ctm M} -> app_csubst ML M M' -> M = M'

csubst_closed_ctm < <b>induction on 2.</b>
</pre>
<a name="1321"></a>
<pre>


  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  ============================
   forall M ML M', {ctm M} -> app_csubst ML M M' @ -> M = M'

csubst_closed_ctm < <b>intros.</b>
</pre>
<a name="1322"></a>
<pre>

  Variables: M, ML, M'
  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  H1 : {ctm M}
  H2 : app_csubst ML M M' @
  ============================
   M = M'

csubst_closed_ctm < <b>case H2.</b>
</pre>
<a name="1323"></a>
<pre>
Subgoal 1:

  Variables: M, ML, M'
  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  H1 : {ctm M'}
  ============================
   M' = M'

Subgoal 2 is:
 M n1 = M1

csubst_closed_ctm < <b>search.</b>
</pre>
<a name="1324"></a>
<pre>
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V
  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  H1 : {ctm (M n1)}
  H3 : app_csubst (ML1 n1) (M V) M1 *
  ============================
   M n1 = M1

csubst_closed_ctm < <b>apply closed_ctm_prune to H1.</b>
</pre>
<a name="1325"></a>
<pre>
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V, M'1
  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  H1 : {ctm M'1}
  H3 : app_csubst (ML1 n1) M'1 M1 *
  ============================
   M'1 = M1

csubst_closed_ctm < <b>apply IH to H1 H3.</b>
</pre>
<a name="1326"></a>
<pre>
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V, M'1
  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  H1 : {ctm M1}
  H3 : app_csubst (ML1 n1) M1 M1 *
  ============================
   M1 = M1

csubst_closed_ctm < <b>search.</b>
Proof completed.
</pre>
<a name="1327"></a>
<pre class="code">
Abella < <b>Theorem csubst_var : 
forall V ML E X, csubst ML -> {cml_member (cmap X V) ML} ->
  app_csubst ML X E -> E = V.</b>
</pre>
<a name="1328"></a>
<pre>


  ============================
   forall V ML E X, csubst ML -> {cml_member (cmap X V) ML} ->
     app_csubst ML X E -> E = V

csubst_var < <b>induction on 1.</b>
</pre>
<a name="1329"></a>
<pre>


  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  ============================
   forall V ML E X, csubst ML @ -> {cml_member (cmap X V) ML} ->
     app_csubst ML X E -> E = V

csubst_var < <b>intros.</b>
</pre>
<a name="1330"></a>
<pre>

  Variables: V, ML, E, X
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H1 : csubst ML @
  H2 : {cml_member (cmap X V) ML}
  H3 : app_csubst ML X E
  ============================
   E = V

csubst_var < <b>case H1.</b>
</pre>
<a name="1331"></a>
<pre>
Subgoal 1:

  Variables: V, ML, E, X
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H2 : {cml_member (cmap X V) cml_nil}
  H3 : app_csubst cml_nil X E
  ============================
   E = V

Subgoal 2 is:
 E = V

csubst_var < <b>case H2.</b>
</pre>
<a name="1332"></a>
<pre>
Subgoal 2:

  Variables: V, ML, E, X, ML1, V1, X1
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H2 : {cml_member (cmap X V) (cml_cons (cmap X1 V1) ML1)}
  H3 : app_csubst (cml_cons (cmap X1 V1) ML1) X E
  H4 : csubst ML1 *
  H5 : ctname X1
  H6 : {ctm V1}
  H7 : {cval V1}
  H8 : forall V', {cml_member (cmap X1 V') ML1} -> V' = V1
  ============================
   E = V

csubst_var < <b>case H2.</b>
</pre>
<a name="1333"></a>
<pre>
Subgoal 2.1:

  Variables: V, ML, E, X, ML1, V1, X1
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H3 : app_csubst (cml_cons (cmap X1 V1) ML1) X1 E
  H4 : csubst ML1 *
  H5 : ctname X1
  H6 : {ctm V1}
  H7 : {cval V1}
  H8 : forall V', {cml_member (cmap X1 V') ML1} -> V' = V1
  ============================
   E = V1

Subgoal 2.2 is:
 E = V

csubst_var < <b>case H3.</b>
</pre>
<a name="1334"></a>
<pre>
Subgoal 2.1:

  Variables: V, ML, E, X, ML1, V1, X1, M, V2
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm V2}
  H7 : {cval V2}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = V2
  H9 : app_csubst (ML1 n1) V2 M
  ============================
   M = V2

Subgoal 2.2 is:
 E = V

csubst_var < <b>apply csubst_closed_ctm to H6 H9.</b>
</pre>
<a name="1335"></a>
<pre>
Subgoal 2.1:

  Variables: V, ML, E, X, ML1, V1, X1, M, V2
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm M}
  H7 : {cval M}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = M
  H9 : app_csubst (ML1 n1) M M
  ============================
   M = M

Subgoal 2.2 is:
 E = V

csubst_var < <b>search.</b>
</pre>
<a name="1336"></a>
<pre>
Subgoal 2.2:

  Variables: V, ML, E, X, ML1, V1, X1
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H3 : app_csubst (cml_cons (cmap X1 V1) ML1) X E
  H4 : csubst ML1 *
  H5 : ctname X1
  H6 : {ctm V1}
  H7 : {cval V1}
  H8 : forall V', {cml_member (cmap X1 V') ML1} -> V' = V1
  H9 : {cml_member (cmap X V) ML1}
  ============================
   E = V

csubst_var < <b>apply csubst_mem to H4 H9.</b>
</pre>
<a name="1337"></a>
<pre>
Subgoal 2.2:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H3 : app_csubst (cml_cons (cmap X1 V1) ML1) X2 E
  H4 : csubst ML1 *
  H5 : ctname X1
  H6 : {ctm V1}
  H7 : {cval V1}
  H8 : forall V', {cml_member (cmap X1 V') ML1} -> V' = V1
  H9 : {cml_member (cmap X2 V2) ML1}
  H10 : ctname X2
  H11 : {cval V2}
  H12 : {ctm V2}
  ============================
   E = V2

csubst_var < <b>case H3.</b>
</pre>
<a name="1338"></a>
<pre>
Subgoal 2.2:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm V3}
  H7 : {cval V3}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = V3
  H9 : {cml_member (cmap (X2 n1) (V2 n1)) (ML1 n1)}
  H10 : ctname (X2 n1)
  H11 : {cval (V2 n1)}
  H12 : {ctm (V2 n1)}
  H13 : app_csubst (ML1 n1) (X2 V3) M
  ============================
   M = V2 n1

csubst_var < <b>case H10.</b>
</pre>
<a name="1339"></a>
<pre>
Subgoal 2.2.1:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n2 n1) *
  H5 : ctname n1
  H6 : {ctm (V3 n2)}
  H7 : {cval (V3 n2)}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n2 n1)} -> V' = V3 n2
  H9 : {cml_member (cmap n2 (V2 n2 n1)) (ML1 n2 n1)}
  H11 : {cval (V2 n2 n1)}
  H12 : {ctm (V2 n2 n1)}
  H13 : app_csubst (ML1 n2 n1) n2 (M n2)
  ============================
   M n2 = V2 n2 n1

Subgoal 2.2.2 is:
 M = V2 n1

csubst_var < <b>apply IH to H4 H9 H13.</b>
</pre>
<a name="1340"></a>
<pre>
Subgoal 2.2.1:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3, M1
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n2 n1) *
  H5 : ctname n1
  H6 : {ctm (V3 n2)}
  H7 : {cval (V3 n2)}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n2 n1)} -> V' = V3 n2
  H9 : {cml_member (cmap n2 (M1 n2)) (ML1 n2 n1)}
  H11 : {cval (M1 n2)}
  H12 : {ctm (M1 n2)}
  H13 : app_csubst (ML1 n2 n1) n2 (M1 n2)
  ============================
   M1 n2 = M1 n2

Subgoal 2.2.2 is:
 M = V2 n1

csubst_var < <b>search.</b>
</pre>
<a name="1341"></a>
<pre>
Subgoal 2.2.2:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm V3}
  H7 : {cval V3}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = V3
  H9 : {cml_member (cmap n1 (V2 n1)) (ML1 n1)}
  H11 : {cval (V2 n1)}
  H12 : {ctm (V2 n1)}
  H13 : app_csubst (ML1 n1) V3 M
  ============================
   M = V2 n1

csubst_var < <b>apply csubst_closed_ctm to H6 H13.</b>
</pre>
<a name="1342"></a>
<pre>
Subgoal 2.2.2:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm M}
  H7 : {cval M}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = M
  H9 : {cml_member (cmap n1 (V2 n1)) (ML1 n1)}
  H11 : {cval (V2 n1)}
  H12 : {ctm (V2 n1)}
  H13 : app_csubst (ML1 n1) M M
  ============================
   M = V2 n1

csubst_var < <b>apply H8 to H9.</b>
</pre>
<a name="1343"></a>
<pre>
Subgoal 2.2.2:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm M}
  H7 : {cval M}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = M
  H9 : {cml_member (cmap n1 M) (ML1 n1)}
  H11 : {cval M}
  H12 : {ctm M}
  H13 : app_csubst (ML1 n1) M M
  ============================
   M = M

csubst_var < <b>search.</b>
Proof completed.
</pre>
<a name="1344"></a>
<pre class="code">
Abella < <b>Theorem csubst_cpair : 
forall F ML M E, app_csubst ML (cpair F M) E -> (exists M' F',
  E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M').</b>
</pre>
<a name="1345"></a>
<pre>


  ============================
   forall F ML M E, app_csubst ML (cpair F M) E -> (exists M' F',
     E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')

csubst_cpair < <b>induction on 1.</b>
</pre>
<a name="1346"></a>
<pre>


  IH : forall F ML M E, app_csubst ML (cpair F M) E * -> (exists M' F',
         E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')
  ============================
   forall F ML M E, app_csubst ML (cpair F M) E @ -> (exists M' F',
     E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')

csubst_cpair < <b>intros.</b>
</pre>
<a name="1347"></a>
<pre>

  Variables: F, ML, M, E
  IH : forall F ML M E, app_csubst ML (cpair F M) E * -> (exists M' F',
         E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')
  H1 : app_csubst ML (cpair F M) E @
  ============================
   exists M' F', E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M'

csubst_cpair < <b>case H1.</b>
</pre>
<a name="1348"></a>
<pre>
Subgoal 1:

  Variables: F, ML, M, E
  IH : forall F ML M E, app_csubst ML (cpair F M) E * -> (exists M' F',
         E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')
  ============================
   exists M' F', cpair F M = cpair F' M' /\ app_csubst cml_nil F F' /\
     app_csubst cml_nil M M'

Subgoal 2 is:
 exists M' F', M1 = cpair F' M' /\
   app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (F n1) F' /\
   app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (M n1) M'

csubst_cpair < <b>search.</b>
</pre>
<a name="1349"></a>
<pre>
Subgoal 2:

  Variables: F, ML, M, E, M1, ML1, V
  IH : forall F ML M E, app_csubst ML (cpair F M) E * -> (exists M' F',
         E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')
  H2 : app_csubst (ML1 n1) (cpair (F V) (M V)) M1 *
  ============================
   exists M' F', M1 = cpair F' M' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (F n1) F' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (M n1) M'

csubst_cpair < <b>apply IH to H2.</b>
</pre>
<a name="1350"></a>
<pre>
Subgoal 2:

  Variables: F, ML, M, E, M1, ML1, V, M', F', M3, M2
  IH : forall F ML M E, app_csubst ML (cpair F M) E * -> (exists M' F',
         E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')
  H2 : app_csubst (ML1 n1) (cpair (F V) (M V)) (cpair M2 M3) *
  H3 : app_csubst (ML1 n1) (F V) M2
  H4 : app_csubst (ML1 n1) (M V) M3
  ============================
   exists M' F', cpair M2 M3 = cpair F' M' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (F n1) F' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (M n1) M'

csubst_cpair < <b>search.</b>
Proof completed.
</pre>
<a name="1351"></a>
<pre class="code">
Abella < <b>Theorem csubst_cunpair : 
forall ML CM1 CM2 E,
  app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E ->
  (exists CM1' CM2', E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
  app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2').</b>
</pre>
<a name="1352"></a>
<pre>


  ============================
   forall ML CM1 CM2 E,
     app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E ->
     (exists CM1' CM2', E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')

csubst_cunpair < <b>induction on 1.</b>
</pre>
<a name="1353"></a>
<pre>


  IH : forall ML CM1 CM2 E,
         app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E * ->
         (exists CM1' CM2',
         E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
         app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')
  ============================
   forall ML CM1 CM2 E,
     app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E @ ->
     (exists CM1' CM2', E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')

csubst_cunpair < <b>intros.</b>
</pre>
<a name="1354"></a>
<pre>

  Variables: ML, CM1, CM2, E
  IH : forall ML CM1 CM2 E,
         app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E * ->
         (exists CM1' CM2',
         E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
         app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')
  H1 : app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E @
  ============================
   exists CM1' CM2', E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2'

csubst_cunpair < <b>case H1.</b>
</pre>
<a name="1355"></a>
<pre>
Subgoal 1:

  Variables: ML, CM1, CM2, E
  IH : forall ML CM1 CM2 E,
         app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E * ->
         (exists CM1' CM2',
         E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
         app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')
  ============================
   exists CM1' CM2',
     cunpair CM1 (f\env\capp f (cross CM2 env)) = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst cml_nil CM1 CM1' /\ app_csubst cml_nil CM2 CM2'

Subgoal 2 is:
 exists CM1' CM2', M = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
   app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM1 n1) CM1' /\
   app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM2 n1) CM2'

csubst_cunpair < <b>search.</b>
</pre>
<a name="1356"></a>
<pre>
Subgoal 2:

  Variables: ML, CM1, CM2, E, M, ML1, V
  IH : forall ML CM1 CM2 E,
         app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E * ->
         (exists CM1' CM2',
         E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
         app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')
  H2 : app_csubst (ML1 n1) (cunpair (CM1 V) (f\env\capp f (cross (CM2 V) env))) M *
  ============================
   exists CM1' CM2', M = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM1 n1) CM1' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM2 n1) CM2'

csubst_cunpair < <b>apply IH to H2.</b>
</pre>
<a name="1357"></a>
<pre>
Subgoal 2:

  Variables: ML, CM1, CM2, E, M, ML1, V, CM1', CM2', M2, M1
  IH : forall ML CM1 CM2 E,
         app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E * ->
         (exists CM1' CM2',
         E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
         app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')
  H2 : app_csubst (ML1 n1) (cunpair (CM1 V) (f\env\capp f (cross (CM2 V) env))) (cunpair M1 (f\env\capp f (cross M2 env))) *
  H3 : app_csubst (ML1 n1) (CM1 V) M1
  H4 : app_csubst (ML1 n1) (CM2 V) M2
  ============================
   exists CM1' CM2',
     cunpair M1 (f\env\capp f (cross M2 env)) = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM1 n1) CM1' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM2 n1) CM2'

csubst_cunpair < <b>search.</b>
Proof completed.
</pre>
<a name="1358"></a>
<pre class="code">
Abella < <b>Define subst_equiv : olist -> smap_list -> ctm -> prop by 
subst_equiv nil ML unit;
subst_equiv (of X T :: L) ML (cross V' VL') := exists V, subst_equiv L ML VL' /\ {sml_member (smap X V) ML} /\ equiv T V V'.</b>
</pre>
<a name="1359"></a>
<pre class="code">
Abella < <b>Define subst_equiv' : olist -> smap_list -> cmap_list -> prop by 
nabla x y xenv, subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) := equiv T V V' /\ subst_equiv L ML Venv.</b>
</pre>
<a name="1360"></a>
<pre class="code">
Abella < <b>Theorem subst_equiv_cval : 
forall T ML VE, subst_equiv T ML VE -> {cval VE}.</b>
</pre>
<a name="1361"></a>
<pre>


  ============================
   forall T ML VE, subst_equiv T ML VE -> {cval VE}

subst_equiv_cval < <b>induction on 1.</b>
</pre>
<a name="1362"></a>
<pre>


  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  ============================
   forall T ML VE, subst_equiv T ML VE @ -> {cval VE}

subst_equiv_cval < <b>intros.</b>
</pre>
<a name="1363"></a>
<pre>

  Variables: T, ML, VE
  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  H1 : subst_equiv T ML VE @
  ============================
   {cval VE}

subst_equiv_cval < <b>case H1.</b>
</pre>
<a name="1364"></a>
<pre>
Subgoal 1:

  Variables: T, ML, VE
  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  ============================
   {cval unit}

Subgoal 2 is:
 {cval (cross V' VL')}

subst_equiv_cval < <b>search.</b>
</pre>
<a name="1365"></a>
<pre>
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  ============================
   {cval (cross V' VL')}

subst_equiv_cval < <b>apply equiv_cval to H4.</b>
</pre>
<a name="1366"></a>
<pre>
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  H5 : {cval V'}
  ============================
   {cval (cross V' VL')}

subst_equiv_cval < <b>apply IH to H2.</b>
</pre>
<a name="1367"></a>
<pre>
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  H5 : {cval V'}
  H6 : {cval VL'}
  ============================
   {cval (cross V' VL')}

subst_equiv_cval < <b>search.</b>
Proof completed.
</pre>
<a name="1368"></a>
<pre class="code">
Abella < <b>Theorem subst_equiv_closed_ctm : 
forall T ML VE, subst_equiv T ML VE -> {ctm VE}.</b>
</pre>
<a name="1369"></a>
<pre>


  ============================
   forall T ML VE, subst_equiv T ML VE -> {ctm VE}

subst_equiv_closed_ctm < <b>induction on 1.</b>
</pre>
<a name="1370"></a>
<pre>


  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  ============================
   forall T ML VE, subst_equiv T ML VE @ -> {ctm VE}

subst_equiv_closed_ctm < <b>intros.</b>
</pre>
<a name="1371"></a>
<pre>

  Variables: T, ML, VE
  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  H1 : subst_equiv T ML VE @
  ============================
   {ctm VE}

subst_equiv_closed_ctm < <b>case H1.</b>
</pre>
<a name="1372"></a>
<pre>
Subgoal 1:

  Variables: T, ML, VE
  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  ============================
   {ctm unit}

Subgoal 2 is:
 {ctm (cross V' VL')}

subst_equiv_closed_ctm < <b>search.</b>
</pre>
<a name="1373"></a>
<pre>
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  ============================
   {ctm (cross V' VL')}

subst_equiv_closed_ctm < <b>apply equiv_closed_ctm to H4.</b>
</pre>
<a name="1374"></a>
<pre>
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  H5 : {ctm V'}
  ============================
   {ctm (cross V' VL')}

subst_equiv_closed_ctm < <b>apply IH to H2.</b>
</pre>
<a name="1375"></a>
<pre>
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  H5 : {ctm V'}
  H6 : {ctm VL'}
  ============================
   {ctm (cross V' VL')}

subst_equiv_closed_ctm < <b>search.</b>
Proof completed.
</pre>
<a name="1376"></a>
<pre class="code">
Abella < <b>Theorem subst_equiv_mem : 
forall ML X L VE T, subst_equiv L ML VE -> member (of X T) L -> (exists V,
  {sml_member (smap X V) ML}).</b>
</pre>
<a name="1377"></a>
<pre>


  ============================
   forall ML X L VE T, subst_equiv L ML VE -> member (of X T) L -> (exists V,
     {sml_member (smap X V) ML})

subst_equiv_mem < <b>induction on 1.</b>
</pre>
<a name="1378"></a>
<pre>


  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  ============================
   forall ML X L VE T, subst_equiv L ML VE @ -> member (of X T) L ->
     (exists V, {sml_member (smap X V) ML})

subst_equiv_mem < <b>intros.</b>
</pre>
<a name="1379"></a>
<pre>

  Variables: ML, X, L, VE, T
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H1 : subst_equiv L ML VE @
  H2 : member (of X T) L
  ============================
   exists V, {sml_member (smap X V) ML}

subst_equiv_mem < <b>case H1.</b>
</pre>
<a name="1380"></a>
<pre>
Subgoal 1:

  Variables: ML, X, L, VE, T
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H2 : member (of X T) nil
  ============================
   exists V, {sml_member (smap X V) ML}

Subgoal 2 is:
 exists V, {sml_member (smap X V) ML}

subst_equiv_mem < <b>case H2.</b>
</pre>
<a name="1381"></a>
<pre>
Subgoal 2:

  Variables: ML, X, L, VE, T, V, VL', V', L1, T1, X1
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H2 : member (of X T) (of X1 T1 :: L1)
  H3 : subst_equiv L1 ML VL' *
  H4 : {sml_member (smap X1 V) ML}
  H5 : equiv T1 V V'
  ============================
   exists V, {sml_member (smap X V) ML}

subst_equiv_mem < <b>case H2.</b>
</pre>
<a name="1382"></a>
<pre>
Subgoal 2.1:

  Variables: ML, X, L, VE, T, V, VL', V', L1, T1, X1
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H3 : subst_equiv L1 ML VL' *
  H4 : {sml_member (smap X1 V) ML}
  H5 : equiv T1 V V'
  ============================
   exists V, {sml_member (smap X1 V) ML}

Subgoal 2.2 is:
 exists V, {sml_member (smap X V) ML}

subst_equiv_mem < <b>search.</b>
</pre>
<a name="1383"></a>
<pre>
Subgoal 2.2:

  Variables: ML, X, L, VE, T, V, VL', V', L1, T1, X1
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H3 : subst_equiv L1 ML VL' *
  H4 : {sml_member (smap X1 V) ML}
  H5 : equiv T1 V V'
  H6 : member (of X T) L1
  ============================
   exists V, {sml_member (smap X V) ML}

subst_equiv_mem < <b>apply IH to H3 H6.</b>
</pre>
<a name="1384"></a>
<pre>
Subgoal 2.2:

  Variables: ML, X, L, VE, T, V, VL', V', L1, T1, X1, V1
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H3 : subst_equiv L1 ML VL' *
  H4 : {sml_member (smap X1 V) ML}
  H5 : equiv T1 V V'
  H6 : member (of X T) L1
  H7 : {sml_member (smap X V1) ML}
  ============================
   exists V, {sml_member (smap X V) ML}

subst_equiv_mem < <b>search.</b>
Proof completed.
</pre>
<a name="1385"></a>
<pre class="code">
Abella < <b>Theorem subst_equiv'_mem : 
forall ML X L VE T, subst_equiv' L ML VE -> member (of X T) L -> (exists V,
  {sml_member (smap X V) ML}).</b>
</pre>
<a name="1386"></a>
<pre>


  ============================
   forall ML X L VE T, subst_equiv' L ML VE -> member (of X T) L ->
     (exists V, {sml_member (smap X V) ML})

subst_equiv'_mem < <b>intros.</b>
</pre>
<a name="1387"></a>
<pre>

  Variables: ML, X, L, VE, T
  H1 : subst_equiv' L ML VE
  H2 : member (of X T) L
  ============================
   exists V, {sml_member (smap X V) ML}

subst_equiv'_mem < <b>case H1.</b>
</pre>
<a name="1388"></a>
<pre>

  Variables: ML, X, L, VE, T, Venv, V', ML1, V, L1, T1
  H2 : member (of (X n1) T) (of n1 T1 :: L1)
  H3 : equiv T1 V V'
  H4 : subst_equiv L1 ML1 Venv
  ============================
   exists V1, {sml_member (smap (X n1) V1) (sml_cons (smap n1 V) ML1)}

subst_equiv'_mem < <b>case H2.</b>
</pre>
<a name="1389"></a>
<pre>
Subgoal 1:

  Variables: ML, X, L, VE, T, Venv, V', ML1, V, L1, T1
  H3 : equiv T1 V V'
  H4 : subst_equiv L1 ML1 Venv
  ============================
   exists V1, {sml_member (smap n1 V1) (sml_cons (smap n1 V) ML1)}

Subgoal 2 is:
 exists V1, {sml_member (smap (X n1) V1) (sml_cons (smap n1 V) ML1)}

subst_equiv'_mem < <b>search.</b>
</pre>
<a name="1390"></a>
<pre>
Subgoal 2:

  Variables: ML, X, L, VE, T, Venv, V', ML1, V, L1, T1
  H3 : equiv T1 V V'
  H4 : subst_equiv L1 ML1 Venv
  H5 : member (of (X n1) T) L1
  ============================
   exists V1, {sml_member (smap (X n1) V1) (sml_cons (smap n1 V) ML1)}

subst_equiv'_mem < <b>apply subst_equiv_mem to H4 H5.</b>
</pre>
<a name="1391"></a>
<pre>
Subgoal 2:

  Variables: ML, X, L, VE, T, Venv, V', ML1, V, L1, T1, V1
  H3 : equiv T1 V V'
  H4 : subst_equiv L1 ML1 Venv
  H5 : member (of (X n1) T) L1
  H6 : {sml_member (smap (X n1) (V1 n1)) ML1}
  ============================
   exists V1, {sml_member (smap (X n1) V1) (sml_cons (smap n1 V) ML1)}

subst_equiv'_mem < <b>search.</b>
Proof completed.
</pre>
<a name="1392"></a>
<pre class="code">
Abella < <b>Theorem env_eval_pres : 
forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
  csubst (cml_cons (cmap xenv Venv) cml_nil) -> subst_equiv L ML Venv ->
  vars_of_sctx L FVs -> {mapvar FVs Map} -> {L |- of E T} ->
  {ml_member (map E (E' xenv)) (Map xenv)} -> app_subst ML E V -> (exists V',
  {evalcc (E' Venv) V'} /\ equiv T V V').</b>
</pre>
<a name="1393"></a>
<pre>


  ============================
   forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
     csubst (cml_cons (cmap xenv Venv) cml_nil) -> subst_equiv L ML Venv ->
     vars_of_sctx L FVs -> {mapvar FVs Map} -> {L |- of E T} ->
     {ml_member (map E (E' xenv)) (Map xenv)} -> app_subst ML E V ->
     (exists V', {evalcc (E' Venv) V'} /\ equiv T V V')

env_eval_pres < <b>induction on 5.</b>
</pre>
<a name="1394"></a>
<pre>


  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  ============================
   forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
     csubst (cml_cons (cmap xenv Venv) cml_nil) -> subst_equiv L ML Venv ->
     vars_of_sctx L FVs @ -> {mapvar FVs Map} -> {L |- of E T} ->
     {ml_member (map E (E' xenv)) (Map xenv)} -> app_subst ML E V ->
     (exists V', {evalcc (E' Venv) V'} /\ equiv T V V')

env_eval_pres < <b>intros.</b>
</pre>
<a name="1395"></a>
<pre>

  Variables: T, L, ML, Venv, Map, FVs, E, E', V
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' L
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv L ML Venv
  H5 : vars_of_sctx L FVs @
  H6 : {mapvar FVs Map}
  H7 : {L |- of E T}
  H8 : {ml_member (map E (E' n1)) (Map n1)}
  H9 : app_subst ML E V
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>case H5.</b>
</pre>
<a name="1396"></a>
<pre>
Subgoal 1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' nil
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv nil ML Venv
  H6 : {mapvar tl_nil Map}
  H7 : {of E T}
  H8 : {ml_member (map E (E' n1)) (Map n1)}
  H9 : app_subst ML E V
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

Subgoal 2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>case H6.</b>
</pre>
<a name="1397"></a>
<pre>
Subgoal 1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' nil
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv nil ML Venv
  H7 : {of E T}
  H8 : {ml_member (map E (E' n1)) ml_nil}
  H9 : app_subst ML E V
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

Subgoal 2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>case H8.</b>
</pre>
<a name="1398"></a>
<pre>
Subgoal 2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H6 : {mapvar (tl_cons X Vs) Map}
  H7 : {L1, of X T1 |- of E T}
  H8 : {ml_member (map E (E' n1)) (Map n1)}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>case H6.</b>
</pre>
<a name="1399"></a>
<pre>
Subgoal 2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H8 : {ml_member (map E (E' n1)) (ml_cons (map X (fst n1)) (Map1 (rst n1)))}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>case H8.</b>
</pre>
<a name="1400"></a>
<pre>
Subgoal 2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of X T}
  H9 : app_subst ML X V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  ============================
   exists V', {evalcc (fst Venv) V'} /\ equiv T V V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>apply of_var_inv to H1 H7.</b>
</pre>
<a name="1401"></a>
<pre>
Subgoal 2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T :: L1) ML Venv
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  ============================
   exists V', {evalcc (fst Venv) V'} /\ equiv T V V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>case H4.</b>
</pre>
<a name="1402"></a>
<pre>
Subgoal 2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  ============================
   exists V'1, {evalcc (fst (cross V' VL')) V'1} /\ equiv T V V'1

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>apply subst_var to H2 H14 H9.</b>
</pre>
<a name="1403"></a>
<pre>
Subgoal 2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  ============================
   exists V'1, {evalcc (fst (cross V' VL')) V'1} /\ equiv T V1 V'1

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>exists V'.</b>
</pre>
<a name="1404"></a>
<pre>
Subgoal 2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  ============================
   {evalcc (fst (cross V' VL')) V'} /\ equiv T V1 V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>split.</b>
</pre>
<a name="1405"></a>
<pre>
Subgoal 2.1.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  ============================
   {evalcc (fst (cross V' VL')) V'}

Subgoal 2.1.2 is:
 equiv T V1 V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>apply csubst_mem to H3 _.</b>
</pre>
<a name="1406"></a>
<pre>
Subgoal 2.1.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V', X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  H16 : ctname n1
  H17 : {cval (cross V' VL')}
  H18 : {ctm (cross V' VL')}
  ============================
   {evalcc (fst (cross V' VL')) V'}

Subgoal 2.1.2 is:
 equiv T V1 V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>apply val_evalcc to H17.</b>
</pre>
<a name="1407"></a>
<pre>
Subgoal 2.1.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V', X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  H16 : ctname n1
  H17 : {cval (cross V' VL')}
  H18 : {ctm (cross V' VL')}
  H19 : {evalcc (cross V' VL') (cross V' VL')}
  ============================
   {evalcc (fst (cross V' VL')) V'}

Subgoal 2.1.2 is:
 equiv T V1 V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>search.</b>
</pre>
<a name="1408"></a>
<pre>
Subgoal 2.1.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  ============================
   equiv T V1 V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>search.</b>
</pre>
<a name="1409"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>apply eq_ml_member to H12 H13.</b>
</pre>
<a name="1410"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>apply mapvar_mem to H11 H14.</b>
</pre>
<a name="1411"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, E'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'1 n1 n2 (rst n1)
  H16 : env_elem (E'1 n1 n2)
  H17 : {ml_member (map E (E'1 n1 n2 n2)) (Map1 n2)}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>apply env_elem_closed to H16.</b>
</pre>
<a name="1412"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'2 n2 (rst n1)
  H16 : env_elem (E'2 n2)
  H17 : {ml_member (map E (E'2 n2 n2)) (Map1 n2)}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>apply env_elem_closed to H16.</b>
</pre>
<a name="1413"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>case H1 (keep).</b>
</pre>
<a name="1414"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H19 : tname X
  H20 : forall T', member (of X T') L1 -> T1 = T'
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>clear H19.</b>
</pre>
<a name="1415"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H20 : forall T', member (of X T') L1 -> T1 = T'
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>clear H20.</b>
</pre>
<a name="1416"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < <b>case H4.</b>
</pre>
<a name="1417"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H22 : {sml_member (smap X V1) ML}
  H23 : equiv T1 V1 V'
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>clear H22.</b>
</pre>
<a name="1418"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H23 : equiv T1 V1 V'
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>clear H23.</b>
</pre>
<a name="1419"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>clear H24.</b>
</pre>
<a name="1420"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>apply csubst_single_inv to H3.</b>
</pre>
<a name="1421"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>assert csubst (cml_cons (cmap n2 VL') cml_nil).</b>
</pre>
<a name="1422"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>assert {L1 |- of E T}.</b>
</pre>
<a name="1423"></a>
<pre>
Subgoal 2.2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  ============================
   {L1 |- of E T}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>apply sctx_env_sync to H18 H10 H11 H17.</b>
</pre>
<a name="1424"></a>
<pre>
Subgoal 2.2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', T2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : member (of E T2) L1
  H27 : tname E
  ============================
   {L1 |- of E T}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>apply of_var_strenghten to H1 H7 H27 H26.</b>
</pre>
<a name="1425"></a>
<pre>
Subgoal 2.2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', T2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : member (of E T2) L1
  H27 : tname E
  H28 : {L1 |- of E T}
  ============================
   {L1 |- of E T}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>search.</b>
</pre>
<a name="1426"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>apply IH to H18 H2 H25 H21 H10 H11 H26 H17 H9.</b>
</pre>
<a name="1427"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>assert {evalcc (E'3 (rst (cross V' VL'))) V'1}.</b>
</pre>
<a name="1428"></a>
<pre>
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>apply csubst_mem to H3 _.</b>
</pre>
<a name="1429"></a>
<pre>
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>case H30 (keep).</b>
</pre>
<a name="1430"></a>
<pre>
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>apply val_evalcc to H33.</b>
</pre>
<a name="1431"></a>
<pre>
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  H34 : {evalcc VL' VL'}
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>assert {evalcc (rst (cross V' VL')) VL'}.</b>
</pre>
<a name="1432"></a>
<pre>
Subgoal 2.2.2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  H34 : {evalcc VL' VL'}
  ============================
   {evalcc (rst (cross V' VL')) VL'}

Subgoal 2.2.2 is:
 {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>apply val_evalcc to H30.</b>
</pre>
<a name="1433"></a>
<pre>
Subgoal 2.2.2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  H34 : {evalcc VL' VL'}
  H35 : {evalcc (cross V' VL') (cross V' VL')}
  ============================
   {evalcc (rst (cross V' VL')) VL'}

Subgoal 2.2.2 is:
 {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>search.</b>
</pre>
<a name="1434"></a>
<pre>
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  H34 : {evalcc VL' VL'}
  H35 : {evalcc (rst (cross V' VL')) VL'}
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>apply env_elem_eval_cong to H16 H34 H35 H27.</b>
</pre>
<a name="1435"></a>
<pre>
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  H34 : {evalcc VL' VL'}
  H35 : {evalcc (rst (cross V' VL')) VL'}
  H36 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>search.</b>
</pre>
<a name="1436"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>exists V'1.</b>
</pre>
<a name="1437"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  ============================
   {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < <b>split.</b>
</pre>
<a name="1438"></a>
<pre>
Subgoal 2.2.3:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  ============================
   {evalcc (E' (cross V' VL')) V'1}

Subgoal 2.2.4 is:
 equiv T V V'1

env_eval_pres < <b>apply eq_inst_eval to H15 H29 with C = cross V' VL'.</b>
</pre>
<a name="1439"></a>
<pre>
Subgoal 2.2.3:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  H30 : {evalcc (E' (cross V' VL')) V'1}
  ============================
   {evalcc (E' (cross V' VL')) V'1}

Subgoal 2.2.4 is:
 equiv T V V'1

env_eval_pres < <b>search.</b>
</pre>
<a name="1440"></a>
<pre>
Subgoal 2.2.4:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  ============================
   equiv T V V'1

env_eval_pres < <b>search.</b>
Proof completed.
</pre>
<a name="1441"></a>
<pre class="code">
Abella < <b>Theorem var_eval_pres : 
forall T L V ML V' Venv FVs Map E E' T' VS ES', nabla x y xenv,
  sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
  csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  vars_of_sctx L FVs -> {mapvar FVs Map} -> {L, of x T |- of (E x) T'} ->
  {ml_member (map (E x) (E' xenv y)) (ml_cons (map x y) (Map xenv))} ->
  app_subst (sml_cons (smap x V) ML) (E x) VS ->
  app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
  (exists VS', {evalcc ES' VS'} /\ equiv T' VS VS').</b>
</pre>
<a name="1442"></a>
<pre>


  ============================
   forall T L V ML V' Venv FVs Map E E' T' VS ES', nabla x y xenv,
     sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
     csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     vars_of_sctx L FVs -> {mapvar FVs Map} -> {L, of x T |- of (E x) T'} ->
     {ml_member (map (E x) (E' xenv y)) (ml_cons (map x y) (Map xenv))} ->
     app_subst (sml_cons (smap x V) ML) (E x) VS ->
     app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
     (exists VS', {evalcc ES' VS'} /\ equiv T' VS VS')

var_eval_pres < <b>intros.</b>
</pre>
<a name="1443"></a>
<pre>

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H8.</b>
</pre>
<a name="1444"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 ES'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>assert {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}.</b>
</pre>
<a name="1445"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 ES'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>apply subst_var to H2 H11 H9.</b>
</pre>
<a name="1446"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 ES'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>assert {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}.</b>
</pre>
<a name="1447"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 ES'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>apply csubst_var to H3 H12 H10.</b>
</pre>
<a name="1448"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  ============================
   exists VS', {evalcc V' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H4.</b>
</pre>
<a name="1449"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  ============================
   exists VS', {evalcc V' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H3.</b>
</pre>
<a name="1450"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   exists VS', {evalcc V' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>apply val_evalcc to H18.</b>
</pre>
<a name="1451"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  ============================
   exists VS', {evalcc V' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>exists V'.</b>
</pre>
<a name="1452"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  ============================
   {evalcc V' V'} /\ equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>split.</b>
</pre>
<a name="1453"></a>
<pre>
Subgoal 1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  ============================
   {evalcc V' V'}

Subgoal 1.2 is:
 equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>search.</b>
</pre>
<a name="1454"></a>
<pre>
Subgoal 1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H7.</b>
</pre>
<a name="1455"></a>
<pre>
Subgoal 1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H21 : {L, of n1 T, [F n1] |- of n1 T'}
  H22 : member (F n1) (of n1 T :: L)
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H22.</b>
</pre>
<a name="1456"></a>
<pre>
Subgoal 1.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H21 : {L, of n1 T, [of n1 T] |- of n1 T'}
  ============================
   equiv T' V V'

Subgoal 1.2.2 is:
 equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H21.</b>
</pre>
<a name="1457"></a>
<pre>
Subgoal 1.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F
  H1 : sctx' (of n1 T' :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T' V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  ============================
   equiv T' V V'

Subgoal 1.2.2 is:
 equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>search.</b>
</pre>
<a name="1458"></a>
<pre>
Subgoal 1.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H21 : {L, of n1 T, [F n1] |- of n1 T'}
  H23 : member (F n1) L
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H1.</b>
</pre>
<a name="1459"></a>
<pre>
Subgoal 1.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H21 : {L, of n1 T, [F n1] |- of n1 T'}
  H23 : member (F n1) L
  H24 : sctx' L
  H25 : tname n1
  H26 : forall T', member (of n1 T') L -> T = T'
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>apply sctx'_mem to H24 H23.</b>
</pre>
<a name="1460"></a>
<pre>
Subgoal 1.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F, X, T1
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H21 : {L, of n1 T, [of (X n1) T1] |- of n1 T'}
  H23 : member (of (X n1) T1) L
  H24 : sctx' L
  H25 : tname n1
  H26 : forall T', member (of n1 T') L -> T = T'
  H27 : tname (X n1)
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H21.</b>
</pre>
<a name="1461"></a>
<pre>
Subgoal 1.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F, X, T1
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H23 : member (of n1 T') L
  H24 : sctx' L
  H25 : tname n1
  H26 : forall T', member (of n1 T') L -> T = T'
  H27 : tname n1
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>apply mem_of_absurd to H23.</b>
</pre>
<a name="1462"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (Map n3)}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>apply ml_member_prune1 to H11.</b>
</pre>
<a name="1463"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map E1 (E' n3 n2)) (Map n3)}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>apply ml_member_prune2 to H11.</b>
</pre>
<a name="1464"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H2.</b>
</pre>
<a name="1465"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H13 : tname n1
  H14 : {tm V}
  H15 : {val V}
  H16 : forall V', {sml_member (smap n1 V') ML} -> V' = V
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>clear H13.</b>
</pre>
<a name="1466"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H14 : {tm V}
  H15 : {val V}
  H16 : forall V', {sml_member (smap n1 V') ML} -> V' = V
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>clear H14.</b>
</pre>
<a name="1467"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H15 : {val V}
  H16 : forall V', {sml_member (smap n1 V') ML} -> V' = V
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>clear H15.</b>
</pre>
<a name="1468"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H16 : forall V', {sml_member (smap n1 V') ML} -> V' = V
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>clear H16.</b>
</pre>
<a name="1469"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H3.</b>
</pre>
<a name="1470"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H18 : ctname n2
  H19 : {ctm V'}
  H20 : {cval V'}
  H21 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>clear H18.</b>
</pre>
<a name="1471"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H19 : {ctm V'}
  H20 : {cval V'}
  H21 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>clear H19.</b>
</pre>
<a name="1472"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H20 : {cval V'}
  H21 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>clear H20.</b>
</pre>
<a name="1473"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H21 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>clear H21.</b>
</pre>
<a name="1474"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H9.</b>
</pre>
<a name="1475"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H10.</b>
</pre>
<a name="1476"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H23 : app_csubst (cml_cons (cmap n3 Venv) cml_nil) (E1' n3) ES'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H23.</b>
</pre>
<a name="1477"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H24 : app_csubst cml_nil (E1' Venv) ES'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H24.</b>
</pre>
<a name="1478"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  ============================
   exists VS', {evalcc (E1' Venv) VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H4.</b>
</pre>
<a name="1479"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H25 : equiv T V V'
  H26 : subst_equiv L ML Venv
  ============================
   exists VS', {evalcc (E1' Venv) VS'} /\ equiv T' VS VS'

var_eval_pres < <b>case H1.</b>
</pre>
<a name="1480"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H25 : equiv T V V'
  H26 : subst_equiv L ML Venv
  H27 : sctx' L
  H28 : tname n1
  H29 : forall T', member (of n1 T') L -> T = T'
  ============================
   exists VS', {evalcc (E1' Venv) VS'} /\ equiv T' VS VS'

var_eval_pres < <b>apply of_strenghten' to H27 H7.</b>
</pre>
<a name="1481"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H25 : equiv T V V'
  H26 : subst_equiv L ML Venv
  H27 : sctx' L
  H28 : tname n1
  H29 : forall T', member (of n1 T') L -> T = T'
  H30 : {L |- of E1 T'}
  ============================
   exists VS', {evalcc (E1' Venv) VS'} /\ equiv T' VS VS'

var_eval_pres < <b>apply env_eval_pres to H27 H12 H17 H26 H5 H6 H30 H11 H22.</b>
</pre>
<a name="1482"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1',
             V'1
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H25 : equiv T V V'
  H26 : subst_equiv L ML Venv
  H27 : sctx' L
  H28 : tname n1
  H29 : forall T', member (of n1 T') L -> T = T'
  H30 : {L |- of E1 T'}
  H31 : {evalcc (E1' Venv) V'1}
  H32 : equiv T' VS V'1
  ============================
   exists VS', {evalcc (E1' Venv) VS'} /\ equiv T' VS VS'

var_eval_pres < <b>search.</b>
Proof completed.
</pre>
<a name="1483"></a>
<pre class="code">
Abella < <b>Theorem mapenv_eval_pres : 
forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
  sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
  csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  vars_of_sctx L FVs -> {mapvar FVs Map} ->
  subset (NFVs x) (tl_cons x FVs) ->
  {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)} ->
  (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
  {evalcc (PE Venv V') VE'} /\ subst_equiv L' (sml_cons (smap x V) ML) VE').</b>
</pre>
<a name="1484"></a>
<pre>


  ============================
   forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
     sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
     csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     vars_of_sctx L FVs -> {mapvar FVs Map} ->
     subset (NFVs x) (tl_cons x FVs) ->
     {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)} ->
     (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
     {evalcc (PE Venv V') VE'} /\
     subst_equiv L' (sml_cons (smap x V) ML) VE')

mapenv_eval_pres < <b>induction on 8.</b>
</pre>
<a name="1485"></a>
<pre>


  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  ============================
   forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
     sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
     csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     vars_of_sctx L FVs -> {mapvar FVs Map} ->
     subset (NFVs x) (tl_cons x FVs) ->
     {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}@ ->
     (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
     {evalcc (PE Venv V') VE'} /\
     subst_equiv L' (sml_cons (smap x V) ML) VE')

mapenv_eval_pres < <b>intros.</b>
</pre>
<a name="1486"></a>
<pre>

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset (NFVs n1) (tl_cons n1 FVs)
  H8 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}@
  ============================
   exists VE' L', pruned_env nil (NFVs n1) (of n1 T :: L) L' /\
     {evalcc (PE Venv V') VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>case H8.</b>
</pre>
<a name="1487"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   exists VE' L', pruned_env nil tl_nil (of n1 T :: L) L' /\
     {evalcc unit VE'} /\ subst_equiv L' (sml_cons (smap n1 V) ML) VE'

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>exists unit.</b>
</pre>
<a name="1488"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   exists L', pruned_env nil tl_nil (of n1 T :: L) L' /\
     {evalcc unit unit} /\ subst_equiv L' (sml_cons (smap n1 V) ML) unit

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>exists nil.</b>
</pre>
<a name="1489"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   pruned_env nil tl_nil (of n1 T :: L) nil /\ {evalcc unit unit} /\
     subst_equiv nil (sml_cons (smap n1 V) ML) unit

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>split.</b>
</pre>
<a name="1490"></a>
<pre>
Subgoal 1.1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   pruned_env nil tl_nil (of n1 T :: L) nil

Subgoal 1.2 is:
 {evalcc unit unit}

Subgoal 1.3 is:
 subst_equiv nil (sml_cons (smap n1 V) ML) unit

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>search.</b>
</pre>
<a name="1491"></a>
<pre>
Subgoal 1.2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   {evalcc unit unit}

Subgoal 1.3 is:
 subst_equiv nil (sml_cons (smap n1 V) ML) unit

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>search.</b>
</pre>
<a name="1492"></a>
<pre>
Subgoal 1.3:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   subst_equiv nil (sml_cons (smap n1 V) ML) unit

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>search.</b>
</pre>
<a name="1493"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset (tl_cons (X n1) (L1 n1)) (tl_cons n1 FVs)
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>case H7.</b>
</pre>
<a name="1494"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>apply vars_of_sctx_mem_exists to H1 _ H11.</b>
</pre>
<a name="1495"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X n1) T1) (of n1 T :: L)
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>apply of_mem to H13.</b>
</pre>
<a name="1496"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X n1) T1}
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>assert app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv).</b>
</pre>
<a name="1497"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>apply subst_equiv'_mem to H4 H13.</b>
</pre>
<a name="1498"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1, V1
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X n1) (V1 n1)) (sml_cons (smap n1 V) ML)}
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>apply subst_var' to H2 H16.</b>
</pre>
<a name="1499"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1, V1
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X n1) (V1 n1)) (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X n1) (V1 n1)
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>apply subst_mem to H2 H16.</b>
</pre>
<a name="1500"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) (V2 n1)) (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) (V2 n1)
  H18 : tname (X1 n1)
  H19 : {val (V2 n1)}
  H20 : {tm (V2 n1)}
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>apply closed_tm_prune to H20.</b>
</pre>
<a name="1501"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>apply var_eval_pres to H1 H2 H3 H4 H5 H6 H14 H9 H17 H15.</b>
</pre>
<a name="1502"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>apply IH to H1 H2 H3 H4 H5 H6 H12 H10.</b>
</pre>
<a name="1503"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < <b>exists cross VS' VE'.</b>
</pre>
<a name="1504"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists L', pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) (cross VS' VE')} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) (cross VS' VE')

mapenv_eval_pres < <b>exists of (X n1) T1 :: L' n1.</b>
</pre>
<a name="1505"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) (of (X1 n1) T1 :: L' n1) /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) (cross VS' VE')} /\
     subst_equiv (of (X1 n1) T1 :: L' n1) (sml_cons (smap n1 V) ML) (cross VS' VE')

mapenv_eval_pres < <b>split.</b>
</pre>
<a name="1506"></a>
<pre>
Subgoal 2.1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) (of (X1 n1) T1 :: L' n1)

Subgoal 2.2 is:
 {evalcc (cross (M V' Venv) (ML1 V' Venv)) (cross VS' VE')}

Subgoal 2.3 is:
 subst_equiv (of (X1 n1) T1 :: L' n1) (sml_cons (smap n1 V) ML) (cross VS' VE')

mapenv_eval_pres < <b>search.</b>
</pre>
<a name="1507"></a>
<pre>
Subgoal 2.2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) (cross VS' VE')}

Subgoal 2.3 is:
 subst_equiv (of (X1 n1) T1 :: L' n1) (sml_cons (smap n1 V) ML) (cross VS' VE')

mapenv_eval_pres < <b>search.</b>
</pre>
<a name="1508"></a>
<pre>
Subgoal 2.3:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   subst_equiv (of (X1 n1) T1 :: L' n1) (sml_cons (smap n1 V) ML) (cross VS' VE')

mapenv_eval_pres < <b>unfold.</b>
</pre>
<a name="1509"></a>
<pre>
Subgoal 2.3:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists V1, subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE' /\
     {sml_member (smap (X1 n1) V1) (sml_cons (smap n1 V) ML)} /\
     equiv T1 V1 VS'

mapenv_eval_pres < <b>exists M'.</b>
</pre>
<a name="1510"></a>
<pre>
Subgoal 2.3:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE' /\
     {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)} /\
     equiv T1 M' VS'

mapenv_eval_pres < <b>split.</b>
</pre>
<a name="1511"></a>
<pre>
Subgoal 2.3.1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'

Subgoal 2.3.2 is:
 {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}

Subgoal 2.3.3 is:
 equiv T1 M' VS'

mapenv_eval_pres < <b>search.</b>
</pre>
<a name="1512"></a>
<pre>
Subgoal 2.3.2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}

Subgoal 2.3.3 is:
 equiv T1 M' VS'

mapenv_eval_pres < <b>search.</b>
</pre>
<a name="1513"></a>
<pre>
Subgoal 2.3.3:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   equiv T1 M' VS'

mapenv_eval_pres < <b>search.</b>
Proof completed.
</pre>
<a name="1514"></a>
<pre class="code">
Abella < <b>Theorem eval_pres : 
forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
  sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
  csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  vars_of_sctx L FVs -> {mapvar FVs Map} -> {L, of x T |- of (E x) T'} ->
  {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
  app_subst (sml_cons (smap x V) ML) (E x) ES ->
  app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
  sim T' ES ES'.</b>
</pre>
<a name="1515"></a>
<pre>


  ============================
   forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
     sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
     csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     vars_of_sctx L FVs -> {mapvar FVs Map} -> {L, of x T |- of (E x) T'} ->
     {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
     app_subst (sml_cons (smap x V) ML) (E x) ES ->
     app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
     sim T' ES ES'

eval_pres < <b>induction on 8.</b>
</pre>
<a name="1516"></a>
<pre>


  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  ============================
   forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
     sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
     csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     vars_of_sctx L FVs -> {mapvar FVs Map} -> {L, of x T |- of (E x) T'} ->
     {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}@ ->
     app_subst (sml_cons (smap x V) ML) (E x) ES ->
     app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
     sim T' ES ES'

eval_pres < <b>intros.</b>
</pre>
<a name="1517"></a>
<pre>

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  ============================
   sim T' ES ES'

eval_pres < <b>case H8 (keep).</b>
</pre>
<a name="1518"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  ============================
   sim T' ES ES'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply var_eval_pres to H1 H2 H3 H4 H5 H6 H7 H11 H9 H10.</b>
</pre>
<a name="1519"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   sim T' ES ES'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>unfold.</b>
</pre>
<a name="1520"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   exists V V', {eval ES V} /\ {evalcc ES' V'} /\ equiv T' V V'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>exists ES.</b>
</pre>
<a name="1521"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   exists V', {eval ES ES} /\ {evalcc ES' V'} /\ equiv T' ES V'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>exists VS'.</b>
</pre>
<a name="1522"></a>
<pre>
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   {eval ES ES} /\ {evalcc ES' VS'} /\ equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>split.</b>
</pre>
<a name="1523"></a>
<pre>
Subgoal 1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   {eval ES ES}

Subgoal 1.2 is:
 {evalcc ES' VS'}

Subgoal 1.3 is:
 equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply equiv_val to H13.</b>
</pre>
<a name="1524"></a>
<pre>
Subgoal 1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  H14 : {val ES}
  ============================
   {eval ES ES}

Subgoal 1.2 is:
 {evalcc ES' VS'}

Subgoal 1.3 is:
 equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply val_eval to H14.</b>
</pre>
<a name="1525"></a>
<pre>
Subgoal 1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  H14 : {val ES}
  H15 : {eval ES ES}
  ============================
   {eval ES ES}

Subgoal 1.2 is:
 {evalcc ES' VS'}

Subgoal 1.3 is:
 equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1526"></a>
<pre>
Subgoal 1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   {evalcc ES' VS'}

Subgoal 1.3 is:
 equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1527"></a>
<pre>
Subgoal 1.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1528"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) T'}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) ES'
  ============================
   sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply subst_closed_tm to _ H9.</b>
</pre>
<a name="1529"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) T'}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) (lnat N)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) ES'
  ============================
   sim T' (lnat N) ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply csubst_closed_ctm to _ H10.</b>
</pre>
<a name="1530"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) T'}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) (lnat N)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) (clnat N)
  ============================
   sim T' (lnat N) (clnat N)

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert equiv nat_t (lnat N) (clnat N).</b>
</pre>
<a name="1531"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) T'}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) (lnat N)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) (clnat N)
  H11 : equiv nat_t (lnat N) (clnat N)
  ============================
   sim T' (lnat N) (clnat N)

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply equiv_to_sim to H11.</b>
</pre>
<a name="1532"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) T'}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) (lnat N)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) (clnat N)
  H11 : equiv nat_t (lnat N) (clnat N)
  H12 : sim nat_t (lnat N) (clnat N)
  ============================
   sim T' (lnat N) (clnat N)

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply of_nat to H1 H7.</b>
</pre>
<a name="1533"></a>
<pre>
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) nat_t}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) (lnat N)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) (clnat N)
  H11 : equiv nat_t (lnat N) (clnat N)
  H12 : sim nat_t (lnat N) (clnat N)
  ============================
   sim nat_t (lnat N) (clnat N)

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1534"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) T'}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) ES'
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  ============================
   sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply of_abs_arrow_typ to H1 H7.</b>
</pre>
<a name="1535"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) ES'
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  ============================
   sim (arr T1 T2) ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply subst_abs to H9.</b>
</pre>
<a name="1536"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) ES'
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  ============================
   sim (arr T1 T2) (abs ES1) ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply csubst_cpair to H10.</b>
</pre>
<a name="1537"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  ============================
   sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert name_map (Map n3).</b>
</pre>
<a name="1538"></a>
<pre>
Subgoal 3.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  ============================
   name_map (Map n3)

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H1.</b>
</pre>
<a name="1539"></a>
<pre>
Subgoal 3.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : sctx' L
  H19 : tname n1
  H20 : forall T', member (of n1 T') L -> T = T'
  ============================
   name_map (Map n3)

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply mapvar_named_map to H18 H5 H6 with X = n3.</b>
</pre>
<a name="1540"></a>
<pre>
Subgoal 3.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : sctx' L
  H19 : tname n1
  H20 : forall T', member (of n1 T') L -> T = T'
  H21 : name_map (Map n3)
  ============================
   name_map (Map n3)

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1541"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  ============================
   sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}.</b>
</pre>
<a name="1542"></a>
<pre>
Subgoal 3.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply mapvar_env_map to H6.</b>
</pre>
<a name="1543"></a>
<pre>
Subgoal 3.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : env_map Map
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply clos_closed to H18 H19 H8.</b>
</pre>
<a name="1544"></a>
<pre>
Subgoal 3.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : env_map Map
  H20 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1545"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}
  ============================
   sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply csubst_closed_ctm to H19 H16.</b>
</pre>
<a name="1546"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply closed_ctm_prune to H19.</b>
</pre>
<a name="1547"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply closed_ctm_prune to H19.</b>
</pre>
<a name="1548"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>clear H16.</b>
</pre>
<a name="1549"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>clear H19.</b>
</pre>
<a name="1550"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>clear H18.</b>
</pre>
<a name="1551"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply fvars_subset to _ H11.</b>
</pre>
<a name="1552"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply mapenv_eval_pres to H1 H2 H3 H4 H5 H6 H20 H12.</b>
</pre>
<a name="1553"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>unfold.</b>
</pre>
<a name="1554"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists V V', {eval (abs ES1) V} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2) V'} /\
     equiv (arr T1 T2) V V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>exists abs ES1.</b>
</pre>
<a name="1555"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists V', {eval (abs ES1) (abs ES1)} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2) V'} /\
     equiv (arr T1 T2) (abs ES1) V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H17.</b>
</pre>
<a name="1556"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H24 : app_csubst (cml_cons (cmap n3 Venv) cml_nil) (PE n3 V') ES'2
  ============================
   exists V', {eval (abs ES1) (abs ES1)} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2) V'} /\
     equiv (arr T1 T2) (abs ES1) V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H24.</b>
</pre>
<a name="1557"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H25 : app_csubst cml_nil (PE Venv V') ES'2
  ============================
   exists V', {eval (abs ES1) (abs ES1)} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2) V'} /\
     equiv (arr T1 T2) (abs ES1) V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H25.</b>
</pre>
<a name="1558"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists V'1, {eval (abs ES1) (abs ES1)} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V')) V'1} /\
     equiv (arr T1 T2) (abs ES1) V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>exists cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE'.</b>
</pre>
<a name="1559"></a>
<pre>
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {eval (abs ES1) (abs ES1)} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V')) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')} /\
     equiv (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>split.</b>
</pre>
<a name="1560"></a>
<pre>
Subgoal 3.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {eval (abs ES1) (abs ES1)}

Subgoal 3.4 is:
 {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V')) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5 is:
 equiv (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1561"></a>
<pre>
Subgoal 3.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V')) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5 is:
 equiv (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1562"></a>
<pre>
Subgoal 3.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   equiv (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>unfold.</b>
</pre>
<a name="1563"></a>
<pre>
Subgoal 3.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply sctx'_tmctx_exists to H1.</b>
</pre>
<a name="1564"></a>
<pre>
Subgoal 3.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  ============================
   {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply of_tm to H26 H7.</b>
</pre>
<a name="1565"></a>
<pre>
Subgoal 3.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  ============================
   {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert forall X, member (tm X) (L'1 n1) -> (exists V',
  {sml_member (smap X V') (sml_cons (smap n1 V) ML)}).</b>
</pre>
<a name="1566"></a>
<pre>
Subgoal 3.5.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  ============================
   forall X, member (tm X) (L'1 n1) -> (exists V'1,
     {sml_member (smap X V'1) (sml_cons (smap n1 V) ML)})

Subgoal 3.5.1 is:
 {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>intros.</b>
</pre>
<a name="1567"></a>
<pre>
Subgoal 3.5.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1, X
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  H29 : member (tm (X n1)) (L'1 n1)
  ============================
   exists V'1, {sml_member (smap (X n1) V'1) (sml_cons (smap n1 V) ML)}

Subgoal 3.5.1 is:
 {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply sctx'_tmctx_sync2 to H26 H29.</b>
</pre>
<a name="1568"></a>
<pre>
Subgoal 3.5.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1, X, T3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  H29 : member (tm (X n1)) (L'1 n1)
  H30 : member (of (X n1) T3) (of n1 T :: L)
  ============================
   exists V'1, {sml_member (smap (X n1) V'1) (sml_cons (smap n1 V) ML)}

Subgoal 3.5.1 is:
 {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply subst_equiv'_mem to H4 H30.</b>
</pre>
<a name="1569"></a>
<pre>
Subgoal 3.5.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1, X, T3, V1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  H29 : member (tm (X n1)) (L'1 n1)
  H30 : member (of (X n1) T3) (of n1 T :: L)
  H31 : {sml_member (smap (X n1) (V1 n1)) (sml_cons (smap n1 V) ML)}
  ============================
   exists V'1, {sml_member (smap (X n1) V'1) (sml_cons (smap n1 V) ML)}

Subgoal 3.5.1 is:
 {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1570"></a>
<pre>
Subgoal 3.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  H29 : forall X, member (tm X) (L'1 n1) -> (exists V'1,
          {sml_member (smap X V'1) (sml_cons (smap n1 V) ML)})
  ============================
   {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply subst_result_closed_tm to H2 H27 H28 H29 H9.</b>
</pre>
<a name="1571"></a>
<pre>
Subgoal 3.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  H29 : forall X, member (tm X) (L'1 n1) -> (exists V'1,
          {sml_member (smap X V'1) (sml_cons (smap n1 V) ML)})
  H30 : {tm (abs ES1)}
  ============================
   {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1572"></a>
<pre>
Subgoal 3.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply mapvar_env_map to H6.</b>
</pre>
<a name="1573"></a>
<pre>
Subgoal 3.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply cc_ctm to H26 H8.</b>
</pre>
<a name="1574"></a>
<pre>
Subgoal 3.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H27 : {ctm n3, ctm n2 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H27.</b>
</pre>
<a name="1575"></a>
<pre>
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H3.</b>
</pre>
<a name="1576"></a>
<pre>
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H30 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H30.</b>
</pre>
<a name="1577"></a>
<pre>
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>inst H29 with n3 = Venv, n2 = V'.</b>
</pre>
<a name="1578"></a>
<pre>
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>cut H40 with H32.</b>
</pre>
<a name="1579"></a>
<pre>
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>cut H41 with H37.</b>
</pre>
<a name="1580"></a>
<pre>
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  H42 : {ctm (PE Venv V')}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply evalcc_ctm_pres to H22 H42.</b>
</pre>
<a name="1581"></a>
<pre>
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  H42 : {ctm (PE Venv V')}
  H43 : {ctm VE'}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H1.</b>
</pre>
<a name="1582"></a>
<pre>
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  H42 : {ctm (PE Venv V')}
  H43 : {ctm VE'}
  H44 : sctx' L
  H45 : tname n1
  H46 : forall T', member (of n1 T') L -> T = T'
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply mapvar_named_map to H44 H5 H6 with X = n3.</b>
</pre>
<a name="1583"></a>
<pre>
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  H42 : {ctm (PE Venv V')}
  H43 : {ctm VE'}
  H44 : sctx' L
  H45 : tname n1
  H46 : forall T', member (of n1 T') L -> T = T'
  H47 : name_map (Map n3)
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply clos_closed to H47 H26 H8.</b>
</pre>
<a name="1584"></a>
<pre>
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  H42 : {ctm (PE Venv V')}
  H43 : {ctm VE'}
  H44 : sctx' L
  H45 : tname n1
  H46 : forall T', member (of n1 T') L -> T = T'
  H47 : name_map (Map n3)
  H48 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1585"></a>
<pre>
Subgoal 3.5.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2, [F n2 n3] |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  H29 : member (F n2 n3) (ctm n2 :: ctm n3 :: nil)
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H29.</b>
</pre>
<a name="1586"></a>
<pre>
Subgoal 3.5.2.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2, [ctm n2] |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H28.</b>
</pre>
<a name="1587"></a>
<pre>
Subgoal 3.5.2.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2, [F n2 n3] |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  H30 : member (F n2 n3) (ctm n3 :: nil)
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H30.</b>
</pre>
<a name="1588"></a>
<pre>
Subgoal 3.5.2.2.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2, [ctm n3] |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H28.</b>
</pre>
<a name="1589"></a>
<pre>
Subgoal 3.5.2.2.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2, [F n2 n3] |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  H31 : member (F n2 n3) nil
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H31.</b>
</pre>
<a name="1590"></a>
<pre>
Subgoal 3.5.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1591"></a>
<pre>
Subgoal 3.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply evalcc_val to H22.</b>
</pre>
<a name="1592"></a>
<pre>
Subgoal 3.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : {cval VE'}
  ============================
   {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1593"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   forall V1 V1', equiv T1 V1 V1' ->
     sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>intros.</b>
</pre>
<a name="1594"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert {L' n1 |- of (abs (M n1)) (arr T1 T2)}.</b>
</pre>
<a name="1595"></a>
<pre>
Subgoal 3.5.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  ============================
   {L' n1 |- of (abs (M n1)) (arr T1 T2)}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert vars_of_sctx (of n1 T :: L) (tl_cons n1 FVs).</b>
</pre>
<a name="1596"></a>
<pre>
Subgoal 3.5.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : vars_of_sctx (of n1 T :: L) (tl_cons n1 FVs)
  ============================
   {L' n1 |- of (abs (M n1)) (arr T1 T2)}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply fvars_islist to _ H11.</b>
</pre>
<a name="1597"></a>
<pre>
Subgoal 3.5.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : vars_of_sctx (of n1 T :: L) (tl_cons n1 FVs)
  H28 : islist (NFVs n1)
  ============================
   {L' n1 |- of (abs (M n1)) (arr T1 T2)}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply subset_refl to H28.</b>
</pre>
<a name="1598"></a>
<pre>
Subgoal 3.5.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : vars_of_sctx (of n1 T :: L) (tl_cons n1 FVs)
  H28 : islist (NFVs n1)
  H29 : subset (NFVs n1) (NFVs n1)
  ============================
   {L' n1 |- of (abs (M n1)) (arr T1 T2)}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply pruned_env_typing to H1 H7 H27 _ H11 H29 H21.</b>
</pre>
<a name="1599"></a>
<pre>
Subgoal 3.5.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : vars_of_sctx (of n1 T :: L) (tl_cons n1 FVs)
  H28 : islist (NFVs n1)
  H29 : subset (NFVs n1) (NFVs n1)
  H30 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  ============================
   {L' n1 |- of (abs (M n1)) (arr T1 T2)}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1600"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)).</b>
</pre>
<a name="1601"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert sctx' (of n4 T1 :: L' n1).</b>
</pre>
<a name="1602"></a>
<pre>
Subgoal 3.5.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   sctx' (of n4 T1 :: L' n1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply pruned_env_sctx to H1 _ H21.</b>
</pre>
<a name="1603"></a>
<pre>
Subgoal 3.5.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (L' n1)
  ============================
   sctx' (of n4 T1 :: L' n1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply sctx'_extend to H29 with x = n4, T = T1.</b>
</pre>
<a name="1604"></a>
<pre>
Subgoal 3.5.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (L' n1)
  H30 : sctx' (of n4 T1 :: L' n1)
  ============================
   sctx' (of n4 T1 :: L' n1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1605"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)).</b>
</pre>
<a name="1606"></a>
<pre>
Subgoal 3.5.5.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  ============================
   subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply equiv_closed_tm to H26.</b>
</pre>
<a name="1607"></a>
<pre>
Subgoal 3.5.5.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : {tm V1}
  ============================
   subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply equiv_val to H26.</b>
</pre>
<a name="1608"></a>
<pre>
Subgoal 3.5.5.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : {tm V1}
  H31 : {val V1}
  ============================
   subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply subst_extend to H2 H30 H31 with x = n4.</b>
</pre>
<a name="1609"></a>
<pre>
Subgoal 3.5.5.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : {tm V1}
  H31 : {val V1}
  H32 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  ============================
   subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1610"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)).</b>
</pre>
<a name="1611"></a>
<pre>
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply subst_equiv_closed_ctm to H23.</b>
</pre>
<a name="1612"></a>
<pre>
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply subst_equiv_cval to H23.</b>
</pre>
<a name="1613"></a>
<pre>
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert csubst cml_nil.</b>
</pre>
<a name="1614"></a>
<pre>
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  H33 : csubst cml_nil
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply csubst_extend to H33 H31 H32 with x = n6.</b>
</pre>
<a name="1615"></a>
<pre>
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  H33 : csubst cml_nil
  H34 : csubst (cml_cons (cmap n6 VE') cml_nil)
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply equiv_closed_ctm to H26.</b>
</pre>
<a name="1616"></a>
<pre>
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  H33 : csubst cml_nil
  H34 : csubst (cml_cons (cmap n6 VE') cml_nil)
  H35 : {ctm V1'}
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply equiv_cval to H26.</b>
</pre>
<a name="1617"></a>
<pre>
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  H33 : csubst cml_nil
  H34 : csubst (cml_cons (cmap n6 VE') cml_nil)
  H35 : {ctm V1'}
  H36 : {cval V1'}
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply csubst_extend to H34 H35 H36 with x = n5.</b>
</pre>
<a name="1618"></a>
<pre>
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  H33 : csubst cml_nil
  H34 : csubst (cml_cons (cmap n6 VE') cml_nil)
  H35 : {ctm V1'}
  H36 : {cval V1'}
  H37 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1619"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1).</b>
</pre>
<a name="1620"></a>
<pre>
Subgoal 3.5.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>unfold.</b>
</pre>
<a name="1621"></a>
<pre>
Subgoal 3.5.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   nabla x, app_subst (sml_cons (smap n1 V) ML) (M n1 V1) (ES1 V1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>intros.</b>
</pre>
<a name="1622"></a>
<pre>
Subgoal 3.5.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   app_subst (sml_cons (smap n1 V) ML) (M n1 V1) (ES1 V1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply equiv_closed_tm to H26.</b>
</pre>
<a name="1623"></a>
<pre>
Subgoal 3.5.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : {tm V1}
  ============================
   app_subst (sml_cons (smap n1 V) ML) (M n1 V1) (ES1 V1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply subst_inst to H32 H15.</b>
</pre>
<a name="1624"></a>
<pre>
Subgoal 3.5.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : {tm V1}
  H33 : app_subst (sml_cons (smap n1 V) ML) (M n1 V1) (ES1 V1)
  ============================
   app_subst (sml_cons (smap n1 V) ML) (M n1 V1) (ES1 V1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1625"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1').</b>
</pre>
<a name="1626"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply pruned_env_vars to H21.</b>
</pre>
<a name="1627"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply mapvar_prune to H13.</b>
</pre>
<a name="1628"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML' n2 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML' n2 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply mapvar_prune to H13.</b>
</pre>
<a name="1629"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert {L' n1, of n4 T1 |- of (M n1 n4) T2}.</b>
</pre>
<a name="1630"></a>
<pre>
Subgoal 3.5.5.6:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H27.</b>
</pre>
<a name="1631"></a>
<pre>
Subgoal 3.5.5.6.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n2 T1 |- of (M n1 n2) T2}
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5.6.2 is:
 {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1632"></a>
<pre>
Subgoal 3.5.5.6.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, [F n1] |- of (abs (M n1)) (arr T1 T2)}
  H36 : member (F n1) (L' n1)
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H29.</b>
</pre>
<a name="1633"></a>
<pre>
Subgoal 3.5.5.6.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, [F n1] |- of (abs (M n1)) (arr T1 T2)}
  H36 : member (F n1) (L' n1)
  H37 : sctx' (L' n1)
  H38 : tname n4
  H39 : forall T', member (of n4 T') (L' n1) -> T1 = T'
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply sctx'_mem to H37 H36.</b>
</pre>
<a name="1634"></a>
<pre>
Subgoal 3.5.5.6.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, F, X, T3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, [of (X n1) T3] |- of (abs (M n1)) (arr T1 T2)}
  H36 : member (of (X n1) T3) (L' n1)
  H37 : sctx' (L' n1)
  H38 : tname n4
  H39 : forall T', member (of n4 T') (L' n1) -> T1 = T'
  H40 : tname (X n1)
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H35.</b>
</pre>
<a name="1635"></a>
<pre>
Subgoal 3.5.5.6.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, F, X, T3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H36 : member (of (abs (M n1)) (arr T1 T2)) (L' n1)
  H37 : sctx' (L' n1)
  H38 : tname n4
  H39 : forall T', member (of n4 T') (L' n1) -> T1 = T'
  H40 : tname (abs (M n1))
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H40.</b>
</pre>
<a name="1636"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply IH to H29 H30 H31 H28 H34 H13 H35 H14 H32 H33.</b>
</pre>
<a name="1637"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H36 : sim T2 (ES1 V1) (ES'3 VE' V1')
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>case H36.</b>
</pre>
<a name="1638"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>unfold.</b>
</pre>
<a name="1639"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   exists V V', {eval (app (abs ES1) V1) V} /\
     {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'} /\
     equiv T2 V V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>exists V2.</b>
</pre>
<a name="1640"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   exists V', {eval (app (abs ES1) V1) V2} /\
     {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'} /\
     equiv T2 V2 V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>exists V'1.</b>
</pre>
<a name="1641"></a>
<pre>
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   {eval (app (abs ES1) V1) V2} /\
     {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1} /\
     equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>split.</b>
</pre>
<a name="1642"></a>
<pre>
Subgoal 3.5.5.7:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   {eval (app (abs ES1) V1) V2}

Subgoal 3.5.5.8 is:
 {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply equiv_val to H26.</b>
</pre>
<a name="1643"></a>
<pre>
Subgoal 3.5.5.7:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {val V1}
  ============================
   {eval (app (abs ES1) V1) V2}

Subgoal 3.5.5.8 is:
 {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply val_eval to H40.</b>
</pre>
<a name="1644"></a>
<pre>
Subgoal 3.5.5.7:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {val V1}
  H41 : {eval V1 V1}
  ============================
   {eval (app (abs ES1) V1) V2}

Subgoal 3.5.5.8 is:
 {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1645"></a>
<pre>
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply evalcc_val to H22.</b>
</pre>
<a name="1646"></a>
<pre>
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply val_evalcc to H40.</b>
</pre>
<a name="1647"></a>
<pre>
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply equiv_cval to H26.</b>
</pre>
<a name="1648"></a>
<pre>
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  H42 : {cval V1'}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>apply val_evalcc to H42.</b>
</pre>
<a name="1649"></a>
<pre>
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  H42 : {cval V1'}
  H43 : {evalcc V1' V1'}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}.</b>
</pre>
<a name="1650"></a>
<pre>
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  H42 : {cval V1'}
  H43 : {evalcc V1' V1'}
  H44 : {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert {evalcc (cross V1' VE') (cross V1' VE')}.</b>
</pre>
<a name="1651"></a>
<pre>
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  H42 : {cval V1'}
  H43 : {evalcc V1' V1'}
  H44 : {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}
  H45 : {evalcc (cross V1' VE') (cross V1' VE')}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>assert {evalcc (capp (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (cross V1' VE')) V'1}.</b>
</pre>
<a name="1652"></a>
<pre>
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  H42 : {cval V1'}
  H43 : {evalcc V1' V1'}
  H44 : {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}
  H45 : {evalcc (cross V1' VE') (cross V1' VE')}
  H46 : {evalcc (capp (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (cross V1' VE')) V'1}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1653"></a>
<pre>
Subgoal 3.5.5.9:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1654"></a>
<pre>
Subgoal 4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (app (M1 n1) (M2 n1)) T'}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  ============================
   sim T' ES ES'

eval_pres < <b>case H7.</b>
</pre>
<a name="1655"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  ============================
   sim T' ES ES'

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>apply subst_app to H9.</b>
</pre>
<a name="1656"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  ============================
   sim T' (app ES1 ES2) ES'

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>apply csubst_cunpair to H10.</b>
</pre>
<a name="1657"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>apply IH to H1 H2 H3 H4 H5 H6 H13 H11 H15 H17.</b>
</pre>
<a name="1658"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H19 : sim (arr T1 T') ES1 ES'1
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>apply IH to H1 H2 H3 H4 H5 H6 H14 H12 H16 H18.</b>
</pre>
<a name="1659"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H19 : sim (arr T1 T') ES1 ES'1
  H20 : sim T1 ES2 ES'2
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>case H19.</b>
</pre>
<a name="1660"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H20 : sim T1 ES2 ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H23 : equiv (arr T1 T') V1 V'1
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>case H20.</b>
</pre>
<a name="1661"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H23 : equiv (arr T1 T') V1 V'1
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>case H23.</b>
</pre>
<a name="1662"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>apply H31 to H26.</b>
</pre>
<a name="1663"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H32 : sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V'2 env)))
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>case H32.</b>
</pre>
<a name="1664"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H34 : {evalcc (cunpair V'1 (f\env\capp f (cross V'2 env))) V'3}
  H35 : equiv T' V3 V'3
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>case H34.</b>
</pre>
<a name="1665"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>unfold.</b>
</pre>
<a name="1666"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   exists V V', {eval (app ES1 ES2) V} /\
     {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'} /\
     equiv T' V V'

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>exists V3.</b>
</pre>
<a name="1667"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   exists V', {eval (app ES1 ES2) V3} /\
     {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'} /\
     equiv T' V3 V'

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>exists V'3.</b>
</pre>
<a name="1668"></a>
<pre>
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   {eval (app ES1 ES2) V3} /\
     {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3} /\
     equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>split.</b>
</pre>
<a name="1669"></a>
<pre>
Subgoal 4.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   {eval (app ES1 ES2) V3}

Subgoal 4.1.2 is:
 {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3}

Subgoal 4.1.3 is:
 equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>apply eval_app_trans to H21 H24 H33.</b>
</pre>
<a name="1670"></a>
<pre>
Subgoal 4.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  H38 : {eval (app ES1 ES2) V3}
  ============================
   {eval (app ES1 ES2) V3}

Subgoal 4.1.2 is:
 {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3}

Subgoal 4.1.3 is:
 equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1671"></a>
<pre>
Subgoal 4.1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3}

Subgoal 4.1.3 is:
 equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>apply evalcc_trans to H22 H36.</b>
</pre>
<a name="1672"></a>
<pre>
Subgoal 4.1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  H38 : {evalcc ES'1 (cpair F E1)}
  ============================
   {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3}

Subgoal 4.1.3 is:
 equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>apply evalcc_capp_trans to H25 H37.</b>
</pre>
<a name="1673"></a>
<pre>
Subgoal 4.1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  H38 : {evalcc ES'1 (cpair F E1)}
  H39 : {evalcc (capp F (cross ES'2 E1)) V'3}
  ============================
   {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3}

Subgoal 4.1.3 is:
 equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1674"></a>
<pre>
Subgoal 4.1.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < <b>search.</b>
</pre>
<a name="1675"></a>
<pre>
Subgoal 4.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T, [F n1] |- of (app (M1 n1) (M2 n1)) T'}
  H14 : member (F n1) (of n1 T :: L)
  ============================
   sim T' ES ES'

eval_pres < <b>apply sctx'_mem to H1 H14.</b>
</pre>
<a name="1676"></a>
<pre>
Subgoal 4.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, F, X, T1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T, [of (X n1) T1] |- of (app (M1 n1) (M2 n1)) T'}
  H14 : member (of (X n1) T1) (of n1 T :: L)
  H15 : tname (X n1)
  ============================
   sim T' ES ES'

eval_pres < <b>case H14.</b>
</pre>
<a name="1677"></a>
<pre>
Subgoal 4.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, F, X, T1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T, [of n1 T] |- of (app (M1 n1) (M2 n1)) T'}
  H15 : tname n1
  ============================
   sim T' ES ES'

Subgoal 4.2.2 is:
 sim T' ES ES'

eval_pres < <b>case H13.</b>
</pre>
<a name="1678"></a>
<pre>
Subgoal 4.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, F, X, T1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T, [of (X n1) T1] |- of (app (M1 n1) (M2 n1)) T'}
  H15 : tname (X n1)
  H16 : member (of (X n1) T1) L
  ============================
   sim T' ES ES'

eval_pres < <b>case H13.</b>
</pre>
<a name="1679"></a>
<pre>
Subgoal 4.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, F, X, T1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H15 : tname (app (M1 n1) (M2 n1))
  H16 : member (of (app (M1 n1) (M2 n1)) T') L
  ============================
   sim T' ES ES'

eval_pres < <b>case H15.</b>
Proof completed.
</pre>
<a name="1680"></a>
<pre class="code">
Abella < <b>Theorem fvars_extend : 
forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs} ->
  {L |- fvars M (tl_cons x FVs) NFVs}.</b>
</pre>
<a name="1681"></a>
<pre>


  ============================
   forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs} ->
     {L |- fvars M (tl_cons x FVs) NFVs}

fvars_extend < <b>induction on 2.</b>
</pre>
<a name="1682"></a>
<pre>


  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  ============================
   forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}@ ->
     {L |- fvars M (tl_cons x FVs) NFVs}

fvars_extend < <b>intros.</b>
</pre>
<a name="1683"></a>
<pre>

  Variables: L, M, FVs, NFVs
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H2 : {L |- fvars M FVs NFVs}@
  ============================
   {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < <b>case H2.</b>
</pre>
<a name="1684"></a>
<pre>
Subgoal 1:

  Variables: L, M, FVs, NFVs
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L |- notfree M}*
  ============================
   {L |- fvars M (tl_cons n1 FVs) tl_nil}

Subgoal 2 is:
 {L |- fvars (lnat X) (tl_cons n1 FVs) tl_nil}

Subgoal 3 is:
 {L |- fvars M (tl_cons n1 FVs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < <b>search.</b>
</pre>
<a name="1685"></a>
<pre>
Subgoal 2:

  Variables: L, M, FVs, NFVs, X
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  ============================
   {L |- fvars (lnat X) (tl_cons n1 FVs) tl_nil}

Subgoal 3 is:
 {L |- fvars M (tl_cons n1 FVs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < <b>search.</b>
</pre>
<a name="1686"></a>
<pre>
Subgoal 3:

  Variables: L, M, FVs, NFVs
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L |- tl_member M FVs}*
  ============================
   {L |- fvars M (tl_cons n1 FVs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < <b>search.</b>
</pre>
<a name="1687"></a>
<pre>
Subgoal 4:

  Variables: L, M, FVs, NFVs, Fvs2, Fvs1, M2, M1
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L |- fvars M1 FVs Fvs1}*
  H4 : {L |- fvars M2 FVs Fvs2}*
  H5 : {L |- combine Fvs1 Fvs2 NFVs}*
  ============================
   {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < <b>apply IH to H1 H3.</b>
</pre>
<a name="1688"></a>
<pre>
Subgoal 4:

  Variables: L, M, FVs, NFVs, Fvs2, Fvs1, M2, M1
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L |- fvars M1 FVs Fvs1}*
  H4 : {L |- fvars M2 FVs Fvs2}*
  H5 : {L |- combine Fvs1 Fvs2 NFVs}*
  H6 : {L |- fvars M1 (tl_cons n1 FVs) Fvs1}
  ============================
   {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < <b>apply IH to H1 H4.</b>
</pre>
<a name="1689"></a>
<pre>
Subgoal 4:

  Variables: L, M, FVs, NFVs, Fvs2, Fvs1, M2, M1
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L |- fvars M1 FVs Fvs1}*
  H4 : {L |- fvars M2 FVs Fvs2}*
  H5 : {L |- combine Fvs1 Fvs2 NFVs}*
  H6 : {L |- fvars M1 (tl_cons n1 FVs) Fvs1}
  H7 : {L |- fvars M2 (tl_cons n1 FVs) Fvs2}
  ============================
   {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < <b>search.</b>
</pre>
<a name="1690"></a>
<pre>
Subgoal 5:

  Variables: L, M, FVs, NFVs, M1
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L, notfree n1 |- fvars (M1 n1) FVs NFVs}*
  ============================
   {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < <b>apply IH to _ H3.</b>
</pre>
<a name="1691"></a>
<pre>
Subgoal 5:

  Variables: L, M, FVs, NFVs, M1
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L, notfree n1 |- fvars (M1 n1) FVs NFVs}*
  H4 : {L, notfree n1 |- fvars (M1 n1) (tl_cons n2 FVs) NFVs}
  ============================
   {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < <b>search.</b>
</pre>
<a name="1692"></a>
<pre>
Subgoal 6:

  Variables: L, M, FVs, NFVs, F
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L, [F] |- fvars M FVs NFVs}*
  H4 : member F L
  ============================
   {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="1693"></a>
<pre>
Subgoal 6:

  Variables: L, M, FVs, NFVs, F, X
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L, [notfree X] |- fvars M FVs NFVs}*
  H4 : member (notfree X) L
  H5 : tname X
  ============================
   {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < <b>case H3.</b>
Proof completed.
</pre>
<a name="1694"></a>
<pre class="code">
Abella < <b>Theorem mapenv_extend : 
forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE} ->
  {mapenv NFVs (ml_cons (map x y) Map) PE}.</b>
</pre>
<a name="1695"></a>
<pre>


  ============================
   forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE} ->
     {mapenv NFVs (ml_cons (map x y) Map) PE}

mapenv_extend < <b>induction on 1.</b>
</pre>
<a name="1696"></a>
<pre>


  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  ============================
   forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}@ ->
     {mapenv NFVs (ml_cons (map x y) Map) PE}

mapenv_extend < <b>intros.</b>
</pre>
<a name="1697"></a>
<pre>

  Variables: NFVs, Map, PE
  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  H1 : {mapenv NFVs Map PE}@
  ============================
   {mapenv NFVs (ml_cons (map n1 n2) Map) PE}

mapenv_extend < <b>case H1.</b>
</pre>
<a name="1698"></a>
<pre>
Subgoal 1:

  Variables: NFVs, Map, PE
  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  ============================
   {mapenv tl_nil (ml_cons (map n1 n2) Map) unit}

Subgoal 2 is:
 {mapenv (tl_cons X L) (ml_cons (map n1 n2) Map) (cross M ML)}

mapenv_extend < <b>search.</b>
</pre>
<a name="1699"></a>
<pre>
Subgoal 2:

  Variables: NFVs, Map, PE, ML, L, M, X
  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  H2 : {ml_member (map X M) Map}*
  H3 : {mapenv L Map ML}*
  ============================
   {mapenv (tl_cons X L) (ml_cons (map n1 n2) Map) (cross M ML)}

mapenv_extend < <b>assert {ml_member (map X M) (ml_cons (map n1 n2) Map)}.</b>
</pre>
<a name="1700"></a>
<pre>
Subgoal 2:

  Variables: NFVs, Map, PE, ML, L, M, X
  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  H2 : {ml_member (map X M) Map}*
  H3 : {mapenv L Map ML}*
  H4 : {ml_member (map X M) (ml_cons (map n1 n2) Map)}
  ============================
   {mapenv (tl_cons X L) (ml_cons (map n1 n2) Map) (cross M ML)}

mapenv_extend < <b>apply IH to H3.</b>
</pre>
<a name="1701"></a>
<pre>
Subgoal 2:

  Variables: NFVs, Map, PE, ML, L, M, X
  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  H2 : {ml_member (map X M) Map}*
  H3 : {mapenv L Map ML}*
  H4 : {ml_member (map X M) (ml_cons (map n1 n2) Map)}
  H5 : {mapenv L (ml_cons (map n1 n2) Map) ML}
  ============================
   {mapenv (tl_cons X L) (ml_cons (map n1 n2) Map) (cross M ML)}

mapenv_extend < <b>search.</b>
Proof completed.
</pre>
<a name="1702"></a>
<pre class="code">
Abella < <b>Theorem cc_extend_map : 
forall E E' Map FVs, nabla x y, {cc E E' Map FVs} ->
  {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}.</b>
</pre>
<a name="1703"></a>
<pre>


  ============================
   forall E E' Map FVs, nabla x y, {cc E E' Map FVs} ->
     {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}

cc_extend_map < <b>induction on 1.</b>
</pre>
<a name="1704"></a>
<pre>


  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  ============================
   forall E E' Map FVs, nabla x y, {cc E E' Map FVs}@ ->
     {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}

cc_extend_map < <b>intros.</b>
</pre>
<a name="1705"></a>
<pre>

  Variables: E, E', Map, FVs
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H1 : {cc E E' Map FVs}@
  ============================
   {cc E E' (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < <b>case H1.</b>
</pre>
<a name="1706"></a>
<pre>
Subgoal 1:

  Variables: E, E', Map, FVs
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {ml_member (map E E') Map}*
  ============================
   {cc E E' (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 2 is:
 {cc (lnat N) (clnat N) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 3 is:
 {cc (abs M) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 4 is:
 {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < <b>search.</b>
</pre>
<a name="1707"></a>
<pre>
Subgoal 2:

  Variables: E, E', Map, FVs, N
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  ============================
   {cc (lnat N) (clnat N) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 3 is:
 {cc (abs M) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 4 is:
 {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < <b>search.</b>
</pre>
<a name="1708"></a>
<pre>
Subgoal 3:

  Variables: E, E', Map, FVs, NFVs, NMap, P, M, PE
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {fvars (abs M) FVs NFVs}*
  H3 : {mapenv NFVs Map PE}*
  H4 : {mapvar NFVs NMap}*
  H5 : {cc (M n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  ============================
   {cc (abs M) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 4 is:
 {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < <b>apply fvars_extend to _ H2 with x = n1.</b>
</pre>
<a name="1709"></a>
<pre>
Subgoal 3:

  Variables: E, E', Map, FVs, NFVs, NMap, P, M, PE
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {fvars (abs M) FVs NFVs}*
  H3 : {mapenv NFVs Map PE}*
  H4 : {mapvar NFVs NMap}*
  H5 : {cc (M n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H6 : {fvars (abs M) (tl_cons n1 FVs) NFVs}
  ============================
   {cc (abs M) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 4 is:
 {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < <b>apply mapenv_extend to H3 with x = n1, y = n2.</b>
</pre>
<a name="1710"></a>
<pre>
Subgoal 3:

  Variables: E, E', Map, FVs, NFVs, NMap, P, M, PE
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {fvars (abs M) FVs NFVs}*
  H3 : {mapenv NFVs Map PE}*
  H4 : {mapvar NFVs NMap}*
  H5 : {cc (M n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H6 : {fvars (abs M) (tl_cons n1 FVs) NFVs}
  H7 : {mapenv NFVs (ml_cons (map n1 n2) Map) PE}
  ============================
   {cc (abs M) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 4 is:
 {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < <b>search.</b>
</pre>
<a name="1711"></a>
<pre>
Subgoal 4:

  Variables: E, E', Map, FVs, CM2, M2, CM1, M1
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {cc M1 CM1 Map FVs}*
  H3 : {cc M2 CM2 Map FVs}*
  ============================
   {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < <b>apply IH to H2.</b>
</pre>
<a name="1712"></a>
<pre>
Subgoal 4:

  Variables: E, E', Map, FVs, CM2, M2, CM1, M1
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {cc M1 CM1 Map FVs}*
  H3 : {cc M2 CM2 Map FVs}*
  H4 : {cc M1 CM1 (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}
  ============================
   {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < <b>apply IH to H3.</b>
</pre>
<a name="1713"></a>
<pre>
Subgoal 4:

  Variables: E, E', Map, FVs, CM2, M2, CM1, M1
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {cc M1 CM1 Map FVs}*
  H3 : {cc M2 CM2 Map FVs}*
  H4 : {cc M1 CM1 (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}
  H5 : {cc M2 CM2 (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}
  ============================
   {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < <b>search.</b>
Proof completed.
</pre>
<a name="1714"></a>
<pre class="code">
Abella < <b>Theorem base_eval_pres : 
forall E E', {of E nat_t} -> {cc E E' ml_nil tl_nil} -> (exists N,
  {eval E (lnat N)} /\ {evalcc E' (clnat N)}).</b>
</pre>
<a name="1715"></a>
<pre>


  ============================
   forall E E', {of E nat_t} -> {cc E E' ml_nil tl_nil} -> (exists N,
     {eval E (lnat N)} /\ {evalcc E' (clnat N)})

base_eval_pres < <b>intros.</b>
</pre>
<a name="1716"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert sctx' (of n1 nat_t :: nil).</b>
</pre>
<a name="1717"></a>
<pre>
Subgoal 1:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  ============================
   sctx' (of n1 nat_t :: nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert sctx' nil.</b>
</pre>
<a name="1718"></a>
<pre>
Subgoal 1:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' nil
  ============================
   sctx' (of n1 nat_t :: nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>apply sctx'_extend to H3 with x = n1, T = nat_t.</b>
</pre>
<a name="1719"></a>
<pre>
Subgoal 1:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' nil
  H4 : sctx' (of n1 nat_t :: nil)
  ============================
   sctx' (of n1 nat_t :: nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>search.</b>
</pre>
<a name="1720"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert subst (sml_cons (smap n1 (lnat z)) sml_nil).</b>
</pre>
<a name="1721"></a>
<pre>
Subgoal 2:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  ============================
   subst (sml_cons (smap n1 (lnat z)) sml_nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert subst sml_nil.</b>
</pre>
<a name="1722"></a>
<pre>
Subgoal 2:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst sml_nil
  ============================
   subst (sml_cons (smap n1 (lnat z)) sml_nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert {tm (lnat z)}.</b>
</pre>
<a name="1723"></a>
<pre>
Subgoal 2:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst sml_nil
  H5 : {tm (lnat z)}
  ============================
   subst (sml_cons (smap n1 (lnat z)) sml_nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert {val (lnat z)}.</b>
</pre>
<a name="1724"></a>
<pre>
Subgoal 2:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst sml_nil
  H5 : {tm (lnat z)}
  H6 : {val (lnat z)}
  ============================
   subst (sml_cons (smap n1 (lnat z)) sml_nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>apply subst_extend to H4 H5 H6.</b>
</pre>
<a name="1725"></a>
<pre>
Subgoal 2:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst sml_nil
  H5 : {tm (lnat z)}
  H6 : {val (lnat z)}
  H7 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  ============================
   subst (sml_cons (smap n1 (lnat z)) sml_nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>search.</b>
</pre>
<a name="1726"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)).</b>
</pre>
<a name="1727"></a>
<pre>
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert csubst cml_nil.</b>
</pre>
<a name="1728"></a>
<pre>
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert {ctm unit}.</b>
</pre>
<a name="1729"></a>
<pre>
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert {cval unit}.</b>
</pre>
<a name="1730"></a>
<pre>
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  H7 : {cval unit}
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>apply csubst_extend to H5 H6 H7.</b>
</pre>
<a name="1731"></a>
<pre>
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  H7 : {cval unit}
  H8 : csubst (cml_cons (cmap n1 unit) cml_nil)
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert {ctm (clnat z)}.</b>
</pre>
<a name="1732"></a>
<pre>
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  H7 : {cval unit}
  H8 : csubst (cml_cons (cmap n1 unit) cml_nil)
  H9 : {ctm (clnat z)}
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert {cval (clnat z)}.</b>
</pre>
<a name="1733"></a>
<pre>
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  H7 : {cval unit}
  H8 : csubst (cml_cons (cmap n1 unit) cml_nil)
  H9 : {ctm (clnat z)}
  H10 : {cval (clnat z)}
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>apply csubst_extend to H8 H9 H10.</b>
</pre>
<a name="1734"></a>
<pre>
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  H7 : {cval unit}
  H8 : csubst (cml_cons (cmap n1 unit) cml_nil)
  H9 : {ctm (clnat z)}
  H10 : {cval (clnat z)}
  H11 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n1 unit) cml_nil))
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>search.</b>
</pre>
<a name="1735"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)).</b>
</pre>
<a name="1736"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert vars_of_sctx nil tl_nil.</b>
</pre>
<a name="1737"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert {mapvar tl_nil (x\ml_nil)}.</b>
</pre>
<a name="1738"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert {of n1 nat_t |- of E nat_t}.</b>
</pre>
<a name="1739"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>apply cc_extend_map to H2 with x = n1, y = n2.</b>
</pre>
<a name="1740"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E.</b>
</pre>
<a name="1741"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  H11 : app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>assert app_csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)) E' E'.</b>
</pre>
<a name="1742"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  H11 : app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E
  H12 : app_csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)) E' E'
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>apply eval_pres to H3 H4 H5 H6 H7 H8 H9 H10 H11 H12.</b>
</pre>
<a name="1743"></a>
<pre>

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  H11 : app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E
  H12 : app_csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)) E' E'
  H13 : sim nat_t E E'
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>case H13.</b>
</pre>
<a name="1744"></a>
<pre>

  Variables: E, E', V, V'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  H11 : app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E
  H12 : app_csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)) E' E'
  H14 : {eval E V}
  H15 : {evalcc E' V'}
  H16 : equiv nat_t V V'
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>case H16.</b>
</pre>
<a name="1745"></a>
<pre>

  Variables: E, E', V, V', N
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  H11 : app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E
  H12 : app_csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)) E' E'
  H14 : {eval E (lnat N)}
  H15 : {evalcc E' (clnat N)}
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < <b>search.</b>
Proof completed.
</pre>
<a name="1746"></a>
<pre class="code">
Abella < Goodbye.
</pre>
</div>

</body>
</html>
