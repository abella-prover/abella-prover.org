Welcome to Abella 2.0.2-dev
Abella < Specification "cc".
Reading specification "cc"

Abella < Close const, nat, tm, ctm, ty.

Abella < Define tname : tm -> prop by 
nabla n, tname n.

Abella < Theorem mem_of_absurd : 
forall T L, nabla x, member (of x T) L -> false.


  ============================
   forall T L, nabla x, member (of x T) L -> false

mem_of_absurd < induction on 1.


  IH : forall T L, nabla x, member (of x T) L * -> false
  ============================
   forall T L, nabla x, member (of x T) L @ -> false

mem_of_absurd < intros.

  Variables: T, L
  IH : forall T L, nabla x, member (of x T) L * -> false
  H1 : member (of n1 T) L @
  ============================
   false

mem_of_absurd < case H1.

  Variables: T, L, L3, L2
  IH : forall T L, nabla x, member (of x T) L * -> false
  H2 : member (of n1 T) L3 *
  ============================
   false

mem_of_absurd < apply IH to H2.
Proof completed.

Abella < Theorem ml_mem_absurd : 
forall M ML, nabla x, {ml_member (map x M) ML} -> false.


  ============================
   forall M ML, nabla x, {ml_member (map x M) ML} -> false

ml_mem_absurd < induction on 1.


  IH : forall M ML, nabla x, {ml_member (map x M) ML}* -> false
  ============================
   forall M ML, nabla x, {ml_member (map x M) ML}@ -> false

ml_mem_absurd < intros.

  Variables: M, ML
  IH : forall M ML, nabla x, {ml_member (map x M) ML}* -> false
  H1 : {ml_member (map n1 M) ML}@
  ============================
   false

ml_mem_absurd < case H1.

  Variables: M, ML, ML2, ML1
  IH : forall M ML, nabla x, {ml_member (map x M) ML}* -> false
  H2 : {ml_member (map n1 M) ML2}*
  ============================
   false

ml_mem_absurd < apply IH to H2.
Proof completed.

Abella < Define sctx : olist -> prop by 
sctx nil;
nabla x, sctx (of x T :: L) := sctx L.

Abella < Define sctx' : olist -> prop by 
sctx' nil;
sctx' (of X T :: L) := sctx' L /\ tname X /\ (forall T', member (of X T') L -> T = T').

Abella < Theorem sctx'_name : 
forall X T L, sctx' L -> member (of X T) L -> tname X.


  ============================
   forall X T L, sctx' L -> member (of X T) L -> tname X

sctx'_name < induction on 1.


  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  ============================
   forall X T L, sctx' L @ -> member (of X T) L -> tname X

sctx'_name < intros.

  Variables: X, T, L
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H1 : sctx' L @
  H2 : member (of X T) L
  ============================
   tname X

sctx'_name < case H1.
Subgoal 1:

  Variables: X, T, L
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H2 : member (of X T) nil
  ============================
   tname X

Subgoal 2 is:
 tname X

sctx'_name < case H2.
Subgoal 2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H2 : member (of X T) (of X1 T1 :: L1)
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   tname X

sctx'_name < case H2.
Subgoal 2.1:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

sctx'_name < search.
Subgoal 2.2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  H6 : member (of X T) L1
  ============================
   tname X

sctx'_name < apply IH to H3 H6.
Subgoal 2.2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  H6 : member (of X T) L1
  H7 : tname X
  ============================
   tname X

sctx'_name < search.
Proof completed.

Abella < Theorem sctx'_mem : 
forall SL O, sctx' SL -> member O SL -> (exists X T, O = of X T /\ tname X).


  ============================
   forall SL O, sctx' SL -> member O SL -> (exists X T, O = of X T /\
     tname X)

sctx'_mem < induction on 1.


  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  ============================
   forall SL O, sctx' SL @ -> member O SL -> (exists X T, O = of X T /\
     tname X)

sctx'_mem < intros.

  Variables: SL, O
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H1 : sctx' SL @
  H2 : member O SL
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < case H1.
Subgoal 1:

  Variables: SL, O
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H2 : member O nil
  ============================
   exists X T, O = of X T /\ tname X

Subgoal 2 is:
 exists X T, O = of X T /\ tname X

sctx'_mem < case H2.
Subgoal 2:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H2 : member O (of X T :: L)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < case H2.
Subgoal 2.1:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  ============================
   exists X1 T1, of X T = of X1 T1 /\ tname X1

Subgoal 2.2 is:
 exists X T, O = of X T /\ tname X

sctx'_mem < search.
Subgoal 2.2:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  H6 : member O L
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < apply IH to H3 H6.
Subgoal 2.2:

  Variables: SL, O, L, T, X, X1, T1
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  H6 : member (of X1 T1) L
  H7 : tname X1
  ============================
   exists X T, of X1 T1 = of X T /\ tname X

sctx'_mem < search.
Proof completed.

Abella < Theorem sctx'_extend : 
forall L T, nabla x, sctx' L -> sctx' (of x T :: L).


  ============================
   forall L T, nabla x, sctx' L -> sctx' (of x T :: L)

sctx'_extend < intros.

  Variables: L, T
  H1 : sctx' L
  ============================
   sctx' (of n1 T :: L)

sctx'_extend < unfold.
Subgoal 1:

  Variables: L, T
  H1 : sctx' L
  ============================
   sctx' L

Subgoal 2 is:
 tname n1

Subgoal 3 is:
 forall T', member (of n1 T') L -> T = T'

sctx'_extend < search.
Subgoal 2:

  Variables: L, T
  H1 : sctx' L
  ============================
   tname n1

Subgoal 3 is:
 forall T', member (of n1 T') L -> T = T'

sctx'_extend < search.
Subgoal 3:

  Variables: L, T
  H1 : sctx' L
  ============================
   forall T', member (of n1 T') L -> T = T'

sctx'_extend < intros.
Subgoal 3:

  Variables: L, T, T'
  H1 : sctx' L
  H2 : member (of n1 T') L
  ============================
   T = T'

sctx'_extend < apply mem_of_absurd to H2.
Proof completed.

Abella < Theorem sctx'_equal : 
forall X T T' L, sctx' L -> member (of X T) L -> member (of X T') L -> T = T'.


  ============================
   forall X T T' L, sctx' L -> member (of X T) L -> member (of X T') L ->
     T = T'

sctx'_equal < induction on 1.


  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  ============================
   forall X T T' L, sctx' L @ -> member (of X T) L -> member (of X T') L ->
     T = T'

sctx'_equal < intros.

  Variables: X, T, T', L
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H1 : sctx' L @
  H2 : member (of X T) L
  H3 : member (of X T') L
  ============================
   T = T'

sctx'_equal < case H1.
Subgoal 1:

  Variables: X, T, T', L
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H2 : member (of X T) nil
  H3 : member (of X T') nil
  ============================
   T = T'

Subgoal 2 is:
 T = T'

sctx'_equal < case H2.
Subgoal 2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H2 : member (of X T) (of X1 T1 :: L1)
  H3 : member (of X T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T = T'

sctx'_equal < case H2.
Subgoal 2.1:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H3 : member (of X1 T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < case H3.
Subgoal 2.1.1:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T1 = T1

Subgoal 2.1.2 is:
 T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < search.
Subgoal 2.1.2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X1 T') L1
  ============================
   T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < apply H6 to H7.
Subgoal 2.1.2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T'1, member (of X1 T'1) L1 -> T' = T'1
  H7 : member (of X1 T') L1
  ============================
   T' = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < search.
Subgoal 2.2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H3 : member (of X T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T) L1
  ============================
   T = T'

sctx'_equal < case H3.
Subgoal 2.2.1:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X1 T) L1
  ============================
   T = T1

Subgoal 2.2.2 is:
 T = T'

sctx'_equal < apply H6 to H7.
Subgoal 2.2.1:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  H7 : member (of X1 T) L1
  ============================
   T = T

Subgoal 2.2.2 is:
 T = T'

sctx'_equal < search.
Subgoal 2.2.2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T) L1
  H8 : member (of X T') L1
  ============================
   T = T'

sctx'_equal < apply IH to H4 H7 H8.
Subgoal 2.2.2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T') L1
  H8 : member (of X T') L1
  ============================
   T' = T'

sctx'_equal < search.
Proof completed.

Abella < Theorem of_const_sctx' : 
forall L C T, sctx' L -> {L |- of_const C T} -> {of_const C T}.


  ============================
   forall L C T, sctx' L -> {L |- of_const C T} -> {of_const C T}

of_const_sctx' < induction on 2.


  IH : forall L C T, sctx' L -> {L |- of_const C T}* -> {of_const C T}
  ============================
   forall L C T, sctx' L -> {L |- of_const C T}@ -> {of_const C T}

of_const_sctx' < intros.

  Variables: L, C, T
  IH : forall L C T, sctx' L -> {L |- of_const C T}* -> {of_const C T}
  H1 : sctx' L
  H2 : {L |- of_const C T}@
  ============================
   {of_const C T}

of_const_sctx' < case H2.
Subgoal 1:

  Variables: L, C, T
  IH : forall L C T, sctx' L -> {L |- of_const C T}* -> {of_const C T}
  H1 : sctx' L
  ============================
   {of_const s++ (arr nat_t (arr nat_t nat_t))}

Subgoal 2 is:
 {of_const C T}

of_const_sctx' < search.
Subgoal 2:

  Variables: L, C, T, F
  IH : forall L C T, sctx' L -> {L |- of_const C T}* -> {of_const C T}
  H1 : sctx' L
  H3 : {L, [F] |- of_const C T}*
  H4 : member F L
  ============================
   {of_const C T}

of_const_sctx' < apply sctx'_mem to H1 H4.
Subgoal 2:

  Variables: L, C, T, F, X, T1
  IH : forall L C T, sctx' L -> {L |- of_const C T}* -> {of_const C T}
  H1 : sctx' L
  H3 : {L, [of X T1] |- of_const C T}*
  H4 : member (of X T1) L
  H5 : tname X
  ============================
   {of_const C T}

of_const_sctx' < case H3.
Proof completed.

Abella < Theorem presv_const_typ : 
forall C T, {of_const C T} -> {cof_const C T}.


  ============================
   forall C T, {of_const C T} -> {cof_const C T}

presv_const_typ < induction on 1.


  IH : forall C T, {of_const C T}* -> {cof_const C T}
  ============================
   forall C T, {of_const C T}@ -> {cof_const C T}

presv_const_typ < intros.

  Variables: C, T
  IH : forall C T, {of_const C T}* -> {cof_const C T}
  H1 : {of_const C T}@
  ============================
   {cof_const C T}

presv_const_typ < case H1.

  Variables: C, T
  IH : forall C T, {of_const C T}* -> {cof_const C T}
  ============================
   {cof_const s++ (arr nat_t (arr nat_t nat_t))}

presv_const_typ < search.
Proof completed.

Abella < Define vars_of_sctx : olist -> tm_list -> prop by 
vars_of_sctx nil tl_nil;
vars_of_sctx (of X T :: L) (tl_cons X Vs) := vars_of_sctx L Vs.

Abella < Define cctx : olist -> prop by 
cctx nil;
nabla x, cctx (cof x T :: L) := cctx L;
nabla f env, cctx (cof f (code (product T1 TE) T) :: cof env TE :: L) := cctx L.

Abella < Define of_ml : olist -> map_list -> olist -> prop by 
of_ml CL ml_nil nil;
of_ml CL (ml_cons (map X M) ML) (of X T :: SL) := tname X /\ {CL |- cof M T} /\ of_ml CL ML SL.

Abella < Theorem of_ml_exists : 
forall CL ML SL X M, of_ml CL ML SL -> {ml_member (map X M) ML} -> (exists T,
  member (of X T) SL).


  ============================
   forall CL ML SL X M, of_ml CL ML SL -> {ml_member (map X M) ML} ->
     (exists T, member (of X T) SL)

of_ml_exists < induction on 1.


  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  ============================
   forall CL ML SL X M, of_ml CL ML SL @ -> {ml_member (map X M) ML} ->
     (exists T, member (of X T) SL)

of_ml_exists < intros.

  Variables: CL, ML, SL, X, M
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H1 : of_ml CL ML SL @
  H2 : {ml_member (map X M) ML}
  ============================
   exists T, member (of X T) SL

of_ml_exists < case H1.
Subgoal 1:

  Variables: CL, ML, SL, X, M
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H2 : {ml_member (map X M) ml_nil}
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of X T1) (of X1 T :: SL1)

of_ml_exists < case H2.
Subgoal 2:

  Variables: CL, ML, SL, X, M, SL1, T, X1, ML1, M1
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H2 : {ml_member (map X M) (ml_cons (map X1 M1) ML1)}
  H3 : tname X1
  H4 : {CL |- cof M1 T}
  H5 : of_ml CL ML1 SL1 *
  ============================
   exists T1, member (of X T1) (of X1 T :: SL1)

of_ml_exists < case H2.
Subgoal 2.1:

  Variables: CL, ML, SL, X, M, SL1, T, X1, ML1, M1
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H3 : tname X1
  H4 : {CL |- cof M1 T}
  H5 : of_ml CL ML1 SL1 *
  ============================
   exists T1, member (of X1 T1) (of X1 T :: SL1)

Subgoal 2.2 is:
 exists T1, member (of X T1) (of X1 T :: SL1)

of_ml_exists < search.
Subgoal 2.2:

  Variables: CL, ML, SL, X, M, SL1, T, X1, ML1, M1
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H3 : tname X1
  H4 : {CL |- cof M1 T}
  H5 : of_ml CL ML1 SL1 *
  H6 : {ml_member (map X M) ML1}
  ============================
   exists T1, member (of X T1) (of X1 T :: SL1)

of_ml_exists < apply IH to H5 H6.
Subgoal 2.2:

  Variables: CL, ML, SL, X, M, SL1, T, X1, ML1, M1, T1
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H3 : tname X1
  H4 : {CL |- cof M1 T}
  H5 : of_ml CL ML1 SL1 *
  H6 : {ml_member (map X M) ML1}
  H7 : member (of X T1) SL1
  ============================
   exists T1, member (of X T1) (of X1 T :: SL1)

of_ml_exists < search.
Proof completed.

Abella < Theorem of_ml_member_type : 
forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL ->
  {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}.


  ============================
   forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL ->
     {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}

of_ml_member_type < induction on 2.


  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  ============================
   forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL @ ->
     {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}

of_ml_member_type < intros.

  Variables: CL, Map, SL, X, M, T
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' SL
  H2 : of_ml CL Map SL @
  H3 : {ml_member (map X M) Map}
  H4 : member (of X T) SL
  ============================
   {CL |- cof M T}

of_ml_member_type < case H2.
Subgoal 1:

  Variables: CL, Map, SL, X, M, T
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' nil
  H3 : {ml_member (map X M) ml_nil}
  H4 : member (of X T) nil
  ============================
   {CL |- cof M T}

Subgoal 2 is:
 {CL |- cof M T}

of_ml_member_type < case H4.
Subgoal 2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H3 : {ml_member (map X M) (ml_cons (map X1 M1) ML)}
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  ============================
   {CL |- cof M T}

of_ml_member_type < case H1 (keep).
Subgoal 2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H3 : {ml_member (map X M) (ml_cons (map X1 M1) ML)}
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  ============================
   {CL |- cof M T}

of_ml_member_type < case H3.
Subgoal 2.1:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X1 T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  ============================
   {CL |- cof M1 T}

Subgoal 2.2 is:
 {CL |- cof M T}

of_ml_member_type < case H4.
Subgoal 2.1.1:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  ============================
   {CL |- cof M1 T1}

Subgoal 2.1.2 is:
 {CL |- cof M1 T}

Subgoal 2.2 is:
 {CL |- cof M T}

of_ml_member_type < search.
Subgoal 2.1.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : member (of X1 T) SL1
  ============================
   {CL |- cof M1 T}

Subgoal 2.2 is:
 {CL |- cof M T}

of_ml_member_type < apply H10 to H11.
Subgoal 2.1.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T = T'
  H11 : member (of X1 T) SL1
  ============================
   {CL |- cof M1 T}

Subgoal 2.2 is:
 {CL |- cof M T}

of_ml_member_type < search.
Subgoal 2.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : {ml_member (map X M) ML}
  ============================
   {CL |- cof M T}

of_ml_member_type < apply of_ml_exists to H7 H11.
Subgoal 2.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1, T2
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : {ml_member (map X M) ML}
  H12 : member (of X T2) SL1
  ============================
   {CL |- cof M T}

of_ml_member_type < apply IH to H8 H7 H11 H12.
Subgoal 2.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1, T2
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : {ml_member (map X M) ML}
  H12 : member (of X T2) SL1
  H13 : {CL |- cof M T2}
  ============================
   {CL |- cof M T}

of_ml_member_type < assert member (of X T2) (of X1 T1 :: SL1).
Subgoal 2.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1, T2
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : {ml_member (map X M) ML}
  H12 : member (of X T2) SL1
  H13 : {CL |- cof M T2}
  H14 : member (of X T2) (of X1 T1 :: SL1)
  ============================
   {CL |- cof M T}

of_ml_member_type < apply sctx'_equal to H1 H4 H14.
Subgoal 2.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1, T2
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X T2) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : {ml_member (map X M) ML}
  H12 : member (of X T2) SL1
  H13 : {CL |- cof M T2}
  H14 : member (of X T2) (of X1 T1 :: SL1)
  ============================
   {CL |- cof M T2}

of_ml_member_type < search.
Proof completed.

Abella < Theorem map_name : 
forall SL CL M X Map, of_ml SL Map CL -> {ml_member (map X M) Map} -> tname X.


  ============================
   forall SL CL M X Map, of_ml SL Map CL -> {ml_member (map X M) Map} ->
     tname X

map_name < induction on 1.


  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  ============================
   forall SL CL M X Map, of_ml SL Map CL @ -> {ml_member (map X M) Map} ->
     tname X

map_name < intros.

  Variables: SL, CL, M, X, Map
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H1 : of_ml SL Map CL @
  H2 : {ml_member (map X M) Map}
  ============================
   tname X

map_name < case H1.
Subgoal 1:

  Variables: SL, CL, M, X, Map
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H2 : {ml_member (map X M) ml_nil}
  ============================
   tname X

Subgoal 2 is:
 tname X

map_name < case H2.
Subgoal 2:

  Variables: SL, CL, M, X, Map, SL1, T, X1, ML, M1
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H2 : {ml_member (map X M) (ml_cons (map X1 M1) ML)}
  H3 : tname X1
  H4 : {SL |- cof M1 T}
  H5 : of_ml SL ML SL1 *
  ============================
   tname X

map_name < case H2.
Subgoal 2.1:

  Variables: SL, CL, M, X, Map, SL1, T, X1, ML, M1
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H3 : tname X1
  H4 : {SL |- cof M1 T}
  H5 : of_ml SL ML SL1 *
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

map_name < search.
Subgoal 2.2:

  Variables: SL, CL, M, X, Map, SL1, T, X1, ML, M1
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H3 : tname X1
  H4 : {SL |- cof M1 T}
  H5 : of_ml SL ML SL1 *
  H6 : {ml_member (map X M) ML}
  ============================
   tname X

map_name < apply IH to H5 H6.
Subgoal 2.2:

  Variables: SL, CL, M, X, Map, SL1, T, X1, ML, M1
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H3 : tname X1
  H4 : {SL |- cof M1 T}
  H5 : of_ml SL ML SL1 *
  H6 : {ml_member (map X M) ML}
  H7 : tname X
  ============================
   tname X

map_name < search.
Proof completed.

Abella < Theorem map_rst : 
forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL ->
  of_ml (cof X (product T RT) :: nil) M SL.


  ============================
   forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL ->
     of_ml (cof X (product T RT) :: nil) M SL

map_rst < induction on 1.


  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  ============================
   forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL @ ->
     of_ml (cof X (product T RT) :: nil) M SL

map_rst < intros.

  Variables: M, SL, X, T, RT
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  H1 : of_ml (cof (rst X) RT :: nil) M SL @
  ============================
   of_ml (cof X (product T RT) :: nil) M SL

map_rst < case H1.
Subgoal 1:

  Variables: M, SL, X, T, RT
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  ============================
   of_ml (cof X (product T RT) :: nil) ml_nil nil

Subgoal 2 is:
 of_ml (cof X (product T RT) :: nil) (ml_cons (map X1 M1) ML) (of X1 T1 :: SL1)

map_rst < search.
Subgoal 2:

  Variables: M, SL, X, T, RT, SL1, T1, X1, ML, M1
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  H2 : tname X1
  H3 : {cof (rst X) RT |- cof M1 T1}
  H4 : of_ml (cof (rst X) RT :: nil) ML SL1 *
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map X1 M1) ML) (of X1 T1 :: SL1)

map_rst < assert {cof X (product T RT) |- cof (rst X) RT}.
Subgoal 2:

  Variables: M, SL, X, T, RT, SL1, T1, X1, ML, M1
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  H2 : tname X1
  H3 : {cof (rst X) RT |- cof M1 T1}
  H4 : of_ml (cof (rst X) RT :: nil) ML SL1 *
  H5 : {cof X (product T RT) |- cof (rst X) RT}
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map X1 M1) ML) (of X1 T1 :: SL1)

map_rst < cut H3 with H5.
Subgoal 2:

  Variables: M, SL, X, T, RT, SL1, T1, X1, ML, M1
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  H2 : tname X1
  H3 : {cof (rst X) RT |- cof M1 T1}
  H4 : of_ml (cof (rst X) RT :: nil) ML SL1 *
  H5 : {cof X (product T RT) |- cof (rst X) RT}
  H6 : {cof X (product T RT) |- cof M1 T1}
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map X1 M1) ML) (of X1 T1 :: SL1)

map_rst < apply IH to H4 with T = T.
Subgoal 2:

  Variables: M, SL, X, T, RT, SL1, T1, X1, ML, M1
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  H2 : tname X1
  H3 : {cof (rst X) RT |- cof M1 T1}
  H4 : of_ml (cof (rst X) RT :: nil) ML SL1 *
  H5 : {cof X (product T RT) |- cof (rst X) RT}
  H6 : {cof X (product T RT) |- cof M1 T1}
  H7 : of_ml (cof X (product T RT) :: nil) ML SL1
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map X1 M1) ML) (of X1 T1 :: SL1)

map_rst < search.
Proof completed.

Abella < Theorem of_ml_extend_cctx : 
forall CL Map SL X, of_ml CL Map SL -> of_ml (X :: CL) Map SL.


  ============================
   forall CL Map SL X, of_ml CL Map SL -> of_ml (X :: CL) Map SL

of_ml_extend_cctx < induction on 1.


  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  ============================
   forall CL Map SL X, of_ml CL Map SL @ -> of_ml (X :: CL) Map SL

of_ml_extend_cctx < intros.

  Variables: CL, Map, SL, X
  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  H1 : of_ml CL Map SL @
  ============================
   of_ml (X :: CL) Map SL

of_ml_extend_cctx < case H1.
Subgoal 1:

  Variables: CL, Map, SL, X
  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  ============================
   of_ml (X :: CL) ml_nil nil

Subgoal 2 is:
 of_ml (X :: CL) (ml_cons (map X1 M) ML) (of X1 T :: SL1)

of_ml_extend_cctx < search.
Subgoal 2:

  Variables: CL, Map, SL, X, SL1, T, X1, ML, M
  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  H2 : tname X1
  H3 : {CL |- cof M T}
  H4 : of_ml CL ML SL1 *
  ============================
   of_ml (X :: CL) (ml_cons (map X1 M) ML) (of X1 T :: SL1)

of_ml_extend_cctx < assert {CL, X |- cof M T}.
Subgoal 2:

  Variables: CL, Map, SL, X, SL1, T, X1, ML, M
  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  H2 : tname X1
  H3 : {CL |- cof M T}
  H4 : of_ml CL ML SL1 *
  H5 : {CL, X |- cof M T}
  ============================
   of_ml (X :: CL) (ml_cons (map X1 M) ML) (of X1 T :: SL1)

of_ml_extend_cctx < apply IH to H4 with X = X.
Subgoal 2:

  Variables: CL, Map, SL, X, SL1, T, X1, ML, M
  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  H2 : tname X1
  H3 : {CL |- cof M T}
  H4 : of_ml CL ML SL1 *
  H5 : {CL, X |- cof M T}
  H6 : of_ml (X :: CL) ML SL1
  ============================
   of_ml (X :: CL) (ml_cons (map X1 M) ML) (of X1 T :: SL1)

of_ml_extend_cctx < search.
Proof completed.

Abella < Theorem of_ml_extend_map : 
forall CL Map SL X Y T, of_ml CL Map SL -> tname X ->
  of_ml (cof Y T :: CL) (ml_cons (map X Y) Map) (of X T :: SL).


  ============================
   forall CL Map SL X Y T, of_ml CL Map SL -> tname X ->
     of_ml (cof Y T :: CL) (ml_cons (map X Y) Map) (of X T :: SL)

of_ml_extend_map < intros.

  Variables: CL, Map, SL, X, Y, T
  H1 : of_ml CL Map SL
  H2 : tname X
  ============================
   of_ml (cof Y T :: CL) (ml_cons (map X Y) Map) (of X T :: SL)

of_ml_extend_map < unfold.
Subgoal 1:

  Variables: CL, Map, SL, X, Y, T
  H1 : of_ml CL Map SL
  H2 : tname X
  ============================
   tname X

Subgoal 2 is:
 {CL, cof Y T |- cof Y T}

Subgoal 3 is:
 of_ml (cof Y T :: CL) Map SL

of_ml_extend_map < search.
Subgoal 2:

  Variables: CL, Map, SL, X, Y, T
  H1 : of_ml CL Map SL
  H2 : tname X
  ============================
   {CL, cof Y T |- cof Y T}

Subgoal 3 is:
 of_ml (cof Y T :: CL) Map SL

of_ml_extend_map < search.
Subgoal 3:

  Variables: CL, Map, SL, X, Y, T
  H1 : of_ml CL Map SL
  H2 : tname X
  ============================
   of_ml (cof Y T :: CL) Map SL

of_ml_extend_map < apply of_ml_extend_cctx to H1 with X = cof Y T.
Subgoal 3:

  Variables: CL, Map, SL, X, Y, T
  H1 : of_ml CL Map SL
  H2 : tname X
  H3 : of_ml (cof Y T :: CL) Map SL
  ============================
   of_ml (cof Y T :: CL) Map SL

of_ml_extend_map < search.
Proof completed.

Abella < Define bvars : olist -> prop by 
bvars nil;
nabla x, bvars (notfree x :: L) := bvars L.

Abella < Theorem bvars_mem : 
forall BVs E, bvars BVs -> member E BVs -> (exists X, E = notfree X /\
  tname X).


  ============================
   forall BVs E, bvars BVs -> member E BVs -> (exists X, E = notfree X /\
     tname X)

bvars_mem < induction on 1.


  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  ============================
   forall BVs E, bvars BVs @ -> member E BVs -> (exists X, E = notfree X /\
     tname X)

bvars_mem < intros.

  Variables: BVs, E
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H1 : bvars BVs @
  H2 : member E BVs
  ============================
   exists X, E = notfree X /\ tname X

bvars_mem < case H1.
Subgoal 1:

  Variables: BVs, E
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H2 : member E nil
  ============================
   exists X, E = notfree X /\ tname X

Subgoal 2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < case H2.
Subgoal 2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H2 : member (E n1) (notfree n1 :: L)
  H3 : bvars L *
  ============================
   exists X, E n1 = notfree X /\ tname X

bvars_mem < case H2.
Subgoal 2.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   exists X, notfree n1 = notfree X /\ tname X

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < exists n1.
Subgoal 2.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   notfree n1 = notfree n1 /\ tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < split.
Subgoal 2.1.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   notfree n1 = notfree n1

Subgoal 2.1.2 is:
 tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < search.
Subgoal 2.1.2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < search.
Subgoal 2.2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (E n1) L
  ============================
   exists X, E n1 = notfree X /\ tname X

bvars_mem < apply IH to H3 H4.
Subgoal 2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   exists X1, notfree (X n1) = notfree X1 /\ tname X1

bvars_mem < exists X n1.
Subgoal 2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   notfree (X n1) = notfree (X n1) /\ tname (X n1)

bvars_mem < split.
Subgoal 2.2.1:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   notfree (X n1) = notfree (X n1)

Subgoal 2.2.2 is:
 tname (X n1)

bvars_mem < search.
Subgoal 2.2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   tname (X n1)

bvars_mem < search.
Proof completed.

Abella < Theorem vars_of_sctx_mem_name : 
forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} -> tname X.


  ============================
   forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     tname X

vars_of_sctx_mem_name < induction on 1.


  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  ============================
   forall SL Vs X, sctx' SL @ -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     tname X

vars_of_sctx_mem_name < intros.

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H1 : sctx' SL @
  H2 : vars_of_sctx SL Vs
  H3 : {tl_member X Vs}
  ============================
   tname X

vars_of_sctx_mem_name < case H1.
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H2 : vars_of_sctx nil Vs
  H3 : {tl_member X Vs}
  ============================
   tname X

Subgoal 2 is:
 tname X

vars_of_sctx_mem_name < case H2.
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H3 : {tl_member X tl_nil}
  ============================
   tname X

Subgoal 2 is:
 tname X

vars_of_sctx_mem_name < case H3.
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H2 : vars_of_sctx (of X1 T :: L) Vs
  H3 : {tl_member X Vs}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  ============================
   tname X

vars_of_sctx_mem_name < case H2.
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H3 : {tl_member X (tl_cons X1 Vs1)}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   tname X

vars_of_sctx_mem_name < case H3.
Subgoal 2.1:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

vars_of_sctx_mem_name < search.
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  ============================
   tname X

vars_of_sctx_mem_name < apply IH to H4 H7 H8.
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  H9 : tname X
  ============================
   tname X

vars_of_sctx_mem_name < search.
Proof completed.

Abella < Theorem vars_of_sctx_mem_exists : 
forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
  (exists T, member (of X T) SL).


  ============================
   forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     (exists T, member (of X T) SL)

vars_of_sctx_mem_exists < induction on 1.


  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  ============================
   forall SL Vs X, sctx' SL @ -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     (exists T, member (of X T) SL)

vars_of_sctx_mem_exists < intros.

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H1 : sctx' SL @
  H2 : vars_of_sctx SL Vs
  H3 : {tl_member X Vs}
  ============================
   exists T, member (of X T) SL

vars_of_sctx_mem_exists < case H1.
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H2 : vars_of_sctx nil Vs
  H3 : {tl_member X Vs}
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < case H2.
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H3 : {tl_member X tl_nil}
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < case H3.
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H2 : vars_of_sctx (of X1 T :: L) Vs
  H3 : {tl_member X Vs}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < case H2.
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H3 : {tl_member X (tl_cons X1 Vs1)}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < case H3.
Subgoal 2.1:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   exists T1, member (of X1 T1) (of X1 T :: L)

Subgoal 2.2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < search.
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < apply IH to H4 H7 H8.
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1, T1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  H9 : member (of X T1) L
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < search.
Proof completed.

Abella < Theorem bvars_notfree : 
forall BVs X, bvars BVs -> {BVs |- notfree X} -> tname X.


  ============================
   forall BVs X, bvars BVs -> {BVs |- notfree X} -> tname X

bvars_notfree < intros.

  Variables: BVs, X
  H1 : bvars BVs
  H2 : {BVs |- notfree X}
  ============================
   tname X

bvars_notfree < case H2.

  Variables: BVs, X, F
  H1 : bvars BVs
  H3 : {BVs, [F] |- notfree X}
  H4 : member F BVs
  ============================
   tname X

bvars_notfree < apply bvars_mem to H1 H4.

  Variables: BVs, X, F, X1
  H1 : bvars BVs
  H3 : {BVs, [notfree X1] |- notfree X}
  H4 : member (notfree X1) BVs
  H5 : tname X1
  ============================
   tname X

bvars_notfree < case H3.

  Variables: BVs, X, F, X1
  H1 : bvars BVs
  H4 : member (notfree X) BVs
  H5 : tname X
  ============================
   tname X

bvars_notfree < search.
Proof completed.

Abella < Define subset : tm_list -> tm_list -> prop by 
subset tl_nil L;
subset (tl_cons X L1) L2 := {tl_member X L2} /\ subset L1 L2.

Abella < Define islist : tm_list -> prop by 
islist tl_nil;
islist (tl_cons X L) := islist L.

Abella < Theorem combine_islist : 
forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> islist L3.


  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> islist L3

combine_islist < induction on 3.


  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     islist L3

combine_islist < intros.

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  ============================
   islist L3

combine_islist < case H3.
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist tl_nil
  H2 : islist L3
  ============================
   islist L3

Subgoal 2 is:
 islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < search.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < case H1.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : islist Fvs1
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < apply IH to H6 H2 H5.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : islist Fvs1
  H7 : islist L3
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < search.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  ============================
   islist (tl_cons X Fvs)

combine_islist < case H1.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  ============================
   islist (tl_cons X Fvs)

combine_islist < apply IH to H5 H2 H4.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : islist Fvs
  ============================
   islist (tl_cons X Fvs)

combine_islist < search.
Proof completed.

Abella < Theorem tl_mem_bvar : 
forall Ps X L, bvars Ps -> {Ps |- tl_member X L} -> {tl_member X L}.


  ============================
   forall Ps X L, bvars Ps -> {Ps |- tl_member X L} -> {tl_member X L}

tl_mem_bvar < induction on 2.


  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  ============================
   forall Ps X L, bvars Ps -> {Ps |- tl_member X L}@ -> {tl_member X L}

tl_mem_bvar < intros.

  Variables: Ps, X, L
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H2 : {Ps |- tl_member X L}@
  ============================
   {tl_member X L}

tl_mem_bvar < case H2.
Subgoal 1:

  Variables: Ps, X, L, L1
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  ============================
   {tl_member X (tl_cons X L1)}

Subgoal 2 is:
 {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < search.
Subgoal 2:

  Variables: Ps, X, L, L1, Y
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L1}*
  ============================
   {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < apply IH to H1 H3.
Subgoal 2:

  Variables: Ps, X, L, L1, Y
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L1}*
  H4 : {tl_member X L1}
  ============================
   {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < search.
Subgoal 3:

  Variables: Ps, X, L, F
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps, [F] |- tl_member X L}*
  H4 : member F Ps
  ============================
   {tl_member X L}

tl_mem_bvar < apply bvars_mem to H1 H4.
Subgoal 3:

  Variables: Ps, X, L, F, X1
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps, [notfree X1] |- tl_member X L}*
  H4 : member (notfree X1) Ps
  H5 : tname X1
  ============================
   {tl_member X L}

tl_mem_bvar < case H3.
Proof completed.

Abella < Theorem combine_bvar : 
forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3} ->
  {combine L1 L2 L3}.


  ============================
   forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3} ->
     {combine L1 L2 L3}

combine_bvar < induction on 2.


  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  ============================
   forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}@ ->
     {combine L1 L2 L3}

combine_bvar < intros.

  Variables: L1, L2, L3, Ps
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H2 : {Ps |- combine L1 L2 L3}@
  ============================
   {combine L1 L2 L3}

combine_bvar < case H2.
Subgoal 1:

  Variables: L1, L2, L3, Ps
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  ============================
   {combine tl_nil L3 L3}

Subgoal 2 is:
 {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < search.
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < apply IH to H1 H4.
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  H5 : {combine Fvs1 L2 L3}
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < apply tl_mem_bvar to H1 H3.
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  H5 : {combine Fvs1 L2 L3}
  H6 : {tl_member X L2}
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < search.
Subgoal 3:

  Variables: L1, L2, L3, Ps, Fvs, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- combine Fvs1 L2 Fvs}*
  ============================
   {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < apply IH to H1 H3.
Subgoal 3:

  Variables: L1, L2, L3, Ps, Fvs, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- combine Fvs1 L2 Fvs}*
  H4 : {combine Fvs1 L2 Fvs}
  ============================
   {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < search.
Subgoal 4:

  Variables: L1, L2, L3, Ps, F
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps, [F] |- combine L1 L2 L3}*
  H4 : member F Ps
  ============================
   {combine L1 L2 L3}

combine_bvar < apply bvars_mem to H1 H4.
Subgoal 4:

  Variables: L1, L2, L3, Ps, F, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- combine L1 L2 L3}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   {combine L1 L2 L3}

combine_bvar < case H3.
Proof completed.

Abella < Theorem subset_mem : 
forall L1 L2 X, subset L1 L2 -> {tl_member X L1} -> {tl_member X L2}.


  ============================
   forall L1 L2 X, subset L1 L2 -> {tl_member X L1} -> {tl_member X L2}

subset_mem < induction on 2.


  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  ============================
   forall L1 L2 X, subset L1 L2 -> {tl_member X L1}@ -> {tl_member X L2}

subset_mem < intros.

  Variables: L1, L2, X
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset L1 L2
  H2 : {tl_member X L1}@
  ============================
   {tl_member X L2}

subset_mem < case H2.
Subgoal 1:

  Variables: L1, L2, X, L
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset (tl_cons X L) L2
  ============================
   {tl_member X L2}

Subgoal 2 is:
 {tl_member X L2}

subset_mem < case H1.
Subgoal 1:

  Variables: L1, L2, X, L
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L2}
  H4 : subset L L2
  ============================
   {tl_member X L2}

Subgoal 2 is:
 {tl_member X L2}

subset_mem < search.
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset (tl_cons Y L) L2
  H3 : {tl_member X L}*
  ============================
   {tl_member X L2}

subset_mem < case H1.
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L}*
  H4 : {tl_member Y L2}
  H5 : subset L L2
  ============================
   {tl_member X L2}

subset_mem < apply IH to H5 H3.
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L}*
  H4 : {tl_member Y L2}
  H5 : subset L L2
  H6 : {tl_member X L2}
  ============================
   {tl_member X L2}

subset_mem < search.
Proof completed.

Abella < Theorem subset_one : 
forall L1 L2 X, islist L1 -> subset L1 L2 -> subset L1 (tl_cons X L2).


  ============================
   forall L1 L2 X, islist L1 -> subset L1 L2 -> subset L1 (tl_cons X L2)

subset_one < induction on 1.


  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 -> subset L1 (tl_cons X L2)
  ============================
   forall L1 L2 X, islist L1 @ -> subset L1 L2 -> subset L1 (tl_cons X L2)

subset_one < intros.

  Variables: L1, L2, X
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H1 : islist L1 @
  H2 : subset L1 L2
  ============================
   subset L1 (tl_cons X L2)

subset_one < case H1.
Subgoal 1:

  Variables: L1, L2, X
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H2 : subset tl_nil L2
  ============================
   subset tl_nil (tl_cons X L2)

Subgoal 2 is:
 subset (tl_cons X1 L) (tl_cons X L2)

subset_one < search.
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H2 : subset (tl_cons X1 L) L2
  H3 : islist L *
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < case H2.
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < apply IH to H3 H5 with X = X.
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < unfold.
Subgoal 2.1:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   {tl_member X1 (tl_cons X L2)}

Subgoal 2.2 is:
 subset L (tl_cons X L2)

subset_one < search.
Subgoal 2.2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   subset L (tl_cons X L2)

subset_one < search.
Proof completed.

Abella < Theorem subset_refl : 
forall L, islist L -> subset L L.


  ============================
   forall L, islist L -> subset L L

subset_refl < induction on 1.


  IH : forall L, islist L * -> subset L L
  ============================
   forall L, islist L @ -> subset L L

subset_refl < intros.

  Variables: L
  IH : forall L, islist L * -> subset L L
  H1 : islist L @
  ============================
   subset L L

subset_refl < case H1 (keep).
Subgoal 1:

  Variables: L
  IH : forall L, islist L * -> subset L L
  H1 : islist tl_nil @
  ============================
   subset tl_nil tl_nil

Subgoal 2 is:
 subset (tl_cons X L1) (tl_cons X L1)

subset_refl < search.
Subgoal 2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   subset (tl_cons X L1) (tl_cons X L1)

subset_refl < unfold.
Subgoal 2.1:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   {tl_member X (tl_cons X L1)}

Subgoal 2.2 is:
 subset L1 (tl_cons X L1)

subset_refl < search.
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   subset L1 (tl_cons X L1)

subset_refl < apply IH to H2.
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  H3 : subset L1 L1
  ============================
   subset L1 (tl_cons X L1)

subset_refl < apply subset_one to H2 H3 with X = X.
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  H3 : subset L1 L1
  H4 : subset L1 (tl_cons X L1)
  ============================
   subset L1 (tl_cons X L1)

subset_refl < search.
Proof completed.

Abella < Theorem subset_trans : 
forall L1 L2 L3, subset L1 L2 -> subset L2 L3 -> subset L1 L3.


  ============================
   forall L1 L2 L3, subset L1 L2 -> subset L2 L3 -> subset L1 L3

subset_trans < induction on 1.


  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  ============================
   forall L1 L2 L3, subset L1 L2 @ -> subset L2 L3 -> subset L1 L3

subset_trans < intros.

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H1 : subset L1 L2 @
  H2 : subset L2 L3
  ============================
   subset L1 L3

subset_trans < case H1.
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  ============================
   subset tl_nil L3

Subgoal 2 is:
 subset (tl_cons X L4) L3

subset_trans < search.
Subgoal 2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   subset (tl_cons X L4) L3

subset_trans < unfold.
Subgoal 2.1:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   {tl_member X L3}

Subgoal 2.2 is:
 subset L4 L3

subset_trans < apply subset_mem to H2 H3.
Subgoal 2.1:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  H5 : {tl_member X L3}
  ============================
   {tl_member X L3}

Subgoal 2.2 is:
 subset L4 L3

subset_trans < search.
Subgoal 2.2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   subset L4 L3

subset_trans < apply IH to H4 H2.
Subgoal 2.2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  H5 : subset L4 L3
  ============================
   subset L4 L3

subset_trans < search.
Proof completed.

Abella < Theorem combine_subset1 : 
forall L1 L2 L3, islist L2 -> {combine L1 L2 L3} -> subset L2 L3.


  ============================
   forall L1 L2 L3, islist L2 -> {combine L1 L2 L3} -> subset L2 L3

combine_subset1 < induction on 2.


  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  ============================
   forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}@ -> subset L2 L3

combine_subset1 < intros.

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H2 : {combine L1 L2 L3}@
  ============================
   subset L2 L3

combine_subset1 < case H2.
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L3
  ============================
   subset L3 L3

Subgoal 2 is:
 subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < apply subset_refl to H1.
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L3
  H3 : subset L3 L3
  ============================
   subset L3 L3

Subgoal 2 is:
 subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < search.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {tl_member X L2}*
  H4 : {combine Fvs1 L2 L3}*
  ============================
   subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < apply IH to H1 H4 with L1 = Fvs1.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {tl_member X L2}*
  H4 : {combine Fvs1 L2 L3}*
  H5 : subset L2 L3
  ============================
   subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < search.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < apply IH to H1 H3 with L1 = Fvs1.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  H4 : subset L2 Fvs
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < apply subset_one to H1 H4 with X = X.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  H4 : subset L2 Fvs
  H5 : subset L2 (tl_cons X Fvs)
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < search.
Proof completed.

Abella < Theorem combine_subset2 : 
forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> subset L1 L3.


  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
     subset L1 L3

combine_subset2 < induction on 3.


  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     subset L1 L3

combine_subset2 < intros.

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  ============================
   subset L1 L3

combine_subset2 < case H3.
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist tl_nil
  H2 : islist L3
  ============================
   subset tl_nil L3

Subgoal 2 is:
 subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < search.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < apply combine_subset1 to H2 H5.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < apply subset_mem to H6 H4.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < case H1.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  H8 : islist Fvs1
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < apply IH to H8 H2 H5.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  H8 : islist Fvs1
  H9 : subset Fvs1 L3
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < search.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < case H1.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < apply IH to H5 H2 H4.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : subset Fvs1 Fvs
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < apply subset_one to H5 H6 with X = X.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : subset Fvs1 Fvs
  H7 : subset Fvs1 (tl_cons X Fvs)
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < search.
Proof completed.

Abella < Theorem subset_combine : 
forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
  subset L1 L4 -> subset L2 L4 -> subset L3 L4.


  ============================
   forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
     subset L1 L4 -> subset L2 L4 -> subset L3 L4

subset_combine < induction on 3.


  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  ============================
   forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     subset L1 L4 -> subset L2 L4 -> subset L3 L4

subset_combine < intros.

  Variables: L1, L2, L3, L4
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  H4 : subset L1 L4
  H5 : subset L2 L4
  ============================
   subset L3 L4

subset_combine < case H3.
Subgoal 1:

  Variables: L1, L2, L3, L4
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist tl_nil
  H2 : islist L3
  H4 : subset tl_nil L4
  H5 : subset L3 L4
  ============================
   subset L3 L4

Subgoal 2 is:
 subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < search.
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < case H1.
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < case H4.
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  H9 : {tl_member X L4}
  H10 : subset Fvs1 L4
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < apply IH to H8 H2 H7 H10 H5.
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  H9 : {tl_member X L4}
  H10 : subset Fvs1 L4
  H11 : subset L3 L4
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < search.
Subgoal 3:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  ============================
   subset (tl_cons X Fvs) L4

subset_combine < case H4.
Subgoal 3:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   subset (tl_cons X Fvs) L4

subset_combine < unfold.
Subgoal 3.1:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   {tl_member X L4}

Subgoal 3.2 is:
 subset Fvs L4

subset_combine < search.
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   subset Fvs L4

subset_combine < case H1.
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  H9 : islist Fvs1
  ============================
   subset Fvs L4

subset_combine < apply IH to H9 H2 H6 H8 H5.
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  H9 : islist Fvs1
  H10 : subset Fvs L4
  ============================
   subset Fvs L4

subset_combine < search.
Proof completed.

Abella < Theorem fvars_islist : 
forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> islist Vs'.


  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> islist Vs'

fvars_islist < induction on 2.


  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}@ -> islist Vs'

fvars_islist < intros.

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   islist Vs'

fvars_islist < case H2.
Subgoal 1:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   islist tl_nil

Subgoal 2 is:
 islist tl_nil

Subgoal 3 is:
 islist tl_nil

Subgoal 4 is:
 islist (tl_cons M tl_nil)

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < search.
Subgoal 2:

  Variables: M, Vs, Vs', Ps, C
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  ============================
   islist tl_nil

Subgoal 3 is:
 islist tl_nil

Subgoal 4 is:
 islist (tl_cons M tl_nil)

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < search.
Subgoal 3:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  ============================
   islist tl_nil

Subgoal 4 is:
 islist (tl_cons M tl_nil)

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < search.
Subgoal 4:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   islist (tl_cons M tl_nil)

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < search.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < apply IH to H1 H3.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < apply IH to H1 H4.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < apply combine_bvar to H1 H5.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  H8 : {combine Fvs1 Fvs2 Vs'}
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < apply combine_islist to H6 H7 H8.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  H8 : {combine Fvs1 Fvs2 Vs'}
  H9 : islist Vs'
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < search.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < assert bvars (notfree n1 :: Ps).
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < apply IH to H4 H3.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : islist Vs'
  ============================
   islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < search.
Subgoal 7:

  Variables: M, Vs, Vs', Ps, F
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   islist Vs'

fvars_islist < apply bvars_mem to H1 H4.
Subgoal 7:

  Variables: M, Vs, Vs', Ps, F, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- fvars M Vs Vs'}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   islist Vs'

fvars_islist < case H3.
Proof completed.

Abella < Theorem fvars_subset : 
forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> subset Vs' Vs.


  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> subset Vs' Vs

fvars_subset < induction on 2.


  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}@ -> subset Vs' Vs

fvars_subset < intros.

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   subset Vs' Vs

fvars_subset < case H2.
Subgoal 1:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   subset tl_nil Vs

Subgoal 2 is:
 subset tl_nil Vs

Subgoal 3 is:
 subset tl_nil Vs

Subgoal 4 is:
 subset (tl_cons M tl_nil) Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < search.
Subgoal 2:

  Variables: M, Vs, Vs', Ps, C
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  ============================
   subset tl_nil Vs

Subgoal 3 is:
 subset tl_nil Vs

Subgoal 4 is:
 subset (tl_cons M tl_nil) Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < search.
Subgoal 3:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  ============================
   subset tl_nil Vs

Subgoal 4 is:
 subset (tl_cons M tl_nil) Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < search.
Subgoal 4:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   subset (tl_cons M tl_nil) Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < apply tl_mem_bvar to H1 H3.
Subgoal 4:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  H4 : {tl_member M Vs}
  ============================
   subset (tl_cons M tl_nil) Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < search.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < apply IH to H1 H3.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < apply IH to H1 H4.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < apply fvars_islist to H1 H3.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < apply fvars_islist to H1 H4.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < apply combine_bvar to H1 H5.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  H10 : {combine Fvs1 Fvs2 Vs'}
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < apply subset_combine to H8 H9 H10 H6 H7.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  H10 : {combine Fvs1 Fvs2 Vs'}
  H11 : subset Vs' Vs
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < search.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < assert bvars (notfree n1 :: Ps).
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < apply IH to H4 H3.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : subset Vs' Vs
  ============================
   subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < search.
Subgoal 7:

  Variables: M, Vs, Vs', Ps, F
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   subset Vs' Vs

fvars_subset < apply bvars_mem to H1 H4.
Subgoal 7:

  Variables: M, Vs, Vs', Ps, F, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- fvars M Vs Vs'}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   subset Vs' Vs

fvars_subset < case H3.
Proof completed.

Abella < Theorem fvars_extend : 
forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'} ->
  {Ps |- fvars M (tl_cons X Vs) Vs'}.


  ============================
   forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'} ->
     {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < induction on 2.


  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  ============================
   forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}@ ->
     {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < intros.

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < case H2.
Subgoal 1:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   {Ps |- fvars M (tl_cons X Vs) tl_nil}

Subgoal 2 is:
 {Ps |- fvars (cst C) (tl_cons X Vs) tl_nil}

Subgoal 3 is:
 {Ps |- fvars (lnat X2) (tl_cons X Vs) tl_nil}

Subgoal 4 is:
 {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 5 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < search.
Subgoal 2:

  Variables: M, Vs, Vs', Ps, X, C
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  ============================
   {Ps |- fvars (cst C) (tl_cons X Vs) tl_nil}

Subgoal 3 is:
 {Ps |- fvars (lnat X2) (tl_cons X Vs) tl_nil}

Subgoal 4 is:
 {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 5 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < search.
Subgoal 3:

  Variables: M, Vs, Vs', Ps, X, X2
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  ============================
   {Ps |- fvars (lnat X2) (tl_cons X Vs) tl_nil}

Subgoal 4 is:
 {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 5 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < search.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 5 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < search.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < apply IH to H1 H3 with X = X.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : {Ps |- fvars M1 (tl_cons X Vs) Fvs1}
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < apply IH to H1 H4 with X = X.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : {Ps |- fvars M1 (tl_cons X Vs) Fvs1}
  H7 : {Ps |- fvars M2 (tl_cons X Vs) Fvs2}
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < search.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < assert bvars (notfree n1 :: Ps).
Subgoal 6:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < apply IH to H4 H3 with X = X.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : {Ps, notfree n1 |- fvars (M1 n1) (tl_cons X Vs) Vs'}
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < search.
Subgoal 7:

  Variables: M, Vs, Vs', Ps, X, F
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < apply bvars_mem to H1 H4.
Subgoal 7:

  Variables: M, Vs, Vs', Ps, X, F, X1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, [notfree X1] |- fvars M Vs Vs'}*
  H4 : member (notfree X1) Ps
  H5 : tname X1
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < case H3.
Proof completed.

Abella < Define pruned_env : olist -> tm_list -> olist -> olist -> prop by 
pruned_env nil tl_nil SL nil;
pruned_env nil (tl_cons X FVs) SL (of X T :: SL') := member (of X T) SL /\ pruned_env nil FVs SL SL';
nabla x, pruned_env (notfree x :: BVs) FVs (of x T :: SL) (of x T :: SL') := pruned_env BVs FVs SL SL'.

Abella < Theorem pruned_env_exists : 
forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs ->
  (exists SL', pruned_env nil Vs' SL SL').


  ============================
   forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs ->
     (exists SL', pruned_env nil Vs' SL SL')

pruned_env_exists < induction on 3.


  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  ============================
   forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs @ ->
     (exists SL', pruned_env nil Vs' SL SL')

pruned_env_exists < intros.

  Variables: SL, Vs, Vs'
  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  H1 : sctx' SL
  H2 : vars_of_sctx SL Vs
  H3 : subset Vs' Vs @
  ============================
   exists SL', pruned_env nil Vs' SL SL'

pruned_env_exists < case H3.
Subgoal 1:

  Variables: SL, Vs, Vs'
  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  H1 : sctx' SL
  H2 : vars_of_sctx SL Vs
  ============================
   exists SL', pruned_env nil tl_nil SL SL'

Subgoal 2 is:
 exists SL', pruned_env nil (tl_cons X L1) SL SL'

pruned_env_exists < search.
Subgoal 2:

  Variables: SL, Vs, Vs', L1, X
  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  H1 : sctx' SL
  H2 : vars_of_sctx SL Vs
  H4 : {tl_member X Vs}
  H5 : subset L1 Vs *
  ============================
   exists SL', pruned_env nil (tl_cons X L1) SL SL'

pruned_env_exists < apply vars_of_sctx_mem_exists to H1 H2 H4.
Subgoal 2:

  Variables: SL, Vs, Vs', L1, X, T
  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  H1 : sctx' SL
  H2 : vars_of_sctx SL Vs
  H4 : {tl_member X Vs}
  H5 : subset L1 Vs *
  H6 : member (of X T) SL
  ============================
   exists SL', pruned_env nil (tl_cons X L1) SL SL'

pruned_env_exists < apply IH to H1 H2 H5.
Subgoal 2:

  Variables: SL, Vs, Vs', L1, X, T, SL'
  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  H1 : sctx' SL
  H2 : vars_of_sctx SL Vs
  H4 : {tl_member X Vs}
  H5 : subset L1 Vs *
  H6 : member (of X T) SL
  H7 : pruned_env nil L1 SL SL'
  ============================
   exists SL', pruned_env nil (tl_cons X L1) SL SL'

pruned_env_exists < search.
Proof completed.

Abella < Theorem pruned_env_vars : 
forall FVs SL SL', pruned_env nil FVs SL SL' -> vars_of_sctx SL' FVs.


  ============================
   forall FVs SL SL', pruned_env nil FVs SL SL' -> vars_of_sctx SL' FVs

pruned_env_vars < induction on 1.


  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  ============================
   forall FVs SL SL', pruned_env nil FVs SL SL' @ -> vars_of_sctx SL' FVs

pruned_env_vars < intros.

  Variables: FVs, SL, SL'
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H1 : pruned_env nil FVs SL SL' @
  ============================
   vars_of_sctx SL' FVs

pruned_env_vars < case H1.
Subgoal 1:

  Variables: FVs, SL, SL'
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  ============================
   vars_of_sctx nil tl_nil

Subgoal 2 is:
 vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < search.
Subgoal 2:

  Variables: FVs, SL, SL', SL'1, T, X, FVs1
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H2 : member (of X T) SL
  H3 : pruned_env nil FVs1 SL SL'1 *
  ============================
   vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < apply IH to H3.
Subgoal 2:

  Variables: FVs, SL, SL', SL'1, T, X, FVs1
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H2 : member (of X T) SL
  H3 : pruned_env nil FVs1 SL SL'1 *
  H4 : vars_of_sctx SL'1 FVs1
  ============================
   vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < search.
Proof completed.

Abella < Theorem pruned_env_sctx_source : 
forall FV SL SL' X T, pruned_env nil FV SL SL' -> member (of X T) SL' ->
  member (of X T) SL.


  ============================
   forall FV SL SL' X T, pruned_env nil FV SL SL' -> member (of X T) SL' ->
     member (of X T) SL

pruned_env_sctx_source < induction on 1.


  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  ============================
   forall FV SL SL' X T, pruned_env nil FV SL SL' @ -> member (of X T) SL' ->
     member (of X T) SL

pruned_env_sctx_source < intros.

  Variables: FV, SL, SL', X, T
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H1 : pruned_env nil FV SL SL' @
  H2 : member (of X T) SL'
  ============================
   member (of X T) SL

pruned_env_sctx_source < case H1.
Subgoal 1:

  Variables: FV, SL, SL', X, T
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H2 : member (of X T) nil
  ============================
   member (of X T) SL

Subgoal 2 is:
 member (of X T) SL

pruned_env_sctx_source < case H2.
Subgoal 2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H2 : member (of X T) (of X1 T1 :: SL'1)
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  ============================
   member (of X T) SL

pruned_env_sctx_source < case H2.
Subgoal 2.1:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  ============================
   member (of X1 T1) SL

Subgoal 2.2 is:
 member (of X T) SL

pruned_env_sctx_source < search.
Subgoal 2.2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  H5 : member (of X T) SL'1
  ============================
   member (of X T) SL

pruned_env_sctx_source < apply IH to H4 H5.
Subgoal 2.2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  H5 : member (of X T) SL'1
  H6 : member (of X T) SL
  ============================
   member (of X T) SL

pruned_env_sctx_source < search.
Proof completed.

Abella < Theorem pruned_env_sctx : 
forall SL BVL FVs SL', sctx' SL -> bvars BVL -> pruned_env BVL FVs SL SL' ->
  sctx' SL'.


  ============================
   forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
     pruned_env BVL FVs SL SL' -> sctx' SL'

pruned_env_sctx < induction on 3.


  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  ============================
   forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
     pruned_env BVL FVs SL SL' @ -> sctx' SL'

pruned_env_sctx < intros.

  Variables: SL, BVL, FVs, SL'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars BVL
  H3 : pruned_env BVL FVs SL SL' @
  ============================
   sctx' SL'

pruned_env_sctx < case H3.
Subgoal 1:

  Variables: SL, BVL, FVs, SL'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  ============================
   sctx' nil

Subgoal 2 is:
 sctx' (of X T :: SL'1)

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < search.
Subgoal 2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   sctx' (of X T :: SL'1)

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < unfold.
Subgoal 2.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   sctx' SL'1

Subgoal 2.2 is:
 tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < apply IH to H1 H2 H5.
Subgoal 2.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : sctx' SL'1
  ============================
   sctx' SL'1

Subgoal 2.2 is:
 tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < search.
Subgoal 2.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < apply sctx'_name to H1 H4.
Subgoal 2.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : tname X
  ============================
   tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < search.
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < intros.
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  ============================
   T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < apply pruned_env_sctx_source to H5 H6.
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  H7 : member (of X T') SL
  ============================
   T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < apply sctx'_equal to H1 H4 H7.
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T') SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  H7 : member (of X T') SL
  ============================
   T' = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < search.
Subgoal 3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   sctx' (of n1 T :: SL'1)

pruned_env_sctx < unfold.
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < case H1.
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < case H2.
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  H8 : bvars BVs
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < apply IH to H5 H8 H4.
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  H8 : bvars BVs
  H9 : sctx' SL'1
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < search.
Subgoal 3.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < search.
Subgoal 3.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < intros.
Subgoal 3.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (of n1 T') SL'1
  ============================
   T = T'

pruned_env_sctx < apply mem_of_absurd to H5.
Proof completed.

Abella < Theorem pruned_env_bound : 
forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' ->
  member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'.


  ============================
   forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' ->
     member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'

pruned_env_bound < induction on 1.


  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  ============================
   forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' @ ->
     member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'

pruned_env_bound < intros.

  Variables: BVL, FVs, SL, SL', X, T
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H1 : pruned_env BVL FVs SL SL' @
  H2 : member (notfree X) BVL
  H3 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_bound < case H1.
Subgoal 1:

  Variables: BVL, FVs, SL, SL', X, T
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree X) nil
  H3 : member (of X T) SL
  ============================
   member (of X T) nil

Subgoal 2 is:
 member (of X T) (of X1 T1 :: SL'1)

Subgoal 3 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < case H2.
Subgoal 2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, X1, FVs1
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree X) nil
  H3 : member (of X T) SL
  H4 : member (of X1 T1) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   member (of X T) (of X1 T1 :: SL'1)

Subgoal 3 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < case H2.
Subgoal 3:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree (X n1)) (notfree n1 :: BVs)
  H3 : member (of (X n1) T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < case H2.
Subgoal 3.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H3 : member (of n1 T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < case H3.
Subgoal 3.1.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 3.1.2 is:
 member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < search.
Subgoal 3.1.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (of n1 T) SL1
  ============================
   member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < apply mem_of_absurd to H5.
Subgoal 3.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H3 : member (of (X n1) T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < case H3.
Subgoal 3.2.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree n1) BVs
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 3.2.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < search.
Subgoal 3.2.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  H6 : member (of (X n1) T) SL1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < apply IH to H4 H5 H6.
Subgoal 3.2.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  H6 : member (of (X n1) T) SL1
  H7 : member (of (X n1) T) SL'1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < search.
Proof completed.

Abella < Theorem pruned_env_free_aux : 
forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
  {tl_member X FVs} -> member (of X T) SL -> member (of X T) SL'.


  ============================
   forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
     {tl_member X FVs} -> member (of X T) SL -> member (of X T) SL'

pruned_env_free_aux < induction on 3.


  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  ============================
   forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
     {tl_member X FVs}@ -> member (of X T) SL -> member (of X T) SL'

pruned_env_free_aux < intros.

  Variables: FVs, SL, SL', X, T
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil FVs SL SL'
  H3 : {tl_member X FVs}@
  H4 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_free_aux < case H3.
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil (tl_cons X L) SL SL'
  H4 : member (of X T) SL
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < case H2.
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : member (of X T1) SL
  H6 : pruned_env nil L SL SL'1
  ============================
   member (of X T) (of X T1 :: SL'1)

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < apply sctx'_equal to H1 H4 H5.
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T1) SL
  H5 : member (of X T1) SL
  H6 : pruned_env nil L SL SL'1
  ============================
   member (of X T1) (of X T1 :: SL'1)

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < search.
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil (tl_cons Y L) SL SL'
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  ============================
   member (of X T) SL'

pruned_env_free_aux < case H2.
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  H6 : member (of Y T1) SL
  H7 : pruned_env nil L SL SL'1
  ============================
   member (of X T) (of Y T1 :: SL'1)

pruned_env_free_aux < apply IH to H1 H7 H5 H4.
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  H6 : member (of Y T1) SL
  H7 : pruned_env nil L SL SL'1
  H8 : member (of X T) SL'1
  ============================
   member (of X T) (of Y T1 :: SL'1)

pruned_env_free_aux < search.
Proof completed.

Abella < Theorem pruned_env_free : 
forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
  pruned_env BVLs FVs SL SL' -> {tl_member X FVs} -> member (of X T) SL ->
  member (of X T) SL'.


  ============================
   forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
     pruned_env BVLs FVs SL SL' -> {tl_member X FVs} -> member (of X T) SL ->
     member (of X T) SL'

pruned_env_free < induction on 3.


  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  ============================
   forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
     pruned_env BVLs FVs SL SL' @ -> {tl_member X FVs} ->
     member (of X T) SL -> member (of X T) SL'

pruned_env_free < intros.

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : bvars BVLs
  H3 : pruned_env BVLs FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_free < case H2.
Subgoal 1:

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H3 : pruned_env nil FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of (X n1) T) (SL' n1)

pruned_env_free < apply pruned_env_free_aux to H1 H3 H4 H5.
Subgoal 1:

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H3 : pruned_env nil FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  H6 : member (of X T) SL'
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of (X n1) T) (SL' n1)

pruned_env_free < search.
Subgoal 2:

  Variables: BVLs, FVs, SL, SL', X, T, L
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (SL n1)
  H3 : pruned_env (notfree n1 :: L) (FVs n1) (SL n1) (SL' n1) @
  H4 : {tl_member (X n1) (FVs n1)}
  H5 : member (of (X n1) T) (SL n1)
  H6 : bvars L
  ============================
   member (of (X n1) T) (SL' n1)

pruned_env_free < case H3.
Subgoal 2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H5 : member (of (X n1) T) (of n1 T1 :: SL1)
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < case H5.
Subgoal 2.1:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member n1 FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 2.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < search.
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < assert bvars (notfree n1 :: L).
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < case H1.
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  H10 : sctx' SL1
  H11 : tname n1
  H12 : forall T', member (of n1 T') SL1 -> T1 = T'
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < apply IH to H10 H6 H7 H4 H8.
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  H10 : sctx' SL1
  H11 : tname n1
  H12 : forall T', member (of n1 T') SL1 -> T1 = T'
  H13 : member (of (X n1) T) SL'1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < search.
Proof completed.

Abella < Theorem pruned_env_typing : 
forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T} ->
  vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
  subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}.


  ============================
   forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T} ->
     vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
     subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}

pruned_env_typing < induction on 2.


  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  ============================
   forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}@ ->
     vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
     subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}

pruned_env_typing < intros.

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs''
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H2 : {SL |- of M T}@
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  ============================
   {SL' |- of M T}

pruned_env_typing < case H2.
Subgoal 1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (lnat X) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  ============================
   {SL' |- of (lnat X) nat_t}

Subgoal 2 is:
 {SL' |- of (cst C) T}

Subgoal 3 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < search.
Subgoal 2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', C
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (cst C) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of_const C T}*
  ============================
   {SL' |- of (cst C) T}

Subgoal 3 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply of_const_sctx' to H1 H8.
Subgoal 2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', C
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (cst C) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of_const C T}*
  H9 : {of_const C T}
  ============================
   {SL' |- of (cst C) T}

Subgoal 3 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < search.
Subgoal 3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (app M1 N) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < case H5.
Subgoal 3.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- notfree (app M1 N)}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.2 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply bvars_notfree to H4 H10.
Subgoal 3.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- notfree (app M1 N)}
  H11 : tname (app M1 N)
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.2 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < case H11.
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply tl_mem_bvar to H4 H10.
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  H11 : {tl_member (app M1 N) FVs}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply vars_of_sctx_mem_name to H1 H3 H11.
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  H11 : {tl_member (app M1 N) FVs}
  H12 : tname (app M1 N)
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < case H12.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply fvars_islist to H4 H10.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply fvars_islist to H4 H11.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply combine_bvar to H4 H12.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply combine_islist to H13 H14 H15.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply combine_subset2 to H13 H14 H15.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply subset_trans to H17 H6.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply IH to H1 H8 H3 H4 H10 H18 H7.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply combine_subset1 to H14 H15.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply subset_trans to H20 H6.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  H21 : subset Fvs2 FVs''
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply IH to H1 H9 H3 H4 H11 H21 H7.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  H21 : subset Fvs2 FVs''
  H22 : {SL' |- of N T1}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < search.
Subgoal 3.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL, [F] |- fvars (app M1 N) FVs FVs'}
  H11 : member F BVL
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply bvars_mem to H4 H11.
Subgoal 3.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, F, X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL, [notfree X] |- fvars (app M1 N) FVs FVs'}
  H11 : member (notfree X) BVL
  H12 : tname X
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < case H10.
Subgoal 4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (abs M1) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < case H5.
Subgoal 4.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- notfree (abs M1)}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.2 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply bvars_notfree to H4 H9.
Subgoal 4.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- notfree (abs M1)}
  H10 : tname (abs M1)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.2 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < case H10.
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply tl_mem_bvar to H4 H9.
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  H10 : {tl_member (abs M1) FVs}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply vars_of_sctx_mem_name to H1 H3 H10.
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  H10 : {tl_member (abs M1) FVs}
  H11 : tname (abs M1)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < case H11.
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < assert pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL').
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < assert bvars (notfree n1 :: BVL).
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < assert vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs).
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply sctx'_extend to H1 with T = T1.
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply fvars_extend to H11 H9 with X = n1.
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  H14 : {BVL, notfree n1 |- fvars (M1 n1) (tl_cons n1 FVs) FVs'}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply IH to H13 H8 H12 H11 H14 H6 H10.
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  H14 : {BVL, notfree n1 |- fvars (M1 n1) (tl_cons n1 FVs) FVs'}
  H15 : {SL', of n1 T1 |- of (M1 n1) T2}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < search.
Subgoal 4.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1, F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, [F] |- fvars (abs M1) FVs FVs'}
  H10 : member F BVL
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < apply bvars_mem to H4 H10.
Subgoal 4.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1, F, X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, [notfree X] |- fvars (abs M1) FVs FVs'}
  H10 : member (notfree X) BVL
  H11 : tname X
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < case H9.
Subgoal 5:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, [F] |- of M T}*
  H9 : member F SL
  ============================
   {SL' |- of M T}

pruned_env_typing < apply sctx'_mem to H1 H9.
Subgoal 5:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, [of X T1] |- of M T}*
  H9 : member (of X T1) SL
  H10 : tname X
  ============================
   {SL' |- of M T}

pruned_env_typing < case H8.
Subgoal 5:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H9 : member (of M T) SL
  H10 : tname M
  ============================
   {SL' |- of M T}

pruned_env_typing < case H10.
Subgoal 5:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H5 : {BVL n1 |- fvars n1 (FVs n1) (FVs' n1)}
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < case H5.
Subgoal 5.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- notfree n1}
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < case H11.
Subgoal 5.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [F1 n1] |- notfree n1}
  H13 : member (F1 n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < apply bvars_mem to H4 H13.
Subgoal 5.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree (X1 n1)] |- notfree n1}
  H13 : member (notfree (X1 n1)) (BVL n1)
  H14 : tname (X1 n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < case H14.
Subgoal 5.1.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n2 n1)
  H3 : vars_of_sctx (SL n2 n1) (FVs n2 n1)
  H4 : bvars (BVL n2 n1)
  H6 : subset tl_nil (FVs'' n2 n1)
  H7 : pruned_env (BVL n2 n1) (FVs'' n2 n1) (SL n2 n1) (SL' n2 n1)
  H9 : member (of n1 T) (SL n2 n1)
  H12 : {BVL n2 n1, [notfree n2] |- notfree n1}
  H13 : member (notfree n2) (BVL n2 n1)
  ============================
   {SL' n2 n1 |- of n1 T}

Subgoal 5.1.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < case H12.
Subgoal 5.1.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree n1] |- notfree n1}
  H13 : member (notfree n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < apply pruned_env_bound to H7 H13 H9.
Subgoal 5.1.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree n1] |- notfree n1}
  H13 : member (notfree n1) (BVL n1)
  H15 : member (of n1 T) (SL' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < search.
Subgoal 5.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (tl_cons n1 tl_nil) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < case H6.
Subgoal 5.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  H12 : {tl_member n1 (FVs'' n1)}
  H13 : subset tl_nil (FVs'' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < apply pruned_env_free to H1 H4 H7 H12 H9.
Subgoal 5.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  H12 : {tl_member n1 (FVs'' n1)}
  H13 : subset tl_nil (FVs'' n1)
  H14 : member (of n1 T) (SL' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < search.
Subgoal 5.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1, [F1 n1] |- fvars n1 (FVs n1) (FVs' n1)}
  H12 : member (F1 n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < apply bvars_mem to H4 H12.
Subgoal 5.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1, [notfree (X1 n1)] |- fvars n1 (FVs n1) (FVs' n1)}
  H12 : member (notfree (X1 n1)) (BVL n1)
  H13 : tname (X1 n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < case H11.
Proof completed.

Abella < Define reified_env : olist -> ty -> prop by 
reified_env nil unit_t;
reified_env (of X T :: SL) (product T RT) := reified_env SL RT.

Abella < Theorem reified_env_exists : 
forall SL, sctx' SL -> (exists Ty, reified_env SL Ty).


  ============================
   forall SL, sctx' SL -> (exists Ty, reified_env SL Ty)

reified_env_exists < induction on 1.


  IH : forall SL, sctx' SL * -> (exists Ty, reified_env SL Ty)
  ============================
   forall SL, sctx' SL @ -> (exists Ty, reified_env SL Ty)

reified_env_exists < intros.

  Variables: SL
  IH : forall SL, sctx' SL * -> (exists Ty, reified_env SL Ty)
  H1 : sctx' SL @
  ============================
   exists Ty, reified_env SL Ty

reified_env_exists < case H1.
Subgoal 1:

  Variables: SL
  IH : forall SL, sctx' SL * -> (exists Ty, reified_env SL Ty)
  ============================
   exists Ty, reified_env nil Ty

Subgoal 2 is:
 exists Ty, reified_env (of X T :: L) Ty

reified_env_exists < search.
Subgoal 2:

  Variables: SL, L, T, X
  IH : forall SL, sctx' SL * -> (exists Ty, reified_env SL Ty)
  H2 : sctx' L *
  H3 : tname X
  H4 : forall T', member (of X T') L -> T = T'
  ============================
   exists Ty, reified_env (of X T :: L) Ty

reified_env_exists < apply IH to H2.
Subgoal 2:

  Variables: SL, L, T, X, Ty
  IH : forall SL, sctx' SL * -> (exists Ty, reified_env SL Ty)
  H2 : sctx' L *
  H3 : tname X
  H4 : forall T', member (of X T') L -> T = T'
  H5 : reified_env L Ty
  ============================
   exists Ty, reified_env (of X T :: L) Ty

reified_env_exists < search.
Proof completed.

Abella < Theorem pruned_env_reification_type : 
forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' -> sctx' SL' ->
  {mapvar FVs X Map} -> reified_env SL' RTy ->
  of_ml (cof X RTy :: nil) Map SL'.


  ============================
   forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' -> sctx' SL' ->
     {mapvar FVs X Map} -> reified_env SL' RTy ->
     of_ml (cof X RTy :: nil) Map SL'

pruned_env_reification_type < induction on 1.


  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  ============================
   forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' @ -> sctx' SL' ->
     {mapvar FVs X Map} -> reified_env SL' RTy ->
     of_ml (cof X RTy :: nil) Map SL'

pruned_env_reification_type < intros.

  Variables: FVs, SL, SL', RTy, Map, X
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H1 : pruned_env nil FVs SL SL' @
  H2 : sctx' SL'
  H3 : {mapvar FVs X Map}
  H4 : reified_env SL' RTy
  ============================
   of_ml (cof X RTy :: nil) Map SL'

pruned_env_reification_type < case H1.
Subgoal 1:

  Variables: FVs, SL, SL', RTy, Map, X
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H2 : sctx' nil
  H3 : {mapvar tl_nil X Map}
  H4 : reified_env nil RTy
  ============================
   of_ml (cof X RTy :: nil) Map nil

Subgoal 2 is:
 of_ml (cof X RTy :: nil) Map (of X1 T :: SL'1)

pruned_env_reification_type < case H3.
Subgoal 1:

  Variables: FVs, SL, SL', RTy, Map, X
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H2 : sctx' nil
  H4 : reified_env nil RTy
  ============================
   of_ml (cof X RTy :: nil) ml_nil nil

Subgoal 2 is:
 of_ml (cof X RTy :: nil) Map (of X1 T :: SL'1)

pruned_env_reification_type < search.
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H2 : sctx' (of X1 T :: SL'1)
  H3 : {mapvar (tl_cons X1 FVs1) X Map}
  H4 : reified_env (of X1 T :: SL'1) RTy
  H5 : member (of X1 T) SL
  H6 : pruned_env nil FVs1 SL SL'1 *
  ============================
   of_ml (cof X RTy :: nil) Map (of X1 T :: SL'1)

pruned_env_reification_type < case H2.
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H3 : {mapvar (tl_cons X1 FVs1) X Map}
  H4 : reified_env (of X1 T :: SL'1) RTy
  H5 : member (of X1 T) SL
  H6 : pruned_env nil FVs1 SL SL'1 *
  H7 : sctx' SL'1
  H8 : tname X1
  H9 : forall T', member (of X1 T') SL'1 -> T = T'
  ============================
   of_ml (cof X RTy :: nil) Map (of X1 T :: SL'1)

pruned_env_reification_type < case H8.
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H3 : {mapvar (tl_cons n1 (FVs1 n1)) X (Map n1)}
  H4 : reified_env (of n1 T :: SL'1 n1) RTy
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  ============================
   of_ml (cof X RTy :: nil) (Map n1) (of n1 T :: SL'1 n1)

pruned_env_reification_type < case H3.
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H4 : reified_env (of n1 T :: SL'1 n1) RTy
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  ============================
   of_ml (cof X RTy :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < case H4.
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap, RT
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  H11 : reified_env (SL'1 n1) RT
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < apply IH to H6 H7 H10 H11.
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap, RT
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  H11 : reified_env (SL'1 n1) RT
  H12 : of_ml (cof (rst X) RT :: nil) (LMap n1) (SL'1 n1)
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < assert {cof X (product T RT) |- cof (fst X) T}.
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap, RT
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  H11 : reified_env (SL'1 n1) RT
  H12 : of_ml (cof (rst X) RT :: nil) (LMap n1) (SL'1 n1)
  H13 : {cof X (product T RT) |- cof (fst X) T}
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < apply map_rst to H12 with T = T.
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap, RT
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  H11 : reified_env (SL'1 n1) RT
  H12 : of_ml (cof (rst X) RT :: nil) (LMap n1) (SL'1 n1)
  H13 : {cof X (product T RT) |- cof (fst X) T}
  H14 : of_ml (cof X (product T RT) :: nil) (LMap n1) (SL'1 n1)
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < assert {cof X (product T RT) |- cof (rst X) RT}.
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap, RT
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  H11 : reified_env (SL'1 n1) RT
  H12 : of_ml (cof (rst X) RT :: nil) (LMap n1) (SL'1 n1)
  H13 : {cof X (product T RT) |- cof (fst X) T}
  H14 : of_ml (cof X (product T RT) :: nil) (LMap n1) (SL'1 n1)
  H15 : {cof X (product T RT) |- cof (rst X) RT}
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < search.
Proof completed.

Abella < Theorem pruned_env_reification_env : 
forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
  pruned_env nil FVs SL SL' -> reified_env SL' Ty -> {mapenv FVs Map PE} ->
  {CL |- cof PE Ty}.


  ============================
   forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
     pruned_env nil FVs SL SL' -> reified_env SL' Ty ->
     {mapenv FVs Map PE} -> {CL |- cof PE Ty}

pruned_env_reification_env < induction on 3.


  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  ============================
   forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
     pruned_env nil FVs SL SL' @ -> reified_env SL' Ty ->
     {mapenv FVs Map PE} -> {CL |- cof PE Ty}

pruned_env_reification_env < intros.

  Variables: CL, Map, SL, SL', Ty, PE, FVs
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H3 : pruned_env nil FVs SL SL' @
  H4 : reified_env SL' Ty
  H5 : {mapenv FVs Map PE}
  ============================
   {CL |- cof PE Ty}

pruned_env_reification_env < case H3.
Subgoal 1:

  Variables: CL, Map, SL, SL', Ty, PE, FVs
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H4 : reified_env nil Ty
  H5 : {mapenv tl_nil Map PE}
  ============================
   {CL |- cof PE Ty}

Subgoal 2 is:
 {CL |- cof PE Ty}

pruned_env_reification_env < case H4.
Subgoal 1:

  Variables: CL, Map, SL, SL', Ty, PE, FVs
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H5 : {mapenv tl_nil Map PE}
  ============================
   {CL |- cof PE unit_t}

Subgoal 2 is:
 {CL |- cof PE Ty}

pruned_env_reification_env < case H5.
Subgoal 1:

  Variables: CL, Map, SL, SL', Ty, PE, FVs
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  ============================
   {CL |- cof unit unit_t}

Subgoal 2 is:
 {CL |- cof PE Ty}

pruned_env_reification_env < search.
Subgoal 2:

  Variables: CL, Map, SL, SL', Ty, PE, FVs, SL'1, T, X, FVs1
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H4 : reified_env (of X T :: SL'1) Ty
  H5 : {mapenv (tl_cons X FVs1) Map PE}
  H6 : member (of X T) SL
  H7 : pruned_env nil FVs1 SL SL'1 *
  ============================
   {CL |- cof PE Ty}

pruned_env_reification_env < case H5.
Subgoal 2:

  Variables: CL, Map, SL, SL', Ty, PE, FVs, SL'1, T, X, FVs1, ML, M
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H4 : reified_env (of X T :: SL'1) Ty
  H6 : member (of X T) SL
  H7 : pruned_env nil FVs1 SL SL'1 *
  H8 : {ml_member (map X M) Map}
  H9 : {mapenv FVs1 Map ML}
  ============================
   {CL |- cof (cross M ML) Ty}

pruned_env_reification_env < case H4.
Subgoal 2:

  Variables: CL, Map, SL, SL', Ty, PE, FVs, SL'1, T, X, FVs1, ML, M, RT
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H6 : member (of X T) SL
  H7 : pruned_env nil FVs1 SL SL'1 *
  H8 : {ml_member (map X M) Map}
  H9 : {mapenv FVs1 Map ML}
  H10 : reified_env SL'1 RT
  ============================
   {CL |- cof (cross M ML) (product T RT)}

pruned_env_reification_env < apply of_ml_member_type to H1 H2 H8 H6.
Subgoal 2:

  Variables: CL, Map, SL, SL', Ty, PE, FVs, SL'1, T, X, FVs1, ML, M, RT
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H6 : member (of X T) SL
  H7 : pruned_env nil FVs1 SL SL'1 *
  H8 : {ml_member (map X M) Map}
  H9 : {mapenv FVs1 Map ML}
  H10 : reified_env SL'1 RT
  H11 : {CL |- cof M T}
  ============================
   {CL |- cof (cross M ML) (product T RT)}

pruned_env_reification_env < apply IH to H1 H2 H7 H10 H9.
Subgoal 2:

  Variables: CL, Map, SL, SL', Ty, PE, FVs, SL'1, T, X, FVs1, ML, M, RT
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H6 : member (of X T) SL
  H7 : pruned_env nil FVs1 SL SL'1 *
  H8 : {ml_member (map X M) Map}
  H9 : {mapenv FVs1 Map ML}
  H10 : reified_env SL'1 RT
  H11 : {CL |- cof M T}
  H12 : {CL |- cof ML RT}
  ============================
   {CL |- cof (cross M ML) (product T RT)}

pruned_env_reification_env < search.
Proof completed.

Abella < Theorem type_pres : 
forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
  {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs} -> {CL |- cof N T}.


  ============================
   forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
     {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs} ->
     {CL |- cof N T}

type_pres < induction on 6.


  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  ============================
   forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
     {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}@ ->
     {CL |- cof N T}

type_pres < intros.

  Variables: SL, CL, Map, M, N, T, Vs
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of M T}
  H5 : vars_of_sctx SL Vs
  H6 : {cc M N Map Vs}@
  ============================
   {CL |- cof N T}

type_pres < case H6.
Subgoal 1:

  Variables: SL, CL, Map, M, N, T, Vs
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of M T}
  H5 : vars_of_sctx SL Vs
  H7 : {ml_member (map M N) Map}*
  ============================
   {CL |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply map_name to H3 H7.
Subgoal 1:

  Variables: SL, CL, Map, M, N, T, Vs
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of M T}
  H5 : vars_of_sctx SL Vs
  H7 : {ml_member (map M N) Map}*
  H8 : tname M
  ============================
   {CL |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H8.
Subgoal 1:

  Variables: SL, CL, Map, M, N, T, Vs
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H4 : {SL n1 |- of n1 T}
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H4.
Subgoal 1:

  Variables: SL, CL, Map, M, N, T, Vs, F
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  H9 : {SL n1, [F n1] |- of n1 T}
  H10 : member (F n1) (SL n1)
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply sctx'_mem to H1 H10.
Subgoal 1:

  Variables: SL, CL, Map, M, N, T, Vs, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  H9 : {SL n1, [of (X n1) T1] |- of n1 T}
  H10 : member (of (X n1) T1) (SL n1)
  H11 : tname (X n1)
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H11.
Subgoal 1.1:

  Variables: SL, CL, Map, M, N, T, Vs, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n2 n1)
  H2 : cctx (CL n2 n1)
  H3 : of_ml (CL n2 n1) (Map n2 n1) (SL n2 n1)
  H5 : vars_of_sctx (SL n2 n1) (Vs n2 n1)
  H7 : {ml_member (map n1 N) (Map n2 n1)}*
  H9 : {SL n2 n1, [of n2 T1] |- of n1 T}
  H10 : member (of n2 T1) (SL n2 n1)
  ============================
   {CL n2 n1 |- cof N T}

Subgoal 1.2 is:
 {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H9.
Subgoal 1.2:

  Variables: SL, CL, Map, M, N, T, Vs, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  H9 : {SL n1, [of n1 T1] |- of n1 T}
  H10 : member (of n1 T1) (SL n1)
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H9.
Subgoal 1.2:

  Variables: SL, CL, Map, M, N, T, Vs, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  H10 : member (of n1 T) (SL n1)
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply of_ml_member_type to H1 H3 H7 H10.
Subgoal 1.2:

  Variables: SL, CL, Map, M, N, T, Vs, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  H10 : member (of n1 T) (SL n1)
  H12 : {CL n1 |- cof N T}
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < search.
Subgoal 2:

  Variables: SL, CL, Map, M, N, T, Vs, N1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (lnat N1) T}
  H5 : vars_of_sctx SL Vs
  ============================
   {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H4.
Subgoal 2.1:

  Variables: SL, CL, Map, M, N, T, Vs, N1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  ============================
   {CL |- cof (clnat N1) nat_t}

Subgoal 2.2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < search.
Subgoal 2.2:

  Variables: SL, CL, Map, M, N, T, Vs, N1, F
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL, [F] |- of (lnat N1) T}
  H8 : member F SL
  ============================
   {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply sctx'_mem to H1 H8.
Subgoal 2.2:

  Variables: SL, CL, Map, M, N, T, Vs, N1, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL, [of X T1] |- of (lnat N1) T}
  H8 : member (of X T1) SL
  H9 : tname X
  ============================
   {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H9.
Subgoal 2.2:

  Variables: SL, CL, Map, M, N, T, Vs, N1, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {SL n1, [of n1 T1] |- of (lnat N1) T}
  H8 : member (of n1 T1) (SL n1)
  ============================
   {CL n1 |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H7.
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < assert bvars nil.
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply fvars_subset to H11 H7.
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply pruned_env_exists to H1 H5 H12.
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL'
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply fvars_islist to H11 H7.
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL'
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply subset_refl to H14.
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL'
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply pruned_env_typing to H1 H4 H5 H11 H7 H15 H13.
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL'
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H16 : {SL' |- of (abs M1) T}
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply pruned_env_sctx to H1 H11 H13.
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL'
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H16 : {SL' |- of (abs M1) T}
  H17 : sctx' SL'
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply reified_env_exists to H17.
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H16 : {SL' |- of (abs M1) T}
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply pruned_env_reification_type to H13 H17 H9 H18.
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H16 : {SL' |- of (abs M1) T}
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H16.
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < assert tname n1.
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply of_ml_extend_map to H19 H21 with X = n1, Y = n2, T = T1.
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply pruned_env_vars to H13.
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < assert vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs).
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply sctx'_extend to H17 with T = T1.
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H25 : sctx' (of n1 T1 :: SL')
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < assert cctx (cof n2 T1 :: cof n3 Ty :: nil).
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H25 : sctx' (of n1 T1 :: SL')
  H26 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply IH to H25 H26 H22 H20 H24 H10.
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H25 : sctx' (of n1 T1 :: SL')
  H26 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  H27 : {cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < assert {CL, cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}.
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H25 : sctx' (of n1 T1 :: SL')
  H26 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  H27 : {cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  H28 : {CL, cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply pruned_env_reification_env to H1 H3 H13 H18 H8.
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H25 : sctx' (of n1 T1 :: SL')
  H26 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  H27 : {cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  H28 : {CL, cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  H29 : {CL |- cof PE Ty}
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < search 10.
Subgoal 3.2:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, F
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', [F] |- of (abs M1) T}
  H21 : member F SL'
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply sctx'_mem to H17 H21.
Subgoal 3.2:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, F, X,
             T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', [of X T1] |- of (abs M1) T}
  H21 : member (of X T1) SL'
  H22 : tname X
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H22.
Subgoal 3.2:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, F, X,
             T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n4)
  H2 : cctx (CL n4)
  H3 : of_ml (CL n4) (Map n4) (SL n4)
  H4 : {SL n4 |- of (abs (M1 n4)) T}
  H5 : vars_of_sctx (SL n4) (Vs n4)
  H7 : {fvars (abs (M1 n4)) (Vs n4) (NFVs n4)}*
  H8 : {mapenv (NFVs n4) (Map n4) PE}*
  H9 : {mapvar (NFVs n4) n1 (NMap n4 n1)}*
  H10 : {cc (M1 n4 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n4 n3)) (tl_cons n1 (NFVs n4))}*
  H11 : bvars nil
  H12 : subset (NFVs n4) (Vs n4)
  H13 : pruned_env nil (NFVs n4) (SL n4) (SL' n4)
  H14 : islist (NFVs n4)
  H15 : subset (NFVs n4) (NFVs n4)
  H17 : sctx' (SL' n4)
  H18 : reified_env (SL' n4) Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n4 n1) (SL' n4)
  H20 : {SL' n4, [of n4 T1] |- of (abs (M1 n4)) T}
  H21 : member (of n4 T1) (SL' n4)
  ============================
   {CL n4 |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H20.
Subgoal 4:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (app M1 M2) T}
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H4.
Subgoal 4.1:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  H9 : {SL |- of M1 (arr T1 T)}
  H10 : {SL |- of M2 T1}
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 4.2 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply IH to H1 H2 H3 H9 H5 H7.
Subgoal 4.1:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  H9 : {SL |- of M1 (arr T1 T)}
  H10 : {SL |- of M2 T1}
  H11 : {CL |- cof CM1 (arr T1 T)}
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 4.2 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply IH to H1 H2 H3 H10 H5 H8.
Subgoal 4.1:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  H9 : {SL |- of M1 (arr T1 T)}
  H10 : {SL |- of M2 T1}
  H11 : {CL |- cof CM1 (arr T1 T)}
  H12 : {CL |- cof CM2 T1}
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 4.2 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < search.
Subgoal 4.2:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, F
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  H9 : {SL, [F] |- of (app M1 M2) T}
  H10 : member F SL
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < apply sctx'_mem to H1 H10.
Subgoal 4.2:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  H9 : {SL, [of X T1] |- of (app M1 M2) T}
  H10 : member (of X T1) SL
  H11 : tname X
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H11.
Subgoal 4.2:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {cc (M1 n1) CM1 (Map n1) (Vs n1)}*
  H8 : {cc (M2 n1) CM2 (Map n1) (Vs n1)}*
  H9 : {SL n1, [of n1 T1] |- of (app (M1 n1) (M2 n1)) T}
  H10 : member (of n1 T1) (SL n1)
  ============================
   {CL n1 |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < case H9.
Subgoal 5:

  Variables: SL, CL, Map, M, N, T, Vs, C
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (cst C) T}
  H5 : vars_of_sctx SL Vs
  ============================
   {CL |- cof (ccst C) T}

type_pres < case H4.
Subgoal 5.1:

  Variables: SL, CL, Map, M, N, T, Vs, C
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL |- of_const C T}
  ============================
   {CL |- cof (ccst C) T}

Subgoal 5.2 is:
 {CL |- cof (ccst C) T}

type_pres < apply of_const_sctx' to H1 H7.
Subgoal 5.1:

  Variables: SL, CL, Map, M, N, T, Vs, C
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL |- of_const C T}
  H8 : {of_const C T}
  ============================
   {CL |- cof (ccst C) T}

Subgoal 5.2 is:
 {CL |- cof (ccst C) T}

type_pres < apply presv_const_typ to H8.
Subgoal 5.1:

  Variables: SL, CL, Map, M, N, T, Vs, C
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL |- of_const C T}
  H8 : {of_const C T}
  H9 : {cof_const C T}
  ============================
   {CL |- cof (ccst C) T}

Subgoal 5.2 is:
 {CL |- cof (ccst C) T}

type_pres < search.
Subgoal 5.2:

  Variables: SL, CL, Map, M, N, T, Vs, C, F
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL, [F] |- of (cst C) T}
  H8 : member F SL
  ============================
   {CL |- cof (ccst C) T}

type_pres < apply sctx'_mem to H1 H8.
Subgoal 5.2:

  Variables: SL, CL, Map, M, N, T, Vs, C, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL, [of X T1] |- of (cst C) T}
  H8 : member (of X T1) SL
  H9 : tname X
  ============================
   {CL |- cof (ccst C) T}

type_pres < case H7.
Subgoal 5.2:

  Variables: SL, CL, Map, M, N, T, Vs, C, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H8 : member (of (cst C) T) SL
  H9 : tname (cst C)
  ============================
   {CL |- cof (ccst C) T}

type_pres < case H9.
Proof completed.

Abella < Theorem type_pres' : 
forall M N T, {of M T} -> {cc' M N} -> {cof N T}.


  ============================
   forall M N T, {of M T} -> {cc' M N} -> {cof N T}

type_pres' < intros.

  Variables: M, N, T
  H1 : {of M T}
  H2 : {cc' M N}
  ============================
   {cof N T}

type_pres' < case H2.

  Variables: M, N, T
  H1 : {of M T}
  H3 : {cc M N ml_nil tl_nil}
  ============================
   {cof N T}

type_pres' < apply type_pres to _ _ _ H1 _ H3.

  Variables: M, N, T
  H1 : {of M T}
  H3 : {cc M N ml_nil tl_nil}
  H4 : {cof N T}
  ============================
   {cof N T}

type_pres' < search.
Proof completed.

Abella < Define name_map : map_list -> prop by 
name_map ml_nil;
name_map (ml_cons (map X V) ML) := name_map ML /\ tname X.

Abella < Theorem name_map_nominal : 
forall Map X V, name_map Map -> {ml_member (map X V) Map} -> tname X.


  ============================
   forall Map X V, name_map Map -> {ml_member (map X V) Map} -> tname X

name_map_nominal < induction on 1.


  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  ============================
   forall Map X V, name_map Map @ -> {ml_member (map X V) Map} -> tname X

name_map_nominal < intros.

  Variables: Map, X, V
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H1 : name_map Map @
  H2 : {ml_member (map X V) Map}
  ============================
   tname X

name_map_nominal < case H1.
Subgoal 1:

  Variables: Map, X, V
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H2 : {ml_member (map X V) ml_nil}
  ============================
   tname X

Subgoal 2 is:
 tname X

name_map_nominal < case H2.
Subgoal 2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H2 : {ml_member (map X V) (ml_cons (map X1 V1) ML)}
  H3 : name_map ML *
  H4 : tname X1
  ============================
   tname X

name_map_nominal < case H2.
Subgoal 2.1:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

name_map_nominal < search.
Subgoal 2.2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  H5 : {ml_member (map X V) ML}
  ============================
   tname X

name_map_nominal < apply IH to H3 H5.
Subgoal 2.2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  H5 : {ml_member (map X V) ML}
  H6 : tname X
  ============================
   tname X

name_map_nominal < search.
Proof completed.

Abella < Theorem clos_closed : 
forall SL Map R F E T1 T2 Vs, sctx' SL -> name_map Map ->
  {SL |- of (abs R) (arr T1 T2)} -> vars_of_sctx SL Vs ->
  {cc (abs R) (cpair F E) Map Vs} -> (exists TE,
  {cof F (code (product T1 TE) T2)}).


  ============================
   forall SL Map R F E T1 T2 Vs, sctx' SL -> name_map Map ->
     {SL |- of (abs R) (arr T1 T2)} -> vars_of_sctx SL Vs ->
     {cc (abs R) (cpair F E) Map Vs} -> (exists TE,
     {cof F (code (product T1 TE) T2)})

clos_closed < intros.

  Variables: SL, Map, R, F, E, T1, T2, Vs
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H5 : {cc (abs R) (cpair F E) Map Vs}
  ============================
   exists TE, {cof F (code (product T1 TE) T2)}

clos_closed < case H5.
Subgoal 1:

  Variables: SL, Map, R, F, E, T1, T2, Vs
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {ml_member (map (abs R) (cpair F E)) Map}
  ============================
   exists TE, {cof F (code (product T1 TE) T2)}

Subgoal 2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply name_map_nominal to H2 H6.
Subgoal 1:

  Variables: SL, Map, R, F, E, T1, T2, Vs
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {ml_member (map (abs R) (cpair F E)) Map}
  H7 : tname (abs R)
  ============================
   exists TE, {cof F (code (product T1 TE) T2)}

Subgoal 2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < case H7.
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < assert bvars nil.
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply fvars_subset to H10 H6.
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply pruned_env_exists to H1 H4 H11.
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL'
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply fvars_islist to H10 H6.
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL'
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply subset_refl to H13.
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL'
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply pruned_env_typing to H1 H3 H4 H10 H6 H14 H12.
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL'
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H15 : {SL' |- of (abs R) (arr T1 T2)}
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply pruned_env_sctx to H1 H10 H12.
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL'
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H15 : {SL' |- of (abs R) (arr T1 T2)}
  H16 : sctx' SL'
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply reified_env_exists to H16.
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H15 : {SL' |- of (abs R) (arr T1 T2)}
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply pruned_env_reification_type to H12 H16 H8 H17.
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H15 : {SL' |- of (abs R) (arr T1 T2)}
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < case H15.
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < assert tname n1.
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply of_ml_extend_map to H18 H20 with X = n1, Y = n2, T = T1.
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply pruned_env_vars to H12.
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H22 : vars_of_sctx SL' NFVs
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < assert vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs).
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H22 : vars_of_sctx SL' NFVs
  H23 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply sctx'_extend to H16 with T = T1.
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H22 : vars_of_sctx SL' NFVs
  H23 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H24 : sctx' (of n1 T1 :: SL')
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < assert cctx (cof n2 T1 :: cof n3 Ty :: nil).
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H22 : vars_of_sctx SL' NFVs
  H23 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H24 : sctx' (of n1 T1 :: SL')
  H25 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply type_pres to H24 H25 H21 H19 H23 H9.
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H22 : vars_of_sctx SL' NFVs
  H23 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H24 : sctx' (of n1 T1 :: SL')
  H25 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  H26 : {cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < search.
Subgoal 2.2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty, F1
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', [F1] |- of (abs R) (arr T1 T2)}
  H20 : member F1 SL'
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < apply sctx'_mem to H16 H20.
Subgoal 2.2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty, F1, X, T
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', [of X T] |- of (abs R) (arr T1 T2)}
  H20 : member (of X T) SL'
  H21 : tname X
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < case H19.
Subgoal 2.2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty, F1, X, T
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : member (of (abs R) (arr T1 T2)) SL'
  H21 : tname (abs R)
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < case H21.
Proof completed.

Abella < Goodbye.
