
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Abella: Specification "cc". - Details</title>
<link href="http://abella-prover.org/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="http://abella-prover.org/images/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="http://abella-prover.org/images/favicon.ico"
        type="image/x-icon" />
</head>

<body>

<div id="logo-small">
<a href="http://abella-prover.org/index.html">
<img src="http://abella-prover.org/images/logo-small.png"/>
</a>
</div>

<div class="section">
Welcome to Abella 2.0.2-dev
<a name="1"></a>
<pre class="code">
Abella < <b>Specification "cc".</b>
Reading specification "cc"
</pre>
<a name="2"></a>
<pre class="code">
Abella < <b>Close const, nat, tm, ctm, ty.</b>
</pre>
<a name="3"></a>
<pre class="code">
Abella < <b>Define tname : tm -> prop by 
nabla n, tname n.</b>
</pre>
<a name="4"></a>
<pre class="code">
Abella < <b>Theorem mem_of_absurd : 
forall T L, nabla x, member (of x T) L -> false.</b>
</pre>
<a name="5"></a>
<pre>


  ============================
   forall T L, nabla x, member (of x T) L -> false

mem_of_absurd < <b>induction on 1.</b>
</pre>
<a name="6"></a>
<pre>


  IH : forall T L, nabla x, member (of x T) L * -> false
  ============================
   forall T L, nabla x, member (of x T) L @ -> false

mem_of_absurd < <b>intros.</b>
</pre>
<a name="7"></a>
<pre>

  Variables: T, L
  IH : forall T L, nabla x, member (of x T) L * -> false
  H1 : member (of n1 T) L @
  ============================
   false

mem_of_absurd < <b>case H1.</b>
</pre>
<a name="8"></a>
<pre>

  Variables: T, L, L3, L2
  IH : forall T L, nabla x, member (of x T) L * -> false
  H2 : member (of n1 T) L3 *
  ============================
   false

mem_of_absurd < <b>apply IH to H2.</b>
Proof completed.
</pre>
<a name="9"></a>
<pre class="code">
Abella < <b>Theorem ml_mem_absurd : 
forall M ML, nabla x, {ml_member (map x M) ML} -> false.</b>
</pre>
<a name="10"></a>
<pre>


  ============================
   forall M ML, nabla x, {ml_member (map x M) ML} -> false

ml_mem_absurd < <b>induction on 1.</b>
</pre>
<a name="11"></a>
<pre>


  IH : forall M ML, nabla x, {ml_member (map x M) ML}* -> false
  ============================
   forall M ML, nabla x, {ml_member (map x M) ML}@ -> false

ml_mem_absurd < <b>intros.</b>
</pre>
<a name="12"></a>
<pre>

  Variables: M, ML
  IH : forall M ML, nabla x, {ml_member (map x M) ML}* -> false
  H1 : {ml_member (map n1 M) ML}@
  ============================
   false

ml_mem_absurd < <b>case H1.</b>
</pre>
<a name="13"></a>
<pre>

  Variables: M, ML, ML2, ML1
  IH : forall M ML, nabla x, {ml_member (map x M) ML}* -> false
  H2 : {ml_member (map n1 M) ML2}*
  ============================
   false

ml_mem_absurd < <b>apply IH to H2.</b>
Proof completed.
</pre>
<a name="14"></a>
<pre class="code">
Abella < <b>Define sctx : olist -> prop by 
sctx nil;
nabla x, sctx (of x T :: L) := sctx L.</b>
</pre>
<a name="15"></a>
<pre class="code">
Abella < <b>Define sctx' : olist -> prop by 
sctx' nil;
sctx' (of X T :: L) := sctx' L /\ tname X /\ (forall T', member (of X T') L -> T = T').</b>
</pre>
<a name="16"></a>
<pre class="code">
Abella < <b>Theorem sctx'_name : 
forall X T L, sctx' L -> member (of X T) L -> tname X.</b>
</pre>
<a name="17"></a>
<pre>


  ============================
   forall X T L, sctx' L -> member (of X T) L -> tname X

sctx'_name < <b>induction on 1.</b>
</pre>
<a name="18"></a>
<pre>


  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  ============================
   forall X T L, sctx' L @ -> member (of X T) L -> tname X

sctx'_name < <b>intros.</b>
</pre>
<a name="19"></a>
<pre>

  Variables: X, T, L
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H1 : sctx' L @
  H2 : member (of X T) L
  ============================
   tname X

sctx'_name < <b>case H1.</b>
</pre>
<a name="20"></a>
<pre>
Subgoal 1:

  Variables: X, T, L
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H2 : member (of X T) nil
  ============================
   tname X

Subgoal 2 is:
 tname X

sctx'_name < <b>case H2.</b>
</pre>
<a name="21"></a>
<pre>
Subgoal 2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H2 : member (of X T) (of X1 T1 :: L1)
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   tname X

sctx'_name < <b>case H2.</b>
</pre>
<a name="22"></a>
<pre>
Subgoal 2.1:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

sctx'_name < <b>search.</b>
</pre>
<a name="23"></a>
<pre>
Subgoal 2.2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  H6 : member (of X T) L1
  ============================
   tname X

sctx'_name < <b>apply IH to H3 H6.</b>
</pre>
<a name="24"></a>
<pre>
Subgoal 2.2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  H6 : member (of X T) L1
  H7 : tname X
  ============================
   tname X

sctx'_name < <b>search.</b>
Proof completed.
</pre>
<a name="25"></a>
<pre class="code">
Abella < <b>Theorem sctx'_mem : 
forall SL O, sctx' SL -> member O SL -> (exists X T, O = of X T /\ tname X).</b>
</pre>
<a name="26"></a>
<pre>


  ============================
   forall SL O, sctx' SL -> member O SL -> (exists X T, O = of X T /\
     tname X)

sctx'_mem < <b>induction on 1.</b>
</pre>
<a name="27"></a>
<pre>


  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  ============================
   forall SL O, sctx' SL @ -> member O SL -> (exists X T, O = of X T /\
     tname X)

sctx'_mem < <b>intros.</b>
</pre>
<a name="28"></a>
<pre>

  Variables: SL, O
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H1 : sctx' SL @
  H2 : member O SL
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < <b>case H1.</b>
</pre>
<a name="29"></a>
<pre>
Subgoal 1:

  Variables: SL, O
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H2 : member O nil
  ============================
   exists X T, O = of X T /\ tname X

Subgoal 2 is:
 exists X T, O = of X T /\ tname X

sctx'_mem < <b>case H2.</b>
</pre>
<a name="30"></a>
<pre>
Subgoal 2:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H2 : member O (of X T :: L)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < <b>case H2.</b>
</pre>
<a name="31"></a>
<pre>
Subgoal 2.1:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  ============================
   exists X1 T1, of X T = of X1 T1 /\ tname X1

Subgoal 2.2 is:
 exists X T, O = of X T /\ tname X

sctx'_mem < <b>search.</b>
</pre>
<a name="32"></a>
<pre>
Subgoal 2.2:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  H6 : member O L
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < <b>apply IH to H3 H6.</b>
</pre>
<a name="33"></a>
<pre>
Subgoal 2.2:

  Variables: SL, O, L, T, X, X1, T1
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  H6 : member (of X1 T1) L
  H7 : tname X1
  ============================
   exists X T, of X1 T1 = of X T /\ tname X

sctx'_mem < <b>search.</b>
Proof completed.
</pre>
<a name="34"></a>
<pre class="code">
Abella < <b>Theorem sctx'_extend : 
forall L T, nabla x, sctx' L -> sctx' (of x T :: L).</b>
</pre>
<a name="35"></a>
<pre>


  ============================
   forall L T, nabla x, sctx' L -> sctx' (of x T :: L)

sctx'_extend < <b>intros.</b>
</pre>
<a name="36"></a>
<pre>

  Variables: L, T
  H1 : sctx' L
  ============================
   sctx' (of n1 T :: L)

sctx'_extend < <b>unfold.</b>
</pre>
<a name="37"></a>
<pre>
Subgoal 1:

  Variables: L, T
  H1 : sctx' L
  ============================
   sctx' L

Subgoal 2 is:
 tname n1

Subgoal 3 is:
 forall T', member (of n1 T') L -> T = T'

sctx'_extend < <b>search.</b>
</pre>
<a name="38"></a>
<pre>
Subgoal 2:

  Variables: L, T
  H1 : sctx' L
  ============================
   tname n1

Subgoal 3 is:
 forall T', member (of n1 T') L -> T = T'

sctx'_extend < <b>search.</b>
</pre>
<a name="39"></a>
<pre>
Subgoal 3:

  Variables: L, T
  H1 : sctx' L
  ============================
   forall T', member (of n1 T') L -> T = T'

sctx'_extend < <b>intros.</b>
</pre>
<a name="40"></a>
<pre>
Subgoal 3:

  Variables: L, T, T'
  H1 : sctx' L
  H2 : member (of n1 T') L
  ============================
   T = T'

sctx'_extend < <b>apply mem_of_absurd to H2.</b>
Proof completed.
</pre>
<a name="41"></a>
<pre class="code">
Abella < <b>Theorem sctx'_equal : 
forall X T T' L, sctx' L -> member (of X T) L -> member (of X T') L -> T = T'.</b>
</pre>
<a name="42"></a>
<pre>


  ============================
   forall X T T' L, sctx' L -> member (of X T) L -> member (of X T') L ->
     T = T'

sctx'_equal < <b>induction on 1.</b>
</pre>
<a name="43"></a>
<pre>


  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  ============================
   forall X T T' L, sctx' L @ -> member (of X T) L -> member (of X T') L ->
     T = T'

sctx'_equal < <b>intros.</b>
</pre>
<a name="44"></a>
<pre>

  Variables: X, T, T', L
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H1 : sctx' L @
  H2 : member (of X T) L
  H3 : member (of X T') L
  ============================
   T = T'

sctx'_equal < <b>case H1.</b>
</pre>
<a name="45"></a>
<pre>
Subgoal 1:

  Variables: X, T, T', L
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H2 : member (of X T) nil
  H3 : member (of X T') nil
  ============================
   T = T'

Subgoal 2 is:
 T = T'

sctx'_equal < <b>case H2.</b>
</pre>
<a name="46"></a>
<pre>
Subgoal 2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H2 : member (of X T) (of X1 T1 :: L1)
  H3 : member (of X T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T = T'

sctx'_equal < <b>case H2.</b>
</pre>
<a name="47"></a>
<pre>
Subgoal 2.1:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H3 : member (of X1 T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < <b>case H3.</b>
</pre>
<a name="48"></a>
<pre>
Subgoal 2.1.1:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T1 = T1

Subgoal 2.1.2 is:
 T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < <b>search.</b>
</pre>
<a name="49"></a>
<pre>
Subgoal 2.1.2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X1 T') L1
  ============================
   T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < <b>apply H6 to H7.</b>
</pre>
<a name="50"></a>
<pre>
Subgoal 2.1.2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T'1, member (of X1 T'1) L1 -> T' = T'1
  H7 : member (of X1 T') L1
  ============================
   T' = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < <b>search.</b>
</pre>
<a name="51"></a>
<pre>
Subgoal 2.2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H3 : member (of X T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T) L1
  ============================
   T = T'

sctx'_equal < <b>case H3.</b>
</pre>
<a name="52"></a>
<pre>
Subgoal 2.2.1:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X1 T) L1
  ============================
   T = T1

Subgoal 2.2.2 is:
 T = T'

sctx'_equal < <b>apply H6 to H7.</b>
</pre>
<a name="53"></a>
<pre>
Subgoal 2.2.1:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  H7 : member (of X1 T) L1
  ============================
   T = T

Subgoal 2.2.2 is:
 T = T'

sctx'_equal < <b>search.</b>
</pre>
<a name="54"></a>
<pre>
Subgoal 2.2.2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T) L1
  H8 : member (of X T') L1
  ============================
   T = T'

sctx'_equal < <b>apply IH to H4 H7 H8.</b>
</pre>
<a name="55"></a>
<pre>
Subgoal 2.2.2:

  Variables: X, T, T', L, L1, T1, X1
  IH : forall X T T' L, sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T') L1
  H8 : member (of X T') L1
  ============================
   T' = T'

sctx'_equal < <b>search.</b>
Proof completed.
</pre>
<a name="56"></a>
<pre class="code">
Abella < <b>Theorem of_const_sctx' : 
forall L C T, sctx' L -> {L |- of_const C T} -> {of_const C T}.</b>
</pre>
<a name="57"></a>
<pre>


  ============================
   forall L C T, sctx' L -> {L |- of_const C T} -> {of_const C T}

of_const_sctx' < <b>induction on 2.</b>
</pre>
<a name="58"></a>
<pre>


  IH : forall L C T, sctx' L -> {L |- of_const C T}* -> {of_const C T}
  ============================
   forall L C T, sctx' L -> {L |- of_const C T}@ -> {of_const C T}

of_const_sctx' < <b>intros.</b>
</pre>
<a name="59"></a>
<pre>

  Variables: L, C, T
  IH : forall L C T, sctx' L -> {L |- of_const C T}* -> {of_const C T}
  H1 : sctx' L
  H2 : {L |- of_const C T}@
  ============================
   {of_const C T}

of_const_sctx' < <b>case H2.</b>
</pre>
<a name="60"></a>
<pre>
Subgoal 1:

  Variables: L, C, T
  IH : forall L C T, sctx' L -> {L |- of_const C T}* -> {of_const C T}
  H1 : sctx' L
  ============================
   {of_const s++ (arr nat_t (arr nat_t nat_t))}

Subgoal 2 is:
 {of_const C T}

of_const_sctx' < <b>search.</b>
</pre>
<a name="61"></a>
<pre>
Subgoal 2:

  Variables: L, C, T, F
  IH : forall L C T, sctx' L -> {L |- of_const C T}* -> {of_const C T}
  H1 : sctx' L
  H3 : {L, [F] |- of_const C T}*
  H4 : member F L
  ============================
   {of_const C T}

of_const_sctx' < <b>apply sctx'_mem to H1 H4.</b>
</pre>
<a name="62"></a>
<pre>
Subgoal 2:

  Variables: L, C, T, F, X, T1
  IH : forall L C T, sctx' L -> {L |- of_const C T}* -> {of_const C T}
  H1 : sctx' L
  H3 : {L, [of X T1] |- of_const C T}*
  H4 : member (of X T1) L
  H5 : tname X
  ============================
   {of_const C T}

of_const_sctx' < <b>case H3.</b>
Proof completed.
</pre>
<a name="63"></a>
<pre class="code">
Abella < <b>Theorem presv_const_typ : 
forall C T, {of_const C T} -> {cof_const C T}.</b>
</pre>
<a name="64"></a>
<pre>


  ============================
   forall C T, {of_const C T} -> {cof_const C T}

presv_const_typ < <b>induction on 1.</b>
</pre>
<a name="65"></a>
<pre>


  IH : forall C T, {of_const C T}* -> {cof_const C T}
  ============================
   forall C T, {of_const C T}@ -> {cof_const C T}

presv_const_typ < <b>intros.</b>
</pre>
<a name="66"></a>
<pre>

  Variables: C, T
  IH : forall C T, {of_const C T}* -> {cof_const C T}
  H1 : {of_const C T}@
  ============================
   {cof_const C T}

presv_const_typ < <b>case H1.</b>
</pre>
<a name="67"></a>
<pre>

  Variables: C, T
  IH : forall C T, {of_const C T}* -> {cof_const C T}
  ============================
   {cof_const s++ (arr nat_t (arr nat_t nat_t))}

presv_const_typ < <b>search.</b>
Proof completed.
</pre>
<a name="68"></a>
<pre class="code">
Abella < <b>Define vars_of_sctx : olist -> tm_list -> prop by 
vars_of_sctx nil tl_nil;
vars_of_sctx (of X T :: L) (tl_cons X Vs) := vars_of_sctx L Vs.</b>
</pre>
<a name="69"></a>
<pre class="code">
Abella < <b>Define cctx : olist -> prop by 
cctx nil;
nabla x, cctx (cof x T :: L) := cctx L;
nabla f env, cctx (cof f (code (product T1 TE) T) :: cof env TE :: L) := cctx L.</b>
</pre>
<a name="70"></a>
<pre class="code">
Abella < <b>Define of_ml : olist -> map_list -> olist -> prop by 
of_ml CL ml_nil nil;
of_ml CL (ml_cons (map X M) ML) (of X T :: SL) := tname X /\ {CL |- cof M T} /\ of_ml CL ML SL.</b>
</pre>
<a name="71"></a>
<pre class="code">
Abella < <b>Theorem of_ml_exists : 
forall CL ML SL X M, of_ml CL ML SL -> {ml_member (map X M) ML} -> (exists T,
  member (of X T) SL).</b>
</pre>
<a name="72"></a>
<pre>


  ============================
   forall CL ML SL X M, of_ml CL ML SL -> {ml_member (map X M) ML} ->
     (exists T, member (of X T) SL)

of_ml_exists < <b>induction on 1.</b>
</pre>
<a name="73"></a>
<pre>


  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  ============================
   forall CL ML SL X M, of_ml CL ML SL @ -> {ml_member (map X M) ML} ->
     (exists T, member (of X T) SL)

of_ml_exists < <b>intros.</b>
</pre>
<a name="74"></a>
<pre>

  Variables: CL, ML, SL, X, M
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H1 : of_ml CL ML SL @
  H2 : {ml_member (map X M) ML}
  ============================
   exists T, member (of X T) SL

of_ml_exists < <b>case H1.</b>
</pre>
<a name="75"></a>
<pre>
Subgoal 1:

  Variables: CL, ML, SL, X, M
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H2 : {ml_member (map X M) ml_nil}
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of X T1) (of X1 T :: SL1)

of_ml_exists < <b>case H2.</b>
</pre>
<a name="76"></a>
<pre>
Subgoal 2:

  Variables: CL, ML, SL, X, M, SL1, T, X1, ML1, M1
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H2 : {ml_member (map X M) (ml_cons (map X1 M1) ML1)}
  H3 : tname X1
  H4 : {CL |- cof M1 T}
  H5 : of_ml CL ML1 SL1 *
  ============================
   exists T1, member (of X T1) (of X1 T :: SL1)

of_ml_exists < <b>case H2.</b>
</pre>
<a name="77"></a>
<pre>
Subgoal 2.1:

  Variables: CL, ML, SL, X, M, SL1, T, X1, ML1, M1
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H3 : tname X1
  H4 : {CL |- cof M1 T}
  H5 : of_ml CL ML1 SL1 *
  ============================
   exists T1, member (of X1 T1) (of X1 T :: SL1)

Subgoal 2.2 is:
 exists T1, member (of X T1) (of X1 T :: SL1)

of_ml_exists < <b>search.</b>
</pre>
<a name="78"></a>
<pre>
Subgoal 2.2:

  Variables: CL, ML, SL, X, M, SL1, T, X1, ML1, M1
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H3 : tname X1
  H4 : {CL |- cof M1 T}
  H5 : of_ml CL ML1 SL1 *
  H6 : {ml_member (map X M) ML1}
  ============================
   exists T1, member (of X T1) (of X1 T :: SL1)

of_ml_exists < <b>apply IH to H5 H6.</b>
</pre>
<a name="79"></a>
<pre>
Subgoal 2.2:

  Variables: CL, ML, SL, X, M, SL1, T, X1, ML1, M1, T1
  IH : forall CL ML SL X M, of_ml CL ML SL * -> {ml_member (map X M) ML} ->
         (exists T, member (of X T) SL)
  H3 : tname X1
  H4 : {CL |- cof M1 T}
  H5 : of_ml CL ML1 SL1 *
  H6 : {ml_member (map X M) ML1}
  H7 : member (of X T1) SL1
  ============================
   exists T1, member (of X T1) (of X1 T :: SL1)

of_ml_exists < <b>search.</b>
Proof completed.
</pre>
<a name="80"></a>
<pre class="code">
Abella < <b>Theorem of_ml_member_type : 
forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL ->
  {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}.</b>
</pre>
<a name="81"></a>
<pre>


  ============================
   forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL ->
     {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}

of_ml_member_type < <b>induction on 2.</b>
</pre>
<a name="82"></a>
<pre>


  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  ============================
   forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL @ ->
     {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}

of_ml_member_type < <b>intros.</b>
</pre>
<a name="83"></a>
<pre>

  Variables: CL, Map, SL, X, M, T
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' SL
  H2 : of_ml CL Map SL @
  H3 : {ml_member (map X M) Map}
  H4 : member (of X T) SL
  ============================
   {CL |- cof M T}

of_ml_member_type < <b>case H2.</b>
</pre>
<a name="84"></a>
<pre>
Subgoal 1:

  Variables: CL, Map, SL, X, M, T
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' nil
  H3 : {ml_member (map X M) ml_nil}
  H4 : member (of X T) nil
  ============================
   {CL |- cof M T}

Subgoal 2 is:
 {CL |- cof M T}

of_ml_member_type < <b>case H4.</b>
</pre>
<a name="85"></a>
<pre>
Subgoal 2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H3 : {ml_member (map X M) (ml_cons (map X1 M1) ML)}
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  ============================
   {CL |- cof M T}

of_ml_member_type < <b>case H1 (keep).</b>
</pre>
<a name="86"></a>
<pre>
Subgoal 2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H3 : {ml_member (map X M) (ml_cons (map X1 M1) ML)}
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  ============================
   {CL |- cof M T}

of_ml_member_type < <b>case H3.</b>
</pre>
<a name="87"></a>
<pre>
Subgoal 2.1:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X1 T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  ============================
   {CL |- cof M1 T}

Subgoal 2.2 is:
 {CL |- cof M T}

of_ml_member_type < <b>case H4.</b>
</pre>
<a name="88"></a>
<pre>
Subgoal 2.1.1:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  ============================
   {CL |- cof M1 T1}

Subgoal 2.1.2 is:
 {CL |- cof M1 T}

Subgoal 2.2 is:
 {CL |- cof M T}

of_ml_member_type < <b>search.</b>
</pre>
<a name="89"></a>
<pre>
Subgoal 2.1.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : member (of X1 T) SL1
  ============================
   {CL |- cof M1 T}

Subgoal 2.2 is:
 {CL |- cof M T}

of_ml_member_type < <b>apply H10 to H11.</b>
</pre>
<a name="90"></a>
<pre>
Subgoal 2.1.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T = T'
  H11 : member (of X1 T) SL1
  ============================
   {CL |- cof M1 T}

Subgoal 2.2 is:
 {CL |- cof M T}

of_ml_member_type < <b>search.</b>
</pre>
<a name="91"></a>
<pre>
Subgoal 2.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : {ml_member (map X M) ML}
  ============================
   {CL |- cof M T}

of_ml_member_type < <b>apply of_ml_exists to H7 H11.</b>
</pre>
<a name="92"></a>
<pre>
Subgoal 2.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1, T2
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : {ml_member (map X M) ML}
  H12 : member (of X T2) SL1
  ============================
   {CL |- cof M T}

of_ml_member_type < <b>apply IH to H8 H7 H11 H12.</b>
</pre>
<a name="93"></a>
<pre>
Subgoal 2.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1, T2
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : {ml_member (map X M) ML}
  H12 : member (of X T2) SL1
  H13 : {CL |- cof M T2}
  ============================
   {CL |- cof M T}

of_ml_member_type < <b>assert member (of X T2) (of X1 T1 :: SL1).</b>
</pre>
<a name="94"></a>
<pre>
Subgoal 2.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1, T2
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X T) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : {ml_member (map X M) ML}
  H12 : member (of X T2) SL1
  H13 : {CL |- cof M T2}
  H14 : member (of X T2) (of X1 T1 :: SL1)
  ============================
   {CL |- cof M T}

of_ml_member_type < <b>apply sctx'_equal to H1 H4 H14.</b>
</pre>
<a name="95"></a>
<pre>
Subgoal 2.2:

  Variables: CL, Map, SL, X, M, T, SL1, T1, X1, ML, M1, T2
  IH : forall CL Map SL X M T, sctx' SL -> of_ml CL Map SL * ->
         {ml_member (map X M) Map} -> member (of X T) SL -> {CL |- cof M T}
  H1 : sctx' (of X1 T1 :: SL1)
  H4 : member (of X T2) (of X1 T1 :: SL1)
  H5 : tname X1
  H6 : {CL |- cof M1 T1}
  H7 : of_ml CL ML SL1 *
  H8 : sctx' SL1
  H9 : tname X1
  H10 : forall T', member (of X1 T') SL1 -> T1 = T'
  H11 : {ml_member (map X M) ML}
  H12 : member (of X T2) SL1
  H13 : {CL |- cof M T2}
  H14 : member (of X T2) (of X1 T1 :: SL1)
  ============================
   {CL |- cof M T2}

of_ml_member_type < <b>search.</b>
Proof completed.
</pre>
<a name="96"></a>
<pre class="code">
Abella < <b>Theorem map_name : 
forall SL CL M X Map, of_ml SL Map CL -> {ml_member (map X M) Map} -> tname X.</b>
</pre>
<a name="97"></a>
<pre>


  ============================
   forall SL CL M X Map, of_ml SL Map CL -> {ml_member (map X M) Map} ->
     tname X

map_name < <b>induction on 1.</b>
</pre>
<a name="98"></a>
<pre>


  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  ============================
   forall SL CL M X Map, of_ml SL Map CL @ -> {ml_member (map X M) Map} ->
     tname X

map_name < <b>intros.</b>
</pre>
<a name="99"></a>
<pre>

  Variables: SL, CL, M, X, Map
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H1 : of_ml SL Map CL @
  H2 : {ml_member (map X M) Map}
  ============================
   tname X

map_name < <b>case H1.</b>
</pre>
<a name="100"></a>
<pre>
Subgoal 1:

  Variables: SL, CL, M, X, Map
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H2 : {ml_member (map X M) ml_nil}
  ============================
   tname X

Subgoal 2 is:
 tname X

map_name < <b>case H2.</b>
</pre>
<a name="101"></a>
<pre>
Subgoal 2:

  Variables: SL, CL, M, X, Map, SL1, T, X1, ML, M1
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H2 : {ml_member (map X M) (ml_cons (map X1 M1) ML)}
  H3 : tname X1
  H4 : {SL |- cof M1 T}
  H5 : of_ml SL ML SL1 *
  ============================
   tname X

map_name < <b>case H2.</b>
</pre>
<a name="102"></a>
<pre>
Subgoal 2.1:

  Variables: SL, CL, M, X, Map, SL1, T, X1, ML, M1
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H3 : tname X1
  H4 : {SL |- cof M1 T}
  H5 : of_ml SL ML SL1 *
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

map_name < <b>search.</b>
</pre>
<a name="103"></a>
<pre>
Subgoal 2.2:

  Variables: SL, CL, M, X, Map, SL1, T, X1, ML, M1
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H3 : tname X1
  H4 : {SL |- cof M1 T}
  H5 : of_ml SL ML SL1 *
  H6 : {ml_member (map X M) ML}
  ============================
   tname X

map_name < <b>apply IH to H5 H6.</b>
</pre>
<a name="104"></a>
<pre>
Subgoal 2.2:

  Variables: SL, CL, M, X, Map, SL1, T, X1, ML, M1
  IH : forall SL CL M X Map, of_ml SL Map CL * ->
         {ml_member (map X M) Map} -> tname X
  H3 : tname X1
  H4 : {SL |- cof M1 T}
  H5 : of_ml SL ML SL1 *
  H6 : {ml_member (map X M) ML}
  H7 : tname X
  ============================
   tname X

map_name < <b>search.</b>
Proof completed.
</pre>
<a name="105"></a>
<pre class="code">
Abella < <b>Theorem map_rst : 
forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL ->
  of_ml (cof X (product T RT) :: nil) M SL.</b>
</pre>
<a name="106"></a>
<pre>


  ============================
   forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL ->
     of_ml (cof X (product T RT) :: nil) M SL

map_rst < <b>induction on 1.</b>
</pre>
<a name="107"></a>
<pre>


  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  ============================
   forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL @ ->
     of_ml (cof X (product T RT) :: nil) M SL

map_rst < <b>intros.</b>
</pre>
<a name="108"></a>
<pre>

  Variables: M, SL, X, T, RT
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  H1 : of_ml (cof (rst X) RT :: nil) M SL @
  ============================
   of_ml (cof X (product T RT) :: nil) M SL

map_rst < <b>case H1.</b>
</pre>
<a name="109"></a>
<pre>
Subgoal 1:

  Variables: M, SL, X, T, RT
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  ============================
   of_ml (cof X (product T RT) :: nil) ml_nil nil

Subgoal 2 is:
 of_ml (cof X (product T RT) :: nil) (ml_cons (map X1 M1) ML) (of X1 T1 :: SL1)

map_rst < <b>search.</b>
</pre>
<a name="110"></a>
<pre>
Subgoal 2:

  Variables: M, SL, X, T, RT, SL1, T1, X1, ML, M1
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  H2 : tname X1
  H3 : {cof (rst X) RT |- cof M1 T1}
  H4 : of_ml (cof (rst X) RT :: nil) ML SL1 *
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map X1 M1) ML) (of X1 T1 :: SL1)

map_rst < <b>assert {cof X (product T RT) |- cof (rst X) RT}.</b>
</pre>
<a name="111"></a>
<pre>
Subgoal 2:

  Variables: M, SL, X, T, RT, SL1, T1, X1, ML, M1
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  H2 : tname X1
  H3 : {cof (rst X) RT |- cof M1 T1}
  H4 : of_ml (cof (rst X) RT :: nil) ML SL1 *
  H5 : {cof X (product T RT) |- cof (rst X) RT}
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map X1 M1) ML) (of X1 T1 :: SL1)

map_rst < <b>cut H3 with H5.</b>
</pre>
<a name="112"></a>
<pre>
Subgoal 2:

  Variables: M, SL, X, T, RT, SL1, T1, X1, ML, M1
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  H2 : tname X1
  H3 : {cof (rst X) RT |- cof M1 T1}
  H4 : of_ml (cof (rst X) RT :: nil) ML SL1 *
  H5 : {cof X (product T RT) |- cof (rst X) RT}
  H6 : {cof X (product T RT) |- cof M1 T1}
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map X1 M1) ML) (of X1 T1 :: SL1)

map_rst < <b>apply IH to H4 with T = T.</b>
</pre>
<a name="113"></a>
<pre>
Subgoal 2:

  Variables: M, SL, X, T, RT, SL1, T1, X1, ML, M1
  IH : forall M SL X T RT, of_ml (cof (rst X) RT :: nil) M SL * ->
         of_ml (cof X (product T RT) :: nil) M SL
  H2 : tname X1
  H3 : {cof (rst X) RT |- cof M1 T1}
  H4 : of_ml (cof (rst X) RT :: nil) ML SL1 *
  H5 : {cof X (product T RT) |- cof (rst X) RT}
  H6 : {cof X (product T RT) |- cof M1 T1}
  H7 : of_ml (cof X (product T RT) :: nil) ML SL1
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map X1 M1) ML) (of X1 T1 :: SL1)

map_rst < <b>search.</b>
Proof completed.
</pre>
<a name="114"></a>
<pre class="code">
Abella < <b>Theorem of_ml_extend_cctx : 
forall CL Map SL X, of_ml CL Map SL -> of_ml (X :: CL) Map SL.</b>
</pre>
<a name="115"></a>
<pre>


  ============================
   forall CL Map SL X, of_ml CL Map SL -> of_ml (X :: CL) Map SL

of_ml_extend_cctx < <b>induction on 1.</b>
</pre>
<a name="116"></a>
<pre>


  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  ============================
   forall CL Map SL X, of_ml CL Map SL @ -> of_ml (X :: CL) Map SL

of_ml_extend_cctx < <b>intros.</b>
</pre>
<a name="117"></a>
<pre>

  Variables: CL, Map, SL, X
  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  H1 : of_ml CL Map SL @
  ============================
   of_ml (X :: CL) Map SL

of_ml_extend_cctx < <b>case H1.</b>
</pre>
<a name="118"></a>
<pre>
Subgoal 1:

  Variables: CL, Map, SL, X
  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  ============================
   of_ml (X :: CL) ml_nil nil

Subgoal 2 is:
 of_ml (X :: CL) (ml_cons (map X1 M) ML) (of X1 T :: SL1)

of_ml_extend_cctx < <b>search.</b>
</pre>
<a name="119"></a>
<pre>
Subgoal 2:

  Variables: CL, Map, SL, X, SL1, T, X1, ML, M
  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  H2 : tname X1
  H3 : {CL |- cof M T}
  H4 : of_ml CL ML SL1 *
  ============================
   of_ml (X :: CL) (ml_cons (map X1 M) ML) (of X1 T :: SL1)

of_ml_extend_cctx < <b>assert {CL, X |- cof M T}.</b>
</pre>
<a name="120"></a>
<pre>
Subgoal 2:

  Variables: CL, Map, SL, X, SL1, T, X1, ML, M
  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  H2 : tname X1
  H3 : {CL |- cof M T}
  H4 : of_ml CL ML SL1 *
  H5 : {CL, X |- cof M T}
  ============================
   of_ml (X :: CL) (ml_cons (map X1 M) ML) (of X1 T :: SL1)

of_ml_extend_cctx < <b>apply IH to H4 with X = X.</b>
</pre>
<a name="121"></a>
<pre>
Subgoal 2:

  Variables: CL, Map, SL, X, SL1, T, X1, ML, M
  IH : forall CL Map SL X, of_ml CL Map SL * -> of_ml (X :: CL) Map SL
  H2 : tname X1
  H3 : {CL |- cof M T}
  H4 : of_ml CL ML SL1 *
  H5 : {CL, X |- cof M T}
  H6 : of_ml (X :: CL) ML SL1
  ============================
   of_ml (X :: CL) (ml_cons (map X1 M) ML) (of X1 T :: SL1)

of_ml_extend_cctx < <b>search.</b>
Proof completed.
</pre>
<a name="122"></a>
<pre class="code">
Abella < <b>Theorem of_ml_extend_map : 
forall CL Map SL X Y T, of_ml CL Map SL -> tname X ->
  of_ml (cof Y T :: CL) (ml_cons (map X Y) Map) (of X T :: SL).</b>
</pre>
<a name="123"></a>
<pre>


  ============================
   forall CL Map SL X Y T, of_ml CL Map SL -> tname X ->
     of_ml (cof Y T :: CL) (ml_cons (map X Y) Map) (of X T :: SL)

of_ml_extend_map < <b>intros.</b>
</pre>
<a name="124"></a>
<pre>

  Variables: CL, Map, SL, X, Y, T
  H1 : of_ml CL Map SL
  H2 : tname X
  ============================
   of_ml (cof Y T :: CL) (ml_cons (map X Y) Map) (of X T :: SL)

of_ml_extend_map < <b>unfold.</b>
</pre>
<a name="125"></a>
<pre>
Subgoal 1:

  Variables: CL, Map, SL, X, Y, T
  H1 : of_ml CL Map SL
  H2 : tname X
  ============================
   tname X

Subgoal 2 is:
 {CL, cof Y T |- cof Y T}

Subgoal 3 is:
 of_ml (cof Y T :: CL) Map SL

of_ml_extend_map < <b>search.</b>
</pre>
<a name="126"></a>
<pre>
Subgoal 2:

  Variables: CL, Map, SL, X, Y, T
  H1 : of_ml CL Map SL
  H2 : tname X
  ============================
   {CL, cof Y T |- cof Y T}

Subgoal 3 is:
 of_ml (cof Y T :: CL) Map SL

of_ml_extend_map < <b>search.</b>
</pre>
<a name="127"></a>
<pre>
Subgoal 3:

  Variables: CL, Map, SL, X, Y, T
  H1 : of_ml CL Map SL
  H2 : tname X
  ============================
   of_ml (cof Y T :: CL) Map SL

of_ml_extend_map < <b>apply of_ml_extend_cctx to H1 with X = cof Y T.</b>
</pre>
<a name="128"></a>
<pre>
Subgoal 3:

  Variables: CL, Map, SL, X, Y, T
  H1 : of_ml CL Map SL
  H2 : tname X
  H3 : of_ml (cof Y T :: CL) Map SL
  ============================
   of_ml (cof Y T :: CL) Map SL

of_ml_extend_map < <b>search.</b>
Proof completed.
</pre>
<a name="129"></a>
<pre class="code">
Abella < <b>Define bvars : olist -> prop by 
bvars nil;
nabla x, bvars (notfree x :: L) := bvars L.</b>
</pre>
<a name="130"></a>
<pre class="code">
Abella < <b>Theorem bvars_mem : 
forall BVs E, bvars BVs -> member E BVs -> (exists X, E = notfree X /\
  tname X).</b>
</pre>
<a name="131"></a>
<pre>


  ============================
   forall BVs E, bvars BVs -> member E BVs -> (exists X, E = notfree X /\
     tname X)

bvars_mem < <b>induction on 1.</b>
</pre>
<a name="132"></a>
<pre>


  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  ============================
   forall BVs E, bvars BVs @ -> member E BVs -> (exists X, E = notfree X /\
     tname X)

bvars_mem < <b>intros.</b>
</pre>
<a name="133"></a>
<pre>

  Variables: BVs, E
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H1 : bvars BVs @
  H2 : member E BVs
  ============================
   exists X, E = notfree X /\ tname X

bvars_mem < <b>case H1.</b>
</pre>
<a name="134"></a>
<pre>
Subgoal 1:

  Variables: BVs, E
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H2 : member E nil
  ============================
   exists X, E = notfree X /\ tname X

Subgoal 2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>case H2.</b>
</pre>
<a name="135"></a>
<pre>
Subgoal 2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H2 : member (E n1) (notfree n1 :: L)
  H3 : bvars L *
  ============================
   exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>case H2.</b>
</pre>
<a name="136"></a>
<pre>
Subgoal 2.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   exists X, notfree n1 = notfree X /\ tname X

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>exists n1.</b>
</pre>
<a name="137"></a>
<pre>
Subgoal 2.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   notfree n1 = notfree n1 /\ tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>split.</b>
</pre>
<a name="138"></a>
<pre>
Subgoal 2.1.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   notfree n1 = notfree n1

Subgoal 2.1.2 is:
 tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>search.</b>
</pre>
<a name="139"></a>
<pre>
Subgoal 2.1.2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>search.</b>
</pre>
<a name="140"></a>
<pre>
Subgoal 2.2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (E n1) L
  ============================
   exists X, E n1 = notfree X /\ tname X

bvars_mem < <b>apply IH to H3 H4.</b>
</pre>
<a name="141"></a>
<pre>
Subgoal 2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   exists X1, notfree (X n1) = notfree X1 /\ tname X1

bvars_mem < <b>exists X n1.</b>
</pre>
<a name="142"></a>
<pre>
Subgoal 2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   notfree (X n1) = notfree (X n1) /\ tname (X n1)

bvars_mem < <b>split.</b>
</pre>
<a name="143"></a>
<pre>
Subgoal 2.2.1:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   notfree (X n1) = notfree (X n1)

Subgoal 2.2.2 is:
 tname (X n1)

bvars_mem < <b>search.</b>
</pre>
<a name="144"></a>
<pre>
Subgoal 2.2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   tname (X n1)

bvars_mem < <b>search.</b>
Proof completed.
</pre>
<a name="145"></a>
<pre class="code">
Abella < <b>Theorem vars_of_sctx_mem_name : 
forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} -> tname X.</b>
</pre>
<a name="146"></a>
<pre>


  ============================
   forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     tname X

vars_of_sctx_mem_name < <b>induction on 1.</b>
</pre>
<a name="147"></a>
<pre>


  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  ============================
   forall SL Vs X, sctx' SL @ -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     tname X

vars_of_sctx_mem_name < <b>intros.</b>
</pre>
<a name="148"></a>
<pre>

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H1 : sctx' SL @
  H2 : vars_of_sctx SL Vs
  H3 : {tl_member X Vs}
  ============================
   tname X

vars_of_sctx_mem_name < <b>case H1.</b>
</pre>
<a name="149"></a>
<pre>
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H2 : vars_of_sctx nil Vs
  H3 : {tl_member X Vs}
  ============================
   tname X

Subgoal 2 is:
 tname X

vars_of_sctx_mem_name < <b>case H2.</b>
</pre>
<a name="150"></a>
<pre>
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H3 : {tl_member X tl_nil}
  ============================
   tname X

Subgoal 2 is:
 tname X

vars_of_sctx_mem_name < <b>case H3.</b>
</pre>
<a name="151"></a>
<pre>
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H2 : vars_of_sctx (of X1 T :: L) Vs
  H3 : {tl_member X Vs}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  ============================
   tname X

vars_of_sctx_mem_name < <b>case H2.</b>
</pre>
<a name="152"></a>
<pre>
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H3 : {tl_member X (tl_cons X1 Vs1)}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   tname X

vars_of_sctx_mem_name < <b>case H3.</b>
</pre>
<a name="153"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

vars_of_sctx_mem_name < <b>search.</b>
</pre>
<a name="154"></a>
<pre>
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  ============================
   tname X

vars_of_sctx_mem_name < <b>apply IH to H4 H7 H8.</b>
</pre>
<a name="155"></a>
<pre>
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  H9 : tname X
  ============================
   tname X

vars_of_sctx_mem_name < <b>search.</b>
Proof completed.
</pre>
<a name="156"></a>
<pre class="code">
Abella < <b>Theorem vars_of_sctx_mem_exists : 
forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
  (exists T, member (of X T) SL).</b>
</pre>
<a name="157"></a>
<pre>


  ============================
   forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     (exists T, member (of X T) SL)

vars_of_sctx_mem_exists < <b>induction on 1.</b>
</pre>
<a name="158"></a>
<pre>


  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  ============================
   forall SL Vs X, sctx' SL @ -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     (exists T, member (of X T) SL)

vars_of_sctx_mem_exists < <b>intros.</b>
</pre>
<a name="159"></a>
<pre>

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H1 : sctx' SL @
  H2 : vars_of_sctx SL Vs
  H3 : {tl_member X Vs}
  ============================
   exists T, member (of X T) SL

vars_of_sctx_mem_exists < <b>case H1.</b>
</pre>
<a name="160"></a>
<pre>
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H2 : vars_of_sctx nil Vs
  H3 : {tl_member X Vs}
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>case H2.</b>
</pre>
<a name="161"></a>
<pre>
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H3 : {tl_member X tl_nil}
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>case H3.</b>
</pre>
<a name="162"></a>
<pre>
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H2 : vars_of_sctx (of X1 T :: L) Vs
  H3 : {tl_member X Vs}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>case H2.</b>
</pre>
<a name="163"></a>
<pre>
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H3 : {tl_member X (tl_cons X1 Vs1)}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>case H3.</b>
</pre>
<a name="164"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   exists T1, member (of X1 T1) (of X1 T :: L)

Subgoal 2.2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>search.</b>
</pre>
<a name="165"></a>
<pre>
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>apply IH to H4 H7 H8.</b>
</pre>
<a name="166"></a>
<pre>
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1, T1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  H9 : member (of X T1) L
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < <b>search.</b>
Proof completed.
</pre>
<a name="167"></a>
<pre class="code">
Abella < <b>Theorem bvars_notfree : 
forall BVs X, bvars BVs -> {BVs |- notfree X} -> tname X.</b>
</pre>
<a name="168"></a>
<pre>


  ============================
   forall BVs X, bvars BVs -> {BVs |- notfree X} -> tname X

bvars_notfree < <b>intros.</b>
</pre>
<a name="169"></a>
<pre>

  Variables: BVs, X
  H1 : bvars BVs
  H2 : {BVs |- notfree X}
  ============================
   tname X

bvars_notfree < <b>case H2.</b>
</pre>
<a name="170"></a>
<pre>

  Variables: BVs, X, F
  H1 : bvars BVs
  H3 : {BVs, [F] |- notfree X}
  H4 : member F BVs
  ============================
   tname X

bvars_notfree < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="171"></a>
<pre>

  Variables: BVs, X, F, X1
  H1 : bvars BVs
  H3 : {BVs, [notfree X1] |- notfree X}
  H4 : member (notfree X1) BVs
  H5 : tname X1
  ============================
   tname X

bvars_notfree < <b>case H3.</b>
</pre>
<a name="172"></a>
<pre>

  Variables: BVs, X, F, X1
  H1 : bvars BVs
  H4 : member (notfree X) BVs
  H5 : tname X
  ============================
   tname X

bvars_notfree < <b>search.</b>
Proof completed.
</pre>
<a name="173"></a>
<pre class="code">
Abella < <b>Define subset : tm_list -> tm_list -> prop by 
subset tl_nil L;
subset (tl_cons X L1) L2 := {tl_member X L2} /\ subset L1 L2.</b>
</pre>
<a name="174"></a>
<pre class="code">
Abella < <b>Define islist : tm_list -> prop by 
islist tl_nil;
islist (tl_cons X L) := islist L.</b>
</pre>
<a name="175"></a>
<pre class="code">
Abella < <b>Theorem combine_islist : 
forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> islist L3.</b>
</pre>
<a name="176"></a>
<pre>


  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> islist L3

combine_islist < <b>induction on 3.</b>
</pre>
<a name="177"></a>
<pre>


  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     islist L3

combine_islist < <b>intros.</b>
</pre>
<a name="178"></a>
<pre>

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  ============================
   islist L3

combine_islist < <b>case H3.</b>
</pre>
<a name="179"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist tl_nil
  H2 : islist L3
  ============================
   islist L3

Subgoal 2 is:
 islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < <b>search.</b>
</pre>
<a name="180"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < <b>case H1.</b>
</pre>
<a name="181"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : islist Fvs1
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < <b>apply IH to H6 H2 H5.</b>
</pre>
<a name="182"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : islist Fvs1
  H7 : islist L3
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < <b>search.</b>
</pre>
<a name="183"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  ============================
   islist (tl_cons X Fvs)

combine_islist < <b>case H1.</b>
</pre>
<a name="184"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  ============================
   islist (tl_cons X Fvs)

combine_islist < <b>apply IH to H5 H2 H4.</b>
</pre>
<a name="185"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : islist Fvs
  ============================
   islist (tl_cons X Fvs)

combine_islist < <b>search.</b>
Proof completed.
</pre>
<a name="186"></a>
<pre class="code">
Abella < <b>Theorem tl_mem_bvar : 
forall Ps X L, bvars Ps -> {Ps |- tl_member X L} -> {tl_member X L}.</b>
</pre>
<a name="187"></a>
<pre>


  ============================
   forall Ps X L, bvars Ps -> {Ps |- tl_member X L} -> {tl_member X L}

tl_mem_bvar < <b>induction on 2.</b>
</pre>
<a name="188"></a>
<pre>


  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  ============================
   forall Ps X L, bvars Ps -> {Ps |- tl_member X L}@ -> {tl_member X L}

tl_mem_bvar < <b>intros.</b>
</pre>
<a name="189"></a>
<pre>

  Variables: Ps, X, L
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H2 : {Ps |- tl_member X L}@
  ============================
   {tl_member X L}

tl_mem_bvar < <b>case H2.</b>
</pre>
<a name="190"></a>
<pre>
Subgoal 1:

  Variables: Ps, X, L, L1
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  ============================
   {tl_member X (tl_cons X L1)}

Subgoal 2 is:
 {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < <b>search.</b>
</pre>
<a name="191"></a>
<pre>
Subgoal 2:

  Variables: Ps, X, L, L1, Y
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L1}*
  ============================
   {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < <b>apply IH to H1 H3.</b>
</pre>
<a name="192"></a>
<pre>
Subgoal 2:

  Variables: Ps, X, L, L1, Y
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L1}*
  H4 : {tl_member X L1}
  ============================
   {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < <b>search.</b>
</pre>
<a name="193"></a>
<pre>
Subgoal 3:

  Variables: Ps, X, L, F
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps, [F] |- tl_member X L}*
  H4 : member F Ps
  ============================
   {tl_member X L}

tl_mem_bvar < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="194"></a>
<pre>
Subgoal 3:

  Variables: Ps, X, L, F, X1
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps, [notfree X1] |- tl_member X L}*
  H4 : member (notfree X1) Ps
  H5 : tname X1
  ============================
   {tl_member X L}

tl_mem_bvar < <b>case H3.</b>
Proof completed.
</pre>
<a name="195"></a>
<pre class="code">
Abella < <b>Theorem combine_bvar : 
forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3} ->
  {combine L1 L2 L3}.</b>
</pre>
<a name="196"></a>
<pre>


  ============================
   forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3} ->
     {combine L1 L2 L3}

combine_bvar < <b>induction on 2.</b>
</pre>
<a name="197"></a>
<pre>


  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  ============================
   forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}@ ->
     {combine L1 L2 L3}

combine_bvar < <b>intros.</b>
</pre>
<a name="198"></a>
<pre>

  Variables: L1, L2, L3, Ps
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H2 : {Ps |- combine L1 L2 L3}@
  ============================
   {combine L1 L2 L3}

combine_bvar < <b>case H2.</b>
</pre>
<a name="199"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3, Ps
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  ============================
   {combine tl_nil L3 L3}

Subgoal 2 is:
 {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>search.</b>
</pre>
<a name="200"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>apply IH to H1 H4.</b>
</pre>
<a name="201"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  H5 : {combine Fvs1 L2 L3}
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>apply tl_mem_bvar to H1 H3.</b>
</pre>
<a name="202"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  H5 : {combine Fvs1 L2 L3}
  H6 : {tl_member X L2}
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>search.</b>
</pre>
<a name="203"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Ps, Fvs, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- combine Fvs1 L2 Fvs}*
  ============================
   {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>apply IH to H1 H3.</b>
</pre>
<a name="204"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Ps, Fvs, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- combine Fvs1 L2 Fvs}*
  H4 : {combine Fvs1 L2 Fvs}
  ============================
   {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < <b>search.</b>
</pre>
<a name="205"></a>
<pre>
Subgoal 4:

  Variables: L1, L2, L3, Ps, F
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps, [F] |- combine L1 L2 L3}*
  H4 : member F Ps
  ============================
   {combine L1 L2 L3}

combine_bvar < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="206"></a>
<pre>
Subgoal 4:

  Variables: L1, L2, L3, Ps, F, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- combine L1 L2 L3}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   {combine L1 L2 L3}

combine_bvar < <b>case H3.</b>
Proof completed.
</pre>
<a name="207"></a>
<pre class="code">
Abella < <b>Theorem subset_mem : 
forall L1 L2 X, subset L1 L2 -> {tl_member X L1} -> {tl_member X L2}.</b>
</pre>
<a name="208"></a>
<pre>


  ============================
   forall L1 L2 X, subset L1 L2 -> {tl_member X L1} -> {tl_member X L2}

subset_mem < <b>induction on 2.</b>
</pre>
<a name="209"></a>
<pre>


  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  ============================
   forall L1 L2 X, subset L1 L2 -> {tl_member X L1}@ -> {tl_member X L2}

subset_mem < <b>intros.</b>
</pre>
<a name="210"></a>
<pre>

  Variables: L1, L2, X
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset L1 L2
  H2 : {tl_member X L1}@
  ============================
   {tl_member X L2}

subset_mem < <b>case H2.</b>
</pre>
<a name="211"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, X, L
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset (tl_cons X L) L2
  ============================
   {tl_member X L2}

Subgoal 2 is:
 {tl_member X L2}

subset_mem < <b>case H1.</b>
</pre>
<a name="212"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, X, L
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L2}
  H4 : subset L L2
  ============================
   {tl_member X L2}

Subgoal 2 is:
 {tl_member X L2}

subset_mem < <b>search.</b>
</pre>
<a name="213"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset (tl_cons Y L) L2
  H3 : {tl_member X L}*
  ============================
   {tl_member X L2}

subset_mem < <b>case H1.</b>
</pre>
<a name="214"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L}*
  H4 : {tl_member Y L2}
  H5 : subset L L2
  ============================
   {tl_member X L2}

subset_mem < <b>apply IH to H5 H3.</b>
</pre>
<a name="215"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L}*
  H4 : {tl_member Y L2}
  H5 : subset L L2
  H6 : {tl_member X L2}
  ============================
   {tl_member X L2}

subset_mem < <b>search.</b>
Proof completed.
</pre>
<a name="216"></a>
<pre class="code">
Abella < <b>Theorem subset_one : 
forall L1 L2 X, islist L1 -> subset L1 L2 -> subset L1 (tl_cons X L2).</b>
</pre>
<a name="217"></a>
<pre>


  ============================
   forall L1 L2 X, islist L1 -> subset L1 L2 -> subset L1 (tl_cons X L2)

subset_one < <b>induction on 1.</b>
</pre>
<a name="218"></a>
<pre>


  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 -> subset L1 (tl_cons X L2)
  ============================
   forall L1 L2 X, islist L1 @ -> subset L1 L2 -> subset L1 (tl_cons X L2)

subset_one < <b>intros.</b>
</pre>
<a name="219"></a>
<pre>

  Variables: L1, L2, X
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H1 : islist L1 @
  H2 : subset L1 L2
  ============================
   subset L1 (tl_cons X L2)

subset_one < <b>case H1.</b>
</pre>
<a name="220"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, X
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H2 : subset tl_nil L2
  ============================
   subset tl_nil (tl_cons X L2)

Subgoal 2 is:
 subset (tl_cons X1 L) (tl_cons X L2)

subset_one < <b>search.</b>
</pre>
<a name="221"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H2 : subset (tl_cons X1 L) L2
  H3 : islist L *
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < <b>case H2.</b>
</pre>
<a name="222"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < <b>apply IH to H3 H5 with X = X.</b>
</pre>
<a name="223"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < <b>unfold.</b>
</pre>
<a name="224"></a>
<pre>
Subgoal 2.1:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   {tl_member X1 (tl_cons X L2)}

Subgoal 2.2 is:
 subset L (tl_cons X L2)

subset_one < <b>search.</b>
</pre>
<a name="225"></a>
<pre>
Subgoal 2.2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   subset L (tl_cons X L2)

subset_one < <b>search.</b>
Proof completed.
</pre>
<a name="226"></a>
<pre class="code">
Abella < <b>Theorem subset_refl : 
forall L, islist L -> subset L L.</b>
</pre>
<a name="227"></a>
<pre>


  ============================
   forall L, islist L -> subset L L

subset_refl < <b>induction on 1.</b>
</pre>
<a name="228"></a>
<pre>


  IH : forall L, islist L * -> subset L L
  ============================
   forall L, islist L @ -> subset L L

subset_refl < <b>intros.</b>
</pre>
<a name="229"></a>
<pre>

  Variables: L
  IH : forall L, islist L * -> subset L L
  H1 : islist L @
  ============================
   subset L L

subset_refl < <b>case H1 (keep).</b>
</pre>
<a name="230"></a>
<pre>
Subgoal 1:

  Variables: L
  IH : forall L, islist L * -> subset L L
  H1 : islist tl_nil @
  ============================
   subset tl_nil tl_nil

Subgoal 2 is:
 subset (tl_cons X L1) (tl_cons X L1)

subset_refl < <b>search.</b>
</pre>
<a name="231"></a>
<pre>
Subgoal 2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   subset (tl_cons X L1) (tl_cons X L1)

subset_refl < <b>unfold.</b>
</pre>
<a name="232"></a>
<pre>
Subgoal 2.1:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   {tl_member X (tl_cons X L1)}

Subgoal 2.2 is:
 subset L1 (tl_cons X L1)

subset_refl < <b>search.</b>
</pre>
<a name="233"></a>
<pre>
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   subset L1 (tl_cons X L1)

subset_refl < <b>apply IH to H2.</b>
</pre>
<a name="234"></a>
<pre>
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  H3 : subset L1 L1
  ============================
   subset L1 (tl_cons X L1)

subset_refl < <b>apply subset_one to H2 H3 with X = X.</b>
</pre>
<a name="235"></a>
<pre>
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  H3 : subset L1 L1
  H4 : subset L1 (tl_cons X L1)
  ============================
   subset L1 (tl_cons X L1)

subset_refl < <b>search.</b>
Proof completed.
</pre>
<a name="236"></a>
<pre class="code">
Abella < <b>Theorem subset_trans : 
forall L1 L2 L3, subset L1 L2 -> subset L2 L3 -> subset L1 L3.</b>
</pre>
<a name="237"></a>
<pre>


  ============================
   forall L1 L2 L3, subset L1 L2 -> subset L2 L3 -> subset L1 L3

subset_trans < <b>induction on 1.</b>
</pre>
<a name="238"></a>
<pre>


  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  ============================
   forall L1 L2 L3, subset L1 L2 @ -> subset L2 L3 -> subset L1 L3

subset_trans < <b>intros.</b>
</pre>
<a name="239"></a>
<pre>

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H1 : subset L1 L2 @
  H2 : subset L2 L3
  ============================
   subset L1 L3

subset_trans < <b>case H1.</b>
</pre>
<a name="240"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  ============================
   subset tl_nil L3

Subgoal 2 is:
 subset (tl_cons X L4) L3

subset_trans < <b>search.</b>
</pre>
<a name="241"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   subset (tl_cons X L4) L3

subset_trans < <b>unfold.</b>
</pre>
<a name="242"></a>
<pre>
Subgoal 2.1:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   {tl_member X L3}

Subgoal 2.2 is:
 subset L4 L3

subset_trans < <b>apply subset_mem to H2 H3.</b>
</pre>
<a name="243"></a>
<pre>
Subgoal 2.1:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  H5 : {tl_member X L3}
  ============================
   {tl_member X L3}

Subgoal 2.2 is:
 subset L4 L3

subset_trans < <b>search.</b>
</pre>
<a name="244"></a>
<pre>
Subgoal 2.2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   subset L4 L3

subset_trans < <b>apply IH to H4 H2.</b>
</pre>
<a name="245"></a>
<pre>
Subgoal 2.2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  H5 : subset L4 L3
  ============================
   subset L4 L3

subset_trans < <b>search.</b>
Proof completed.
</pre>
<a name="246"></a>
<pre class="code">
Abella < <b>Theorem combine_subset1 : 
forall L1 L2 L3, islist L2 -> {combine L1 L2 L3} -> subset L2 L3.</b>
</pre>
<a name="247"></a>
<pre>


  ============================
   forall L1 L2 L3, islist L2 -> {combine L1 L2 L3} -> subset L2 L3

combine_subset1 < <b>induction on 2.</b>
</pre>
<a name="248"></a>
<pre>


  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  ============================
   forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}@ -> subset L2 L3

combine_subset1 < <b>intros.</b>
</pre>
<a name="249"></a>
<pre>

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H2 : {combine L1 L2 L3}@
  ============================
   subset L2 L3

combine_subset1 < <b>case H2.</b>
</pre>
<a name="250"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L3
  ============================
   subset L3 L3

Subgoal 2 is:
 subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < <b>apply subset_refl to H1.</b>
</pre>
<a name="251"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L3
  H3 : subset L3 L3
  ============================
   subset L3 L3

Subgoal 2 is:
 subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < <b>search.</b>
</pre>
<a name="252"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {tl_member X L2}*
  H4 : {combine Fvs1 L2 L3}*
  ============================
   subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < <b>apply IH to H1 H4 with L1 = Fvs1.</b>
</pre>
<a name="253"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {tl_member X L2}*
  H4 : {combine Fvs1 L2 L3}*
  H5 : subset L2 L3
  ============================
   subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < <b>search.</b>
</pre>
<a name="254"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < <b>apply IH to H1 H3 with L1 = Fvs1.</b>
</pre>
<a name="255"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  H4 : subset L2 Fvs
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < <b>apply subset_one to H1 H4 with X = X.</b>
</pre>
<a name="256"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  H4 : subset L2 Fvs
  H5 : subset L2 (tl_cons X Fvs)
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < <b>search.</b>
Proof completed.
</pre>
<a name="257"></a>
<pre class="code">
Abella < <b>Theorem combine_subset2 : 
forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> subset L1 L3.</b>
</pre>
<a name="258"></a>
<pre>


  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
     subset L1 L3

combine_subset2 < <b>induction on 3.</b>
</pre>
<a name="259"></a>
<pre>


  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     subset L1 L3

combine_subset2 < <b>intros.</b>
</pre>
<a name="260"></a>
<pre>

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  ============================
   subset L1 L3

combine_subset2 < <b>case H3.</b>
</pre>
<a name="261"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist tl_nil
  H2 : islist L3
  ============================
   subset tl_nil L3

Subgoal 2 is:
 subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>search.</b>
</pre>
<a name="262"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>apply combine_subset1 to H2 H5.</b>
</pre>
<a name="263"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>apply subset_mem to H6 H4.</b>
</pre>
<a name="264"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>case H1.</b>
</pre>
<a name="265"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  H8 : islist Fvs1
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>apply IH to H8 H2 H5.</b>
</pre>
<a name="266"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  H8 : islist Fvs1
  H9 : subset Fvs1 L3
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>search.</b>
</pre>
<a name="267"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>case H1.</b>
</pre>
<a name="268"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>apply IH to H5 H2 H4.</b>
</pre>
<a name="269"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : subset Fvs1 Fvs
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>apply subset_one to H5 H6 with X = X.</b>
</pre>
<a name="270"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : subset Fvs1 Fvs
  H7 : subset Fvs1 (tl_cons X Fvs)
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < <b>search.</b>
Proof completed.
</pre>
<a name="271"></a>
<pre class="code">
Abella < <b>Theorem subset_combine : 
forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
  subset L1 L4 -> subset L2 L4 -> subset L3 L4.</b>
</pre>
<a name="272"></a>
<pre>


  ============================
   forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
     subset L1 L4 -> subset L2 L4 -> subset L3 L4

subset_combine < <b>induction on 3.</b>
</pre>
<a name="273"></a>
<pre>


  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  ============================
   forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     subset L1 L4 -> subset L2 L4 -> subset L3 L4

subset_combine < <b>intros.</b>
</pre>
<a name="274"></a>
<pre>

  Variables: L1, L2, L3, L4
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  H4 : subset L1 L4
  H5 : subset L2 L4
  ============================
   subset L3 L4

subset_combine < <b>case H3.</b>
</pre>
<a name="275"></a>
<pre>
Subgoal 1:

  Variables: L1, L2, L3, L4
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist tl_nil
  H2 : islist L3
  H4 : subset tl_nil L4
  H5 : subset L3 L4
  ============================
   subset L3 L4

Subgoal 2 is:
 subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < <b>search.</b>
</pre>
<a name="276"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < <b>case H1.</b>
</pre>
<a name="277"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < <b>case H4.</b>
</pre>
<a name="278"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  H9 : {tl_member X L4}
  H10 : subset Fvs1 L4
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < <b>apply IH to H8 H2 H7 H10 H5.</b>
</pre>
<a name="279"></a>
<pre>
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  H9 : {tl_member X L4}
  H10 : subset Fvs1 L4
  H11 : subset L3 L4
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < <b>search.</b>
</pre>
<a name="280"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  ============================
   subset (tl_cons X Fvs) L4

subset_combine < <b>case H4.</b>
</pre>
<a name="281"></a>
<pre>
Subgoal 3:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   subset (tl_cons X Fvs) L4

subset_combine < <b>unfold.</b>
</pre>
<a name="282"></a>
<pre>
Subgoal 3.1:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   {tl_member X L4}

Subgoal 3.2 is:
 subset Fvs L4

subset_combine < <b>search.</b>
</pre>
<a name="283"></a>
<pre>
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   subset Fvs L4

subset_combine < <b>case H1.</b>
</pre>
<a name="284"></a>
<pre>
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  H9 : islist Fvs1
  ============================
   subset Fvs L4

subset_combine < <b>apply IH to H9 H2 H6 H8 H5.</b>
</pre>
<a name="285"></a>
<pre>
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  H9 : islist Fvs1
  H10 : subset Fvs L4
  ============================
   subset Fvs L4

subset_combine < <b>search.</b>
Proof completed.
</pre>
<a name="286"></a>
<pre class="code">
Abella < <b>Theorem fvars_islist : 
forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> islist Vs'.</b>
</pre>
<a name="287"></a>
<pre>


  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> islist Vs'

fvars_islist < <b>induction on 2.</b>
</pre>
<a name="288"></a>
<pre>


  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}@ -> islist Vs'

fvars_islist < <b>intros.</b>
</pre>
<a name="289"></a>
<pre>

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   islist Vs'

fvars_islist < <b>case H2.</b>
</pre>
<a name="290"></a>
<pre>
Subgoal 1:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   islist tl_nil

Subgoal 2 is:
 islist tl_nil

Subgoal 3 is:
 islist tl_nil

Subgoal 4 is:
 islist (tl_cons M tl_nil)

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>search.</b>
</pre>
<a name="291"></a>
<pre>
Subgoal 2:

  Variables: M, Vs, Vs', Ps, C
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  ============================
   islist tl_nil

Subgoal 3 is:
 islist tl_nil

Subgoal 4 is:
 islist (tl_cons M tl_nil)

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>search.</b>
</pre>
<a name="292"></a>
<pre>
Subgoal 3:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  ============================
   islist tl_nil

Subgoal 4 is:
 islist (tl_cons M tl_nil)

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>search.</b>
</pre>
<a name="293"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   islist (tl_cons M tl_nil)

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>search.</b>
</pre>
<a name="294"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>apply IH to H1 H3.</b>
</pre>
<a name="295"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>apply IH to H1 H4.</b>
</pre>
<a name="296"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>apply combine_bvar to H1 H5.</b>
</pre>
<a name="297"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  H8 : {combine Fvs1 Fvs2 Vs'}
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>apply combine_islist to H6 H7 H8.</b>
</pre>
<a name="298"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  H8 : {combine Fvs1 Fvs2 Vs'}
  H9 : islist Vs'
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>search.</b>
</pre>
<a name="299"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>assert bvars (notfree n1 :: Ps).</b>
</pre>
<a name="300"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>apply IH to H4 H3.</b>
</pre>
<a name="301"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : islist Vs'
  ============================
   islist Vs'

Subgoal 7 is:
 islist Vs'

fvars_islist < <b>search.</b>
</pre>
<a name="302"></a>
<pre>
Subgoal 7:

  Variables: M, Vs, Vs', Ps, F
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   islist Vs'

fvars_islist < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="303"></a>
<pre>
Subgoal 7:

  Variables: M, Vs, Vs', Ps, F, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- fvars M Vs Vs'}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   islist Vs'

fvars_islist < <b>case H3.</b>
Proof completed.
</pre>
<a name="304"></a>
<pre class="code">
Abella < <b>Theorem fvars_subset : 
forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> subset Vs' Vs.</b>
</pre>
<a name="305"></a>
<pre>


  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> subset Vs' Vs

fvars_subset < <b>induction on 2.</b>
</pre>
<a name="306"></a>
<pre>


  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}@ -> subset Vs' Vs

fvars_subset < <b>intros.</b>
</pre>
<a name="307"></a>
<pre>

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   subset Vs' Vs

fvars_subset < <b>case H2.</b>
</pre>
<a name="308"></a>
<pre>
Subgoal 1:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   subset tl_nil Vs

Subgoal 2 is:
 subset tl_nil Vs

Subgoal 3 is:
 subset tl_nil Vs

Subgoal 4 is:
 subset (tl_cons M tl_nil) Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>search.</b>
</pre>
<a name="309"></a>
<pre>
Subgoal 2:

  Variables: M, Vs, Vs', Ps, C
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  ============================
   subset tl_nil Vs

Subgoal 3 is:
 subset tl_nil Vs

Subgoal 4 is:
 subset (tl_cons M tl_nil) Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>search.</b>
</pre>
<a name="310"></a>
<pre>
Subgoal 3:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  ============================
   subset tl_nil Vs

Subgoal 4 is:
 subset (tl_cons M tl_nil) Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>search.</b>
</pre>
<a name="311"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   subset (tl_cons M tl_nil) Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>apply tl_mem_bvar to H1 H3.</b>
</pre>
<a name="312"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  H4 : {tl_member M Vs}
  ============================
   subset (tl_cons M tl_nil) Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>search.</b>
</pre>
<a name="313"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>apply IH to H1 H3.</b>
</pre>
<a name="314"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>apply IH to H1 H4.</b>
</pre>
<a name="315"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>apply fvars_islist to H1 H3.</b>
</pre>
<a name="316"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>apply fvars_islist to H1 H4.</b>
</pre>
<a name="317"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>apply combine_bvar to H1 H5.</b>
</pre>
<a name="318"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  H10 : {combine Fvs1 Fvs2 Vs'}
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>apply subset_combine to H8 H9 H10 H6 H7.</b>
</pre>
<a name="319"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  H10 : {combine Fvs1 Fvs2 Vs'}
  H11 : subset Vs' Vs
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>search.</b>
</pre>
<a name="320"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>assert bvars (notfree n1 :: Ps).</b>
</pre>
<a name="321"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>apply IH to H4 H3.</b>
</pre>
<a name="322"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : subset Vs' Vs
  ============================
   subset Vs' Vs

Subgoal 7 is:
 subset Vs' Vs

fvars_subset < <b>search.</b>
</pre>
<a name="323"></a>
<pre>
Subgoal 7:

  Variables: M, Vs, Vs', Ps, F
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   subset Vs' Vs

fvars_subset < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="324"></a>
<pre>
Subgoal 7:

  Variables: M, Vs, Vs', Ps, F, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- fvars M Vs Vs'}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   subset Vs' Vs

fvars_subset < <b>case H3.</b>
Proof completed.
</pre>
<a name="325"></a>
<pre class="code">
Abella < <b>Theorem fvars_extend : 
forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'} ->
  {Ps |- fvars M (tl_cons X Vs) Vs'}.</b>
</pre>
<a name="326"></a>
<pre>


  ============================
   forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'} ->
     {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>induction on 2.</b>
</pre>
<a name="327"></a>
<pre>


  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  ============================
   forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}@ ->
     {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>intros.</b>
</pre>
<a name="328"></a>
<pre>

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>case H2.</b>
</pre>
<a name="329"></a>
<pre>
Subgoal 1:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   {Ps |- fvars M (tl_cons X Vs) tl_nil}

Subgoal 2 is:
 {Ps |- fvars (cst C) (tl_cons X Vs) tl_nil}

Subgoal 3 is:
 {Ps |- fvars (lnat X2) (tl_cons X Vs) tl_nil}

Subgoal 4 is:
 {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 5 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>search.</b>
</pre>
<a name="330"></a>
<pre>
Subgoal 2:

  Variables: M, Vs, Vs', Ps, X, C
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  ============================
   {Ps |- fvars (cst C) (tl_cons X Vs) tl_nil}

Subgoal 3 is:
 {Ps |- fvars (lnat X2) (tl_cons X Vs) tl_nil}

Subgoal 4 is:
 {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 5 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>search.</b>
</pre>
<a name="331"></a>
<pre>
Subgoal 3:

  Variables: M, Vs, Vs', Ps, X, X2
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  ============================
   {Ps |- fvars (lnat X2) (tl_cons X Vs) tl_nil}

Subgoal 4 is:
 {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 5 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>search.</b>
</pre>
<a name="332"></a>
<pre>
Subgoal 4:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 5 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>search.</b>
</pre>
<a name="333"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>apply IH to H1 H3 with X = X.</b>
</pre>
<a name="334"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : {Ps |- fvars M1 (tl_cons X Vs) Fvs1}
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>apply IH to H1 H4 with X = X.</b>
</pre>
<a name="335"></a>
<pre>
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : {Ps |- fvars M1 (tl_cons X Vs) Fvs1}
  H7 : {Ps |- fvars M2 (tl_cons X Vs) Fvs2}
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>search.</b>
</pre>
<a name="336"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>assert bvars (notfree n1 :: Ps).</b>
</pre>
<a name="337"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>apply IH to H4 H3 with X = X.</b>
</pre>
<a name="338"></a>
<pre>
Subgoal 6:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : {Ps, notfree n1 |- fvars (M1 n1) (tl_cons X Vs) Vs'}
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 7 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>search.</b>
</pre>
<a name="339"></a>
<pre>
Subgoal 7:

  Variables: M, Vs, Vs', Ps, X, F
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>apply bvars_mem to H1 H4.</b>
</pre>
<a name="340"></a>
<pre>
Subgoal 7:

  Variables: M, Vs, Vs', Ps, X, F, X1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, [notfree X1] |- fvars M Vs Vs'}*
  H4 : member (notfree X1) Ps
  H5 : tname X1
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < <b>case H3.</b>
Proof completed.
</pre>
<a name="341"></a>
<pre class="code">
Abella < <b>Define pruned_env : olist -> tm_list -> olist -> olist -> prop by 
pruned_env nil tl_nil SL nil;
pruned_env nil (tl_cons X FVs) SL (of X T :: SL') := member (of X T) SL /\ pruned_env nil FVs SL SL';
nabla x, pruned_env (notfree x :: BVs) FVs (of x T :: SL) (of x T :: SL') := pruned_env BVs FVs SL SL'.</b>
</pre>
<a name="342"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_exists : 
forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs ->
  (exists SL', pruned_env nil Vs' SL SL').</b>
</pre>
<a name="343"></a>
<pre>


  ============================
   forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs ->
     (exists SL', pruned_env nil Vs' SL SL')

pruned_env_exists < <b>induction on 3.</b>
</pre>
<a name="344"></a>
<pre>


  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  ============================
   forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs @ ->
     (exists SL', pruned_env nil Vs' SL SL')

pruned_env_exists < <b>intros.</b>
</pre>
<a name="345"></a>
<pre>

  Variables: SL, Vs, Vs'
  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  H1 : sctx' SL
  H2 : vars_of_sctx SL Vs
  H3 : subset Vs' Vs @
  ============================
   exists SL', pruned_env nil Vs' SL SL'

pruned_env_exists < <b>case H3.</b>
</pre>
<a name="346"></a>
<pre>
Subgoal 1:

  Variables: SL, Vs, Vs'
  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  H1 : sctx' SL
  H2 : vars_of_sctx SL Vs
  ============================
   exists SL', pruned_env nil tl_nil SL SL'

Subgoal 2 is:
 exists SL', pruned_env nil (tl_cons X L1) SL SL'

pruned_env_exists < <b>search.</b>
</pre>
<a name="347"></a>
<pre>
Subgoal 2:

  Variables: SL, Vs, Vs', L1, X
  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  H1 : sctx' SL
  H2 : vars_of_sctx SL Vs
  H4 : {tl_member X Vs}
  H5 : subset L1 Vs *
  ============================
   exists SL', pruned_env nil (tl_cons X L1) SL SL'

pruned_env_exists < <b>apply vars_of_sctx_mem_exists to H1 H2 H4.</b>
</pre>
<a name="348"></a>
<pre>
Subgoal 2:

  Variables: SL, Vs, Vs', L1, X, T
  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  H1 : sctx' SL
  H2 : vars_of_sctx SL Vs
  H4 : {tl_member X Vs}
  H5 : subset L1 Vs *
  H6 : member (of X T) SL
  ============================
   exists SL', pruned_env nil (tl_cons X L1) SL SL'

pruned_env_exists < <b>apply IH to H1 H2 H5.</b>
</pre>
<a name="349"></a>
<pre>
Subgoal 2:

  Variables: SL, Vs, Vs', L1, X, T, SL'
  IH : forall SL Vs Vs', sctx' SL -> vars_of_sctx SL Vs -> subset Vs' Vs * ->
         (exists SL', pruned_env nil Vs' SL SL')
  H1 : sctx' SL
  H2 : vars_of_sctx SL Vs
  H4 : {tl_member X Vs}
  H5 : subset L1 Vs *
  H6 : member (of X T) SL
  H7 : pruned_env nil L1 SL SL'
  ============================
   exists SL', pruned_env nil (tl_cons X L1) SL SL'

pruned_env_exists < <b>search.</b>
Proof completed.
</pre>
<a name="350"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_vars : 
forall FVs SL SL', pruned_env nil FVs SL SL' -> vars_of_sctx SL' FVs.</b>
</pre>
<a name="351"></a>
<pre>


  ============================
   forall FVs SL SL', pruned_env nil FVs SL SL' -> vars_of_sctx SL' FVs

pruned_env_vars < <b>induction on 1.</b>
</pre>
<a name="352"></a>
<pre>


  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  ============================
   forall FVs SL SL', pruned_env nil FVs SL SL' @ -> vars_of_sctx SL' FVs

pruned_env_vars < <b>intros.</b>
</pre>
<a name="353"></a>
<pre>

  Variables: FVs, SL, SL'
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H1 : pruned_env nil FVs SL SL' @
  ============================
   vars_of_sctx SL' FVs

pruned_env_vars < <b>case H1.</b>
</pre>
<a name="354"></a>
<pre>
Subgoal 1:

  Variables: FVs, SL, SL'
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  ============================
   vars_of_sctx nil tl_nil

Subgoal 2 is:
 vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < <b>search.</b>
</pre>
<a name="355"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', SL'1, T, X, FVs1
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H2 : member (of X T) SL
  H3 : pruned_env nil FVs1 SL SL'1 *
  ============================
   vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < <b>apply IH to H3.</b>
</pre>
<a name="356"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', SL'1, T, X, FVs1
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H2 : member (of X T) SL
  H3 : pruned_env nil FVs1 SL SL'1 *
  H4 : vars_of_sctx SL'1 FVs1
  ============================
   vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < <b>search.</b>
Proof completed.
</pre>
<a name="357"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_sctx_source : 
forall FV SL SL' X T, pruned_env nil FV SL SL' -> member (of X T) SL' ->
  member (of X T) SL.</b>
</pre>
<a name="358"></a>
<pre>


  ============================
   forall FV SL SL' X T, pruned_env nil FV SL SL' -> member (of X T) SL' ->
     member (of X T) SL

pruned_env_sctx_source < <b>induction on 1.</b>
</pre>
<a name="359"></a>
<pre>


  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  ============================
   forall FV SL SL' X T, pruned_env nil FV SL SL' @ -> member (of X T) SL' ->
     member (of X T) SL

pruned_env_sctx_source < <b>intros.</b>
</pre>
<a name="360"></a>
<pre>

  Variables: FV, SL, SL', X, T
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H1 : pruned_env nil FV SL SL' @
  H2 : member (of X T) SL'
  ============================
   member (of X T) SL

pruned_env_sctx_source < <b>case H1.</b>
</pre>
<a name="361"></a>
<pre>
Subgoal 1:

  Variables: FV, SL, SL', X, T
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H2 : member (of X T) nil
  ============================
   member (of X T) SL

Subgoal 2 is:
 member (of X T) SL

pruned_env_sctx_source < <b>case H2.</b>
</pre>
<a name="362"></a>
<pre>
Subgoal 2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H2 : member (of X T) (of X1 T1 :: SL'1)
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  ============================
   member (of X T) SL

pruned_env_sctx_source < <b>case H2.</b>
</pre>
<a name="363"></a>
<pre>
Subgoal 2.1:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  ============================
   member (of X1 T1) SL

Subgoal 2.2 is:
 member (of X T) SL

pruned_env_sctx_source < <b>search.</b>
</pre>
<a name="364"></a>
<pre>
Subgoal 2.2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  H5 : member (of X T) SL'1
  ============================
   member (of X T) SL

pruned_env_sctx_source < <b>apply IH to H4 H5.</b>
</pre>
<a name="365"></a>
<pre>
Subgoal 2.2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  H5 : member (of X T) SL'1
  H6 : member (of X T) SL
  ============================
   member (of X T) SL

pruned_env_sctx_source < <b>search.</b>
Proof completed.
</pre>
<a name="366"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_sctx : 
forall SL BVL FVs SL', sctx' SL -> bvars BVL -> pruned_env BVL FVs SL SL' ->
  sctx' SL'.</b>
</pre>
<a name="367"></a>
<pre>


  ============================
   forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
     pruned_env BVL FVs SL SL' -> sctx' SL'

pruned_env_sctx < <b>induction on 3.</b>
</pre>
<a name="368"></a>
<pre>


  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  ============================
   forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
     pruned_env BVL FVs SL SL' @ -> sctx' SL'

pruned_env_sctx < <b>intros.</b>
</pre>
<a name="369"></a>
<pre>

  Variables: SL, BVL, FVs, SL'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars BVL
  H3 : pruned_env BVL FVs SL SL' @
  ============================
   sctx' SL'

pruned_env_sctx < <b>case H3.</b>
</pre>
<a name="370"></a>
<pre>
Subgoal 1:

  Variables: SL, BVL, FVs, SL'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  ============================
   sctx' nil

Subgoal 2 is:
 sctx' (of X T :: SL'1)

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>search.</b>
</pre>
<a name="371"></a>
<pre>
Subgoal 2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   sctx' (of X T :: SL'1)

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>unfold.</b>
</pre>
<a name="372"></a>
<pre>
Subgoal 2.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   sctx' SL'1

Subgoal 2.2 is:
 tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>apply IH to H1 H2 H5.</b>
</pre>
<a name="373"></a>
<pre>
Subgoal 2.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : sctx' SL'1
  ============================
   sctx' SL'1

Subgoal 2.2 is:
 tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>search.</b>
</pre>
<a name="374"></a>
<pre>
Subgoal 2.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>apply sctx'_name to H1 H4.</b>
</pre>
<a name="375"></a>
<pre>
Subgoal 2.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : tname X
  ============================
   tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>search.</b>
</pre>
<a name="376"></a>
<pre>
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>intros.</b>
</pre>
<a name="377"></a>
<pre>
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  ============================
   T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>apply pruned_env_sctx_source to H5 H6.</b>
</pre>
<a name="378"></a>
<pre>
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  H7 : member (of X T') SL
  ============================
   T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>apply sctx'_equal to H1 H4 H7.</b>
</pre>
<a name="379"></a>
<pre>
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T') SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  H7 : member (of X T') SL
  ============================
   T' = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>search.</b>
</pre>
<a name="380"></a>
<pre>
Subgoal 3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   sctx' (of n1 T :: SL'1)

pruned_env_sctx < <b>unfold.</b>
</pre>
<a name="381"></a>
<pre>
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>case H1.</b>
</pre>
<a name="382"></a>
<pre>
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>case H2.</b>
</pre>
<a name="383"></a>
<pre>
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  H8 : bvars BVs
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>apply IH to H5 H8 H4.</b>
</pre>
<a name="384"></a>
<pre>
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  H8 : bvars BVs
  H9 : sctx' SL'1
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>search.</b>
</pre>
<a name="385"></a>
<pre>
Subgoal 3.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>search.</b>
</pre>
<a name="386"></a>
<pre>
Subgoal 3.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < <b>intros.</b>
</pre>
<a name="387"></a>
<pre>
Subgoal 3.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (of n1 T') SL'1
  ============================
   T = T'

pruned_env_sctx < <b>apply mem_of_absurd to H5.</b>
Proof completed.
</pre>
<a name="388"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_bound : 
forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' ->
  member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'.</b>
</pre>
<a name="389"></a>
<pre>


  ============================
   forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' ->
     member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'

pruned_env_bound < <b>induction on 1.</b>
</pre>
<a name="390"></a>
<pre>


  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  ============================
   forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' @ ->
     member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'

pruned_env_bound < <b>intros.</b>
</pre>
<a name="391"></a>
<pre>

  Variables: BVL, FVs, SL, SL', X, T
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H1 : pruned_env BVL FVs SL SL' @
  H2 : member (notfree X) BVL
  H3 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_bound < <b>case H1.</b>
</pre>
<a name="392"></a>
<pre>
Subgoal 1:

  Variables: BVL, FVs, SL, SL', X, T
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree X) nil
  H3 : member (of X T) SL
  ============================
   member (of X T) nil

Subgoal 2 is:
 member (of X T) (of X1 T1 :: SL'1)

Subgoal 3 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>case H2.</b>
</pre>
<a name="393"></a>
<pre>
Subgoal 2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, X1, FVs1
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree X) nil
  H3 : member (of X T) SL
  H4 : member (of X1 T1) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   member (of X T) (of X1 T1 :: SL'1)

Subgoal 3 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>case H2.</b>
</pre>
<a name="394"></a>
<pre>
Subgoal 3:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree (X n1)) (notfree n1 :: BVs)
  H3 : member (of (X n1) T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>case H2.</b>
</pre>
<a name="395"></a>
<pre>
Subgoal 3.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H3 : member (of n1 T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>case H3.</b>
</pre>
<a name="396"></a>
<pre>
Subgoal 3.1.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 3.1.2 is:
 member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>search.</b>
</pre>
<a name="397"></a>
<pre>
Subgoal 3.1.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (of n1 T) SL1
  ============================
   member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>apply mem_of_absurd to H5.</b>
</pre>
<a name="398"></a>
<pre>
Subgoal 3.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H3 : member (of (X n1) T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>case H3.</b>
</pre>
<a name="399"></a>
<pre>
Subgoal 3.2.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree n1) BVs
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 3.2.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>search.</b>
</pre>
<a name="400"></a>
<pre>
Subgoal 3.2.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  H6 : member (of (X n1) T) SL1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>apply IH to H4 H5 H6.</b>
</pre>
<a name="401"></a>
<pre>
Subgoal 3.2.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  H6 : member (of (X n1) T) SL1
  H7 : member (of (X n1) T) SL'1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < <b>search.</b>
Proof completed.
</pre>
<a name="402"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_free_aux : 
forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
  {tl_member X FVs} -> member (of X T) SL -> member (of X T) SL'.</b>
</pre>
<a name="403"></a>
<pre>


  ============================
   forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
     {tl_member X FVs} -> member (of X T) SL -> member (of X T) SL'

pruned_env_free_aux < <b>induction on 3.</b>
</pre>
<a name="404"></a>
<pre>


  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  ============================
   forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
     {tl_member X FVs}@ -> member (of X T) SL -> member (of X T) SL'

pruned_env_free_aux < <b>intros.</b>
</pre>
<a name="405"></a>
<pre>

  Variables: FVs, SL, SL', X, T
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil FVs SL SL'
  H3 : {tl_member X FVs}@
  H4 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_free_aux < <b>case H3.</b>
</pre>
<a name="406"></a>
<pre>
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil (tl_cons X L) SL SL'
  H4 : member (of X T) SL
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < <b>case H2.</b>
</pre>
<a name="407"></a>
<pre>
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : member (of X T1) SL
  H6 : pruned_env nil L SL SL'1
  ============================
   member (of X T) (of X T1 :: SL'1)

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < <b>apply sctx'_equal to H1 H4 H5.</b>
</pre>
<a name="408"></a>
<pre>
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T1) SL
  H5 : member (of X T1) SL
  H6 : pruned_env nil L SL SL'1
  ============================
   member (of X T1) (of X T1 :: SL'1)

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < <b>search.</b>
</pre>
<a name="409"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil (tl_cons Y L) SL SL'
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  ============================
   member (of X T) SL'

pruned_env_free_aux < <b>case H2.</b>
</pre>
<a name="410"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  H6 : member (of Y T1) SL
  H7 : pruned_env nil L SL SL'1
  ============================
   member (of X T) (of Y T1 :: SL'1)

pruned_env_free_aux < <b>apply IH to H1 H7 H5 H4.</b>
</pre>
<a name="411"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  H6 : member (of Y T1) SL
  H7 : pruned_env nil L SL SL'1
  H8 : member (of X T) SL'1
  ============================
   member (of X T) (of Y T1 :: SL'1)

pruned_env_free_aux < <b>search.</b>
Proof completed.
</pre>
<a name="412"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_free : 
forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
  pruned_env BVLs FVs SL SL' -> {tl_member X FVs} -> member (of X T) SL ->
  member (of X T) SL'.</b>
</pre>
<a name="413"></a>
<pre>


  ============================
   forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
     pruned_env BVLs FVs SL SL' -> {tl_member X FVs} -> member (of X T) SL ->
     member (of X T) SL'

pruned_env_free < <b>induction on 3.</b>
</pre>
<a name="414"></a>
<pre>


  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  ============================
   forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
     pruned_env BVLs FVs SL SL' @ -> {tl_member X FVs} ->
     member (of X T) SL -> member (of X T) SL'

pruned_env_free < <b>intros.</b>
</pre>
<a name="415"></a>
<pre>

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : bvars BVLs
  H3 : pruned_env BVLs FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_free < <b>case H2.</b>
</pre>
<a name="416"></a>
<pre>
Subgoal 1:

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H3 : pruned_env nil FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of (X n1) T) (SL' n1)

pruned_env_free < <b>apply pruned_env_free_aux to H1 H3 H4 H5.</b>
</pre>
<a name="417"></a>
<pre>
Subgoal 1:

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H3 : pruned_env nil FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  H6 : member (of X T) SL'
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of (X n1) T) (SL' n1)

pruned_env_free < <b>search.</b>
</pre>
<a name="418"></a>
<pre>
Subgoal 2:

  Variables: BVLs, FVs, SL, SL', X, T, L
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (SL n1)
  H3 : pruned_env (notfree n1 :: L) (FVs n1) (SL n1) (SL' n1) @
  H4 : {tl_member (X n1) (FVs n1)}
  H5 : member (of (X n1) T) (SL n1)
  H6 : bvars L
  ============================
   member (of (X n1) T) (SL' n1)

pruned_env_free < <b>case H3.</b>
</pre>
<a name="419"></a>
<pre>
Subgoal 2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H5 : member (of (X n1) T) (of n1 T1 :: SL1)
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>case H5.</b>
</pre>
<a name="420"></a>
<pre>
Subgoal 2.1:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member n1 FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 2.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>search.</b>
</pre>
<a name="421"></a>
<pre>
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>assert bvars (notfree n1 :: L).</b>
</pre>
<a name="422"></a>
<pre>
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>case H1.</b>
</pre>
<a name="423"></a>
<pre>
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  H10 : sctx' SL1
  H11 : tname n1
  H12 : forall T', member (of n1 T') SL1 -> T1 = T'
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>apply IH to H10 H6 H7 H4 H8.</b>
</pre>
<a name="424"></a>
<pre>
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  H10 : sctx' SL1
  H11 : tname n1
  H12 : forall T', member (of n1 T') SL1 -> T1 = T'
  H13 : member (of (X n1) T) SL'1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < <b>search.</b>
Proof completed.
</pre>
<a name="425"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_typing : 
forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T} ->
  vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
  subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}.</b>
</pre>
<a name="426"></a>
<pre>


  ============================
   forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T} ->
     vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
     subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}

pruned_env_typing < <b>induction on 2.</b>
</pre>
<a name="427"></a>
<pre>


  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  ============================
   forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}@ ->
     vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
     subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}

pruned_env_typing < <b>intros.</b>
</pre>
<a name="428"></a>
<pre>

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs''
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H2 : {SL |- of M T}@
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  ============================
   {SL' |- of M T}

pruned_env_typing < <b>case H2.</b>
</pre>
<a name="429"></a>
<pre>
Subgoal 1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (lnat X) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  ============================
   {SL' |- of (lnat X) nat_t}

Subgoal 2 is:
 {SL' |- of (cst C) T}

Subgoal 3 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>search.</b>
</pre>
<a name="430"></a>
<pre>
Subgoal 2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', C
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (cst C) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of_const C T}*
  ============================
   {SL' |- of (cst C) T}

Subgoal 3 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply of_const_sctx' to H1 H8.</b>
</pre>
<a name="431"></a>
<pre>
Subgoal 2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', C
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (cst C) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of_const C T}*
  H9 : {of_const C T}
  ============================
   {SL' |- of (cst C) T}

Subgoal 3 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>search.</b>
</pre>
<a name="432"></a>
<pre>
Subgoal 3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (app M1 N) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H5.</b>
</pre>
<a name="433"></a>
<pre>
Subgoal 3.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- notfree (app M1 N)}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.2 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply bvars_notfree to H4 H10.</b>
</pre>
<a name="434"></a>
<pre>
Subgoal 3.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- notfree (app M1 N)}
  H11 : tname (app M1 N)
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.2 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H11.</b>
</pre>
<a name="435"></a>
<pre>
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply tl_mem_bvar to H4 H10.</b>
</pre>
<a name="436"></a>
<pre>
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  H11 : {tl_member (app M1 N) FVs}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply vars_of_sctx_mem_name to H1 H3 H11.</b>
</pre>
<a name="437"></a>
<pre>
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  H11 : {tl_member (app M1 N) FVs}
  H12 : tname (app M1 N)
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H12.</b>
</pre>
<a name="438"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply fvars_islist to H4 H10.</b>
</pre>
<a name="439"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply fvars_islist to H4 H11.</b>
</pre>
<a name="440"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply combine_bvar to H4 H12.</b>
</pre>
<a name="441"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply combine_islist to H13 H14 H15.</b>
</pre>
<a name="442"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply combine_subset2 to H13 H14 H15.</b>
</pre>
<a name="443"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply subset_trans to H17 H6.</b>
</pre>
<a name="444"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply IH to H1 H8 H3 H4 H10 H18 H7.</b>
</pre>
<a name="445"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply combine_subset1 to H14 H15.</b>
</pre>
<a name="446"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply subset_trans to H20 H6.</b>
</pre>
<a name="447"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  H21 : subset Fvs2 FVs''
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply IH to H1 H9 H3 H4 H11 H21 H7.</b>
</pre>
<a name="448"></a>
<pre>
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  H21 : subset Fvs2 FVs''
  H22 : {SL' |- of N T1}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>search.</b>
</pre>
<a name="449"></a>
<pre>
Subgoal 3.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL, [F] |- fvars (app M1 N) FVs FVs'}
  H11 : member F BVL
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply bvars_mem to H4 H11.</b>
</pre>
<a name="450"></a>
<pre>
Subgoal 3.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, F, X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL, [notfree X] |- fvars (app M1 N) FVs FVs'}
  H11 : member (notfree X) BVL
  H12 : tname X
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H10.</b>
</pre>
<a name="451"></a>
<pre>
Subgoal 4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (abs M1) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H5.</b>
</pre>
<a name="452"></a>
<pre>
Subgoal 4.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- notfree (abs M1)}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.2 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply bvars_notfree to H4 H9.</b>
</pre>
<a name="453"></a>
<pre>
Subgoal 4.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- notfree (abs M1)}
  H10 : tname (abs M1)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.2 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H10.</b>
</pre>
<a name="454"></a>
<pre>
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply tl_mem_bvar to H4 H9.</b>
</pre>
<a name="455"></a>
<pre>
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  H10 : {tl_member (abs M1) FVs}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply vars_of_sctx_mem_name to H1 H3 H10.</b>
</pre>
<a name="456"></a>
<pre>
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  H10 : {tl_member (abs M1) FVs}
  H11 : tname (abs M1)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H11.</b>
</pre>
<a name="457"></a>
<pre>
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>assert pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL').</b>
</pre>
<a name="458"></a>
<pre>
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>assert bvars (notfree n1 :: BVL).</b>
</pre>
<a name="459"></a>
<pre>
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>assert vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs).</b>
</pre>
<a name="460"></a>
<pre>
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply sctx'_extend to H1 with T = T1.</b>
</pre>
<a name="461"></a>
<pre>
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply fvars_extend to H11 H9 with X = n1.</b>
</pre>
<a name="462"></a>
<pre>
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  H14 : {BVL, notfree n1 |- fvars (M1 n1) (tl_cons n1 FVs) FVs'}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply IH to H13 H8 H12 H11 H14 H6 H10.</b>
</pre>
<a name="463"></a>
<pre>
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  H14 : {BVL, notfree n1 |- fvars (M1 n1) (tl_cons n1 FVs) FVs'}
  H15 : {SL', of n1 T1 |- of (M1 n1) T2}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>search.</b>
</pre>
<a name="464"></a>
<pre>
Subgoal 4.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1, F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, [F] |- fvars (abs M1) FVs FVs'}
  H10 : member F BVL
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>apply bvars_mem to H4 H10.</b>
</pre>
<a name="465"></a>
<pre>
Subgoal 4.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1, F, X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, [notfree X] |- fvars (abs M1) FVs FVs'}
  H10 : member (notfree X) BVL
  H11 : tname X
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 5 is:
 {SL' |- of M T}

pruned_env_typing < <b>case H9.</b>
</pre>
<a name="466"></a>
<pre>
Subgoal 5:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, [F] |- of M T}*
  H9 : member F SL
  ============================
   {SL' |- of M T}

pruned_env_typing < <b>apply sctx'_mem to H1 H9.</b>
</pre>
<a name="467"></a>
<pre>
Subgoal 5:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, [of X T1] |- of M T}*
  H9 : member (of X T1) SL
  H10 : tname X
  ============================
   {SL' |- of M T}

pruned_env_typing < <b>case H8.</b>
</pre>
<a name="468"></a>
<pre>
Subgoal 5:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H9 : member (of M T) SL
  H10 : tname M
  ============================
   {SL' |- of M T}

pruned_env_typing < <b>case H10.</b>
</pre>
<a name="469"></a>
<pre>
Subgoal 5:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H5 : {BVL n1 |- fvars n1 (FVs n1) (FVs' n1)}
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H5.</b>
</pre>
<a name="470"></a>
<pre>
Subgoal 5.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- notfree n1}
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H11.</b>
</pre>
<a name="471"></a>
<pre>
Subgoal 5.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [F1 n1] |- notfree n1}
  H13 : member (F1 n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>apply bvars_mem to H4 H13.</b>
</pre>
<a name="472"></a>
<pre>
Subgoal 5.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree (X1 n1)] |- notfree n1}
  H13 : member (notfree (X1 n1)) (BVL n1)
  H14 : tname (X1 n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H14.</b>
</pre>
<a name="473"></a>
<pre>
Subgoal 5.1.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n2 n1)
  H3 : vars_of_sctx (SL n2 n1) (FVs n2 n1)
  H4 : bvars (BVL n2 n1)
  H6 : subset tl_nil (FVs'' n2 n1)
  H7 : pruned_env (BVL n2 n1) (FVs'' n2 n1) (SL n2 n1) (SL' n2 n1)
  H9 : member (of n1 T) (SL n2 n1)
  H12 : {BVL n2 n1, [notfree n2] |- notfree n1}
  H13 : member (notfree n2) (BVL n2 n1)
  ============================
   {SL' n2 n1 |- of n1 T}

Subgoal 5.1.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H12.</b>
</pre>
<a name="474"></a>
<pre>
Subgoal 5.1.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree n1] |- notfree n1}
  H13 : member (notfree n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>apply pruned_env_bound to H7 H13 H9.</b>
</pre>
<a name="475"></a>
<pre>
Subgoal 5.1.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree n1] |- notfree n1}
  H13 : member (notfree n1) (BVL n1)
  H15 : member (of n1 T) (SL' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.2 is:
 {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>search.</b>
</pre>
<a name="476"></a>
<pre>
Subgoal 5.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (tl_cons n1 tl_nil) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H6.</b>
</pre>
<a name="477"></a>
<pre>
Subgoal 5.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  H12 : {tl_member n1 (FVs'' n1)}
  H13 : subset tl_nil (FVs'' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>apply pruned_env_free to H1 H4 H7 H12 H9.</b>
</pre>
<a name="478"></a>
<pre>
Subgoal 5.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  H12 : {tl_member n1 (FVs'' n1)}
  H13 : subset tl_nil (FVs'' n1)
  H14 : member (of n1 T) (SL' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 5.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < <b>search.</b>
</pre>
<a name="479"></a>
<pre>
Subgoal 5.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1, [F1 n1] |- fvars n1 (FVs n1) (FVs' n1)}
  H12 : member (F1 n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < <b>apply bvars_mem to H4 H12.</b>
</pre>
<a name="480"></a>
<pre>
Subgoal 5.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1, [notfree (X1 n1)] |- fvars n1 (FVs n1) (FVs' n1)}
  H12 : member (notfree (X1 n1)) (BVL n1)
  H13 : tname (X1 n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < <b>case H11.</b>
Proof completed.
</pre>
<a name="481"></a>
<pre class="code">
Abella < <b>Define reified_env : olist -> ty -> prop by 
reified_env nil unit_t;
reified_env (of X T :: SL) (product T RT) := reified_env SL RT.</b>
</pre>
<a name="482"></a>
<pre class="code">
Abella < <b>Theorem reified_env_exists : 
forall SL, sctx' SL -> (exists Ty, reified_env SL Ty).</b>
</pre>
<a name="483"></a>
<pre>


  ============================
   forall SL, sctx' SL -> (exists Ty, reified_env SL Ty)

reified_env_exists < <b>induction on 1.</b>
</pre>
<a name="484"></a>
<pre>


  IH : forall SL, sctx' SL * -> (exists Ty, reified_env SL Ty)
  ============================
   forall SL, sctx' SL @ -> (exists Ty, reified_env SL Ty)

reified_env_exists < <b>intros.</b>
</pre>
<a name="485"></a>
<pre>

  Variables: SL
  IH : forall SL, sctx' SL * -> (exists Ty, reified_env SL Ty)
  H1 : sctx' SL @
  ============================
   exists Ty, reified_env SL Ty

reified_env_exists < <b>case H1.</b>
</pre>
<a name="486"></a>
<pre>
Subgoal 1:

  Variables: SL
  IH : forall SL, sctx' SL * -> (exists Ty, reified_env SL Ty)
  ============================
   exists Ty, reified_env nil Ty

Subgoal 2 is:
 exists Ty, reified_env (of X T :: L) Ty

reified_env_exists < <b>search.</b>
</pre>
<a name="487"></a>
<pre>
Subgoal 2:

  Variables: SL, L, T, X
  IH : forall SL, sctx' SL * -> (exists Ty, reified_env SL Ty)
  H2 : sctx' L *
  H3 : tname X
  H4 : forall T', member (of X T') L -> T = T'
  ============================
   exists Ty, reified_env (of X T :: L) Ty

reified_env_exists < <b>apply IH to H2.</b>
</pre>
<a name="488"></a>
<pre>
Subgoal 2:

  Variables: SL, L, T, X, Ty
  IH : forall SL, sctx' SL * -> (exists Ty, reified_env SL Ty)
  H2 : sctx' L *
  H3 : tname X
  H4 : forall T', member (of X T') L -> T = T'
  H5 : reified_env L Ty
  ============================
   exists Ty, reified_env (of X T :: L) Ty

reified_env_exists < <b>search.</b>
Proof completed.
</pre>
<a name="489"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_reification_type : 
forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' -> sctx' SL' ->
  {mapvar FVs X Map} -> reified_env SL' RTy ->
  of_ml (cof X RTy :: nil) Map SL'.</b>
</pre>
<a name="490"></a>
<pre>


  ============================
   forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' -> sctx' SL' ->
     {mapvar FVs X Map} -> reified_env SL' RTy ->
     of_ml (cof X RTy :: nil) Map SL'

pruned_env_reification_type < <b>induction on 1.</b>
</pre>
<a name="491"></a>
<pre>


  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  ============================
   forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' @ -> sctx' SL' ->
     {mapvar FVs X Map} -> reified_env SL' RTy ->
     of_ml (cof X RTy :: nil) Map SL'

pruned_env_reification_type < <b>intros.</b>
</pre>
<a name="492"></a>
<pre>

  Variables: FVs, SL, SL', RTy, Map, X
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H1 : pruned_env nil FVs SL SL' @
  H2 : sctx' SL'
  H3 : {mapvar FVs X Map}
  H4 : reified_env SL' RTy
  ============================
   of_ml (cof X RTy :: nil) Map SL'

pruned_env_reification_type < <b>case H1.</b>
</pre>
<a name="493"></a>
<pre>
Subgoal 1:

  Variables: FVs, SL, SL', RTy, Map, X
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H2 : sctx' nil
  H3 : {mapvar tl_nil X Map}
  H4 : reified_env nil RTy
  ============================
   of_ml (cof X RTy :: nil) Map nil

Subgoal 2 is:
 of_ml (cof X RTy :: nil) Map (of X1 T :: SL'1)

pruned_env_reification_type < <b>case H3.</b>
</pre>
<a name="494"></a>
<pre>
Subgoal 1:

  Variables: FVs, SL, SL', RTy, Map, X
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H2 : sctx' nil
  H4 : reified_env nil RTy
  ============================
   of_ml (cof X RTy :: nil) ml_nil nil

Subgoal 2 is:
 of_ml (cof X RTy :: nil) Map (of X1 T :: SL'1)

pruned_env_reification_type < <b>search.</b>
</pre>
<a name="495"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H2 : sctx' (of X1 T :: SL'1)
  H3 : {mapvar (tl_cons X1 FVs1) X Map}
  H4 : reified_env (of X1 T :: SL'1) RTy
  H5 : member (of X1 T) SL
  H6 : pruned_env nil FVs1 SL SL'1 *
  ============================
   of_ml (cof X RTy :: nil) Map (of X1 T :: SL'1)

pruned_env_reification_type < <b>case H2.</b>
</pre>
<a name="496"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H3 : {mapvar (tl_cons X1 FVs1) X Map}
  H4 : reified_env (of X1 T :: SL'1) RTy
  H5 : member (of X1 T) SL
  H6 : pruned_env nil FVs1 SL SL'1 *
  H7 : sctx' SL'1
  H8 : tname X1
  H9 : forall T', member (of X1 T') SL'1 -> T = T'
  ============================
   of_ml (cof X RTy :: nil) Map (of X1 T :: SL'1)

pruned_env_reification_type < <b>case H8.</b>
</pre>
<a name="497"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H3 : {mapvar (tl_cons n1 (FVs1 n1)) X (Map n1)}
  H4 : reified_env (of n1 T :: SL'1 n1) RTy
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  ============================
   of_ml (cof X RTy :: nil) (Map n1) (of n1 T :: SL'1 n1)

pruned_env_reification_type < <b>case H3.</b>
</pre>
<a name="498"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H4 : reified_env (of n1 T :: SL'1 n1) RTy
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  ============================
   of_ml (cof X RTy :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < <b>case H4.</b>
</pre>
<a name="499"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap, RT
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  H11 : reified_env (SL'1 n1) RT
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < <b>apply IH to H6 H7 H10 H11.</b>
</pre>
<a name="500"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap, RT
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  H11 : reified_env (SL'1 n1) RT
  H12 : of_ml (cof (rst X) RT :: nil) (LMap n1) (SL'1 n1)
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < <b>assert {cof X (product T RT) |- cof (fst X) T}.</b>
</pre>
<a name="501"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap, RT
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  H11 : reified_env (SL'1 n1) RT
  H12 : of_ml (cof (rst X) RT :: nil) (LMap n1) (SL'1 n1)
  H13 : {cof X (product T RT) |- cof (fst X) T}
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < <b>apply map_rst to H12 with T = T.</b>
</pre>
<a name="502"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap, RT
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  H11 : reified_env (SL'1 n1) RT
  H12 : of_ml (cof (rst X) RT :: nil) (LMap n1) (SL'1 n1)
  H13 : {cof X (product T RT) |- cof (fst X) T}
  H14 : of_ml (cof X (product T RT) :: nil) (LMap n1) (SL'1 n1)
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < <b>assert {cof X (product T RT) |- cof (rst X) RT}.</b>
</pre>
<a name="503"></a>
<pre>
Subgoal 2:

  Variables: FVs, SL, SL', RTy, Map, X, SL'1, T, X1, FVs1, LMap, RT
  IH : forall FVs SL SL' RTy Map X, pruned_env nil FVs SL SL' * ->
         sctx' SL' -> {mapvar FVs X Map} -> reified_env SL' RTy ->
         of_ml (cof X RTy :: nil) Map SL'
  H5 : member (of n1 T) (SL n1)
  H6 : pruned_env nil (FVs1 n1) (SL n1) (SL'1 n1) *
  H7 : sctx' (SL'1 n1)
  H9 : forall T', member (of n1 T') (SL'1 n1) -> T = T'
  H10 : {mapvar (FVs1 n1) (rst X) (LMap n1)}
  H11 : reified_env (SL'1 n1) RT
  H12 : of_ml (cof (rst X) RT :: nil) (LMap n1) (SL'1 n1)
  H13 : {cof X (product T RT) |- cof (fst X) T}
  H14 : of_ml (cof X (product T RT) :: nil) (LMap n1) (SL'1 n1)
  H15 : {cof X (product T RT) |- cof (rst X) RT}
  ============================
   of_ml (cof X (product T RT) :: nil) (ml_cons (map n1 (fst X)) (LMap n1)) (of n1 T :: SL'1 n1)

pruned_env_reification_type < <b>search.</b>
Proof completed.
</pre>
<a name="504"></a>
<pre class="code">
Abella < <b>Theorem pruned_env_reification_env : 
forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
  pruned_env nil FVs SL SL' -> reified_env SL' Ty -> {mapenv FVs Map PE} ->
  {CL |- cof PE Ty}.</b>
</pre>
<a name="505"></a>
<pre>


  ============================
   forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
     pruned_env nil FVs SL SL' -> reified_env SL' Ty ->
     {mapenv FVs Map PE} -> {CL |- cof PE Ty}

pruned_env_reification_env < <b>induction on 3.</b>
</pre>
<a name="506"></a>
<pre>


  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  ============================
   forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
     pruned_env nil FVs SL SL' @ -> reified_env SL' Ty ->
     {mapenv FVs Map PE} -> {CL |- cof PE Ty}

pruned_env_reification_env < <b>intros.</b>
</pre>
<a name="507"></a>
<pre>

  Variables: CL, Map, SL, SL', Ty, PE, FVs
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H3 : pruned_env nil FVs SL SL' @
  H4 : reified_env SL' Ty
  H5 : {mapenv FVs Map PE}
  ============================
   {CL |- cof PE Ty}

pruned_env_reification_env < <b>case H3.</b>
</pre>
<a name="508"></a>
<pre>
Subgoal 1:

  Variables: CL, Map, SL, SL', Ty, PE, FVs
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H4 : reified_env nil Ty
  H5 : {mapenv tl_nil Map PE}
  ============================
   {CL |- cof PE Ty}

Subgoal 2 is:
 {CL |- cof PE Ty}

pruned_env_reification_env < <b>case H4.</b>
</pre>
<a name="509"></a>
<pre>
Subgoal 1:

  Variables: CL, Map, SL, SL', Ty, PE, FVs
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H5 : {mapenv tl_nil Map PE}
  ============================
   {CL |- cof PE unit_t}

Subgoal 2 is:
 {CL |- cof PE Ty}

pruned_env_reification_env < <b>case H5.</b>
</pre>
<a name="510"></a>
<pre>
Subgoal 1:

  Variables: CL, Map, SL, SL', Ty, PE, FVs
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  ============================
   {CL |- cof unit unit_t}

Subgoal 2 is:
 {CL |- cof PE Ty}

pruned_env_reification_env < <b>search.</b>
</pre>
<a name="511"></a>
<pre>
Subgoal 2:

  Variables: CL, Map, SL, SL', Ty, PE, FVs, SL'1, T, X, FVs1
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H4 : reified_env (of X T :: SL'1) Ty
  H5 : {mapenv (tl_cons X FVs1) Map PE}
  H6 : member (of X T) SL
  H7 : pruned_env nil FVs1 SL SL'1 *
  ============================
   {CL |- cof PE Ty}

pruned_env_reification_env < <b>case H5.</b>
</pre>
<a name="512"></a>
<pre>
Subgoal 2:

  Variables: CL, Map, SL, SL', Ty, PE, FVs, SL'1, T, X, FVs1, ML, M
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H4 : reified_env (of X T :: SL'1) Ty
  H6 : member (of X T) SL
  H7 : pruned_env nil FVs1 SL SL'1 *
  H8 : {ml_member (map X M) Map}
  H9 : {mapenv FVs1 Map ML}
  ============================
   {CL |- cof (cross M ML) Ty}

pruned_env_reification_env < <b>case H4.</b>
</pre>
<a name="513"></a>
<pre>
Subgoal 2:

  Variables: CL, Map, SL, SL', Ty, PE, FVs, SL'1, T, X, FVs1, ML, M, RT
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H6 : member (of X T) SL
  H7 : pruned_env nil FVs1 SL SL'1 *
  H8 : {ml_member (map X M) Map}
  H9 : {mapenv FVs1 Map ML}
  H10 : reified_env SL'1 RT
  ============================
   {CL |- cof (cross M ML) (product T RT)}

pruned_env_reification_env < <b>apply of_ml_member_type to H1 H2 H8 H6.</b>
</pre>
<a name="514"></a>
<pre>
Subgoal 2:

  Variables: CL, Map, SL, SL', Ty, PE, FVs, SL'1, T, X, FVs1, ML, M, RT
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H6 : member (of X T) SL
  H7 : pruned_env nil FVs1 SL SL'1 *
  H8 : {ml_member (map X M) Map}
  H9 : {mapenv FVs1 Map ML}
  H10 : reified_env SL'1 RT
  H11 : {CL |- cof M T}
  ============================
   {CL |- cof (cross M ML) (product T RT)}

pruned_env_reification_env < <b>apply IH to H1 H2 H7 H10 H9.</b>
</pre>
<a name="515"></a>
<pre>
Subgoal 2:

  Variables: CL, Map, SL, SL', Ty, PE, FVs, SL'1, T, X, FVs1, ML, M, RT
  IH : forall CL Map SL SL' Ty PE FVs, sctx' SL -> of_ml CL Map SL ->
         pruned_env nil FVs SL SL' * -> reified_env SL' Ty ->
         {mapenv FVs Map PE} -> {CL |- cof PE Ty}
  H1 : sctx' SL
  H2 : of_ml CL Map SL
  H6 : member (of X T) SL
  H7 : pruned_env nil FVs1 SL SL'1 *
  H8 : {ml_member (map X M) Map}
  H9 : {mapenv FVs1 Map ML}
  H10 : reified_env SL'1 RT
  H11 : {CL |- cof M T}
  H12 : {CL |- cof ML RT}
  ============================
   {CL |- cof (cross M ML) (product T RT)}

pruned_env_reification_env < <b>search.</b>
Proof completed.
</pre>
<a name="516"></a>
<pre class="code">
Abella < <b>Theorem type_pres : 
forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
  {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs} -> {CL |- cof N T}.</b>
</pre>
<a name="517"></a>
<pre>


  ============================
   forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
     {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs} ->
     {CL |- cof N T}

type_pres < <b>induction on 6.</b>
</pre>
<a name="518"></a>
<pre>


  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  ============================
   forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
     {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}@ ->
     {CL |- cof N T}

type_pres < <b>intros.</b>
</pre>
<a name="519"></a>
<pre>

  Variables: SL, CL, Map, M, N, T, Vs
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of M T}
  H5 : vars_of_sctx SL Vs
  H6 : {cc M N Map Vs}@
  ============================
   {CL |- cof N T}

type_pres < <b>case H6.</b>
</pre>
<a name="520"></a>
<pre>
Subgoal 1:

  Variables: SL, CL, Map, M, N, T, Vs
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of M T}
  H5 : vars_of_sctx SL Vs
  H7 : {ml_member (map M N) Map}*
  ============================
   {CL |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply map_name to H3 H7.</b>
</pre>
<a name="521"></a>
<pre>
Subgoal 1:

  Variables: SL, CL, Map, M, N, T, Vs
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of M T}
  H5 : vars_of_sctx SL Vs
  H7 : {ml_member (map M N) Map}*
  H8 : tname M
  ============================
   {CL |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H8.</b>
</pre>
<a name="522"></a>
<pre>
Subgoal 1:

  Variables: SL, CL, Map, M, N, T, Vs
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H4 : {SL n1 |- of n1 T}
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H4.</b>
</pre>
<a name="523"></a>
<pre>
Subgoal 1:

  Variables: SL, CL, Map, M, N, T, Vs, F
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  H9 : {SL n1, [F n1] |- of n1 T}
  H10 : member (F n1) (SL n1)
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply sctx'_mem to H1 H10.</b>
</pre>
<a name="524"></a>
<pre>
Subgoal 1:

  Variables: SL, CL, Map, M, N, T, Vs, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  H9 : {SL n1, [of (X n1) T1] |- of n1 T}
  H10 : member (of (X n1) T1) (SL n1)
  H11 : tname (X n1)
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H11.</b>
</pre>
<a name="525"></a>
<pre>
Subgoal 1.1:

  Variables: SL, CL, Map, M, N, T, Vs, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n2 n1)
  H2 : cctx (CL n2 n1)
  H3 : of_ml (CL n2 n1) (Map n2 n1) (SL n2 n1)
  H5 : vars_of_sctx (SL n2 n1) (Vs n2 n1)
  H7 : {ml_member (map n1 N) (Map n2 n1)}*
  H9 : {SL n2 n1, [of n2 T1] |- of n1 T}
  H10 : member (of n2 T1) (SL n2 n1)
  ============================
   {CL n2 n1 |- cof N T}

Subgoal 1.2 is:
 {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H9.</b>
</pre>
<a name="526"></a>
<pre>
Subgoal 1.2:

  Variables: SL, CL, Map, M, N, T, Vs, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  H9 : {SL n1, [of n1 T1] |- of n1 T}
  H10 : member (of n1 T1) (SL n1)
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H9.</b>
</pre>
<a name="527"></a>
<pre>
Subgoal 1.2:

  Variables: SL, CL, Map, M, N, T, Vs, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  H10 : member (of n1 T) (SL n1)
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply of_ml_member_type to H1 H3 H7 H10.</b>
</pre>
<a name="528"></a>
<pre>
Subgoal 1.2:

  Variables: SL, CL, Map, M, N, T, Vs, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {ml_member (map n1 N) (Map n1)}*
  H10 : member (of n1 T) (SL n1)
  H12 : {CL n1 |- cof N T}
  ============================
   {CL n1 |- cof N T}

Subgoal 2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>search.</b>
</pre>
<a name="529"></a>
<pre>
Subgoal 2:

  Variables: SL, CL, Map, M, N, T, Vs, N1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (lnat N1) T}
  H5 : vars_of_sctx SL Vs
  ============================
   {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H4.</b>
</pre>
<a name="530"></a>
<pre>
Subgoal 2.1:

  Variables: SL, CL, Map, M, N, T, Vs, N1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  ============================
   {CL |- cof (clnat N1) nat_t}

Subgoal 2.2 is:
 {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>search.</b>
</pre>
<a name="531"></a>
<pre>
Subgoal 2.2:

  Variables: SL, CL, Map, M, N, T, Vs, N1, F
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL, [F] |- of (lnat N1) T}
  H8 : member F SL
  ============================
   {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply sctx'_mem to H1 H8.</b>
</pre>
<a name="532"></a>
<pre>
Subgoal 2.2:

  Variables: SL, CL, Map, M, N, T, Vs, N1, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL, [of X T1] |- of (lnat N1) T}
  H8 : member (of X T1) SL
  H9 : tname X
  ============================
   {CL |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H9.</b>
</pre>
<a name="533"></a>
<pre>
Subgoal 2.2:

  Variables: SL, CL, Map, M, N, T, Vs, N1, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {SL n1, [of n1 T1] |- of (lnat N1) T}
  H8 : member (of n1 T1) (SL n1)
  ============================
   {CL n1 |- cof (clnat N1) T}

Subgoal 3 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H7.</b>
</pre>
<a name="534"></a>
<pre>
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>assert bvars nil.</b>
</pre>
<a name="535"></a>
<pre>
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply fvars_subset to H11 H7.</b>
</pre>
<a name="536"></a>
<pre>
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply pruned_env_exists to H1 H5 H12.</b>
</pre>
<a name="537"></a>
<pre>
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL'
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply fvars_islist to H11 H7.</b>
</pre>
<a name="538"></a>
<pre>
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL'
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply subset_refl to H14.</b>
</pre>
<a name="539"></a>
<pre>
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL'
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply pruned_env_typing to H1 H4 H5 H11 H7 H15 H13.</b>
</pre>
<a name="540"></a>
<pre>
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL'
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H16 : {SL' |- of (abs M1) T}
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply pruned_env_sctx to H1 H11 H13.</b>
</pre>
<a name="541"></a>
<pre>
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL'
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H16 : {SL' |- of (abs M1) T}
  H17 : sctx' SL'
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply reified_env_exists to H17.</b>
</pre>
<a name="542"></a>
<pre>
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H16 : {SL' |- of (abs M1) T}
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply pruned_env_reification_type to H13 H17 H9 H18.</b>
</pre>
<a name="543"></a>
<pre>
Subgoal 3:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H16 : {SL' |- of (abs M1) T}
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H16.</b>
</pre>
<a name="544"></a>
<pre>
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>assert tname n1.</b>
</pre>
<a name="545"></a>
<pre>
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply of_ml_extend_map to H19 H21 with X = n1, Y = n2, T = T1.</b>
</pre>
<a name="546"></a>
<pre>
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply pruned_env_vars to H13.</b>
</pre>
<a name="547"></a>
<pre>
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>assert vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs).</b>
</pre>
<a name="548"></a>
<pre>
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply sctx'_extend to H17 with T = T1.</b>
</pre>
<a name="549"></a>
<pre>
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H25 : sctx' (of n1 T1 :: SL')
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>assert cctx (cof n2 T1 :: cof n3 Ty :: nil).</b>
</pre>
<a name="550"></a>
<pre>
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H25 : sctx' (of n1 T1 :: SL')
  H26 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply IH to H25 H26 H22 H20 H24 H10.</b>
</pre>
<a name="551"></a>
<pre>
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H25 : sctx' (of n1 T1 :: SL')
  H26 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  H27 : {cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>assert {CL, cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}.</b>
</pre>
<a name="552"></a>
<pre>
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H25 : sctx' (of n1 T1 :: SL')
  H26 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  H27 : {cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  H28 : {CL, cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply pruned_env_reification_env to H1 H3 H13 H18 H8.</b>
</pre>
<a name="553"></a>
<pre>
Subgoal 3.1:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, T2, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) (arr T1 T2)}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', of n1 T1 |- of (M1 n1) T2}
  H21 : tname n1
  H22 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H23 : vars_of_sctx SL' NFVs
  H24 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H25 : sctx' (of n1 T1 :: SL')
  H26 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  H27 : {cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  H28 : {CL, cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  H29 : {CL |- cof PE Ty}
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (arr T1 T2)}

Subgoal 3.2 is:
 {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>search 10.</b>
</pre>
<a name="554"></a>
<pre>
Subgoal 3.2:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, F
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', [F] |- of (abs M1) T}
  H21 : member F SL'
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply sctx'_mem to H17 H21.</b>
</pre>
<a name="555"></a>
<pre>
Subgoal 3.2:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, F, X,
             T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (abs M1) T}
  H5 : vars_of_sctx SL Vs
  H7 : {fvars (abs M1) Vs NFVs}*
  H8 : {mapenv NFVs Map PE}*
  H9 : {mapvar NFVs n1 (NMap n1)}*
  H10 : {cc (M1 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H11 : bvars nil
  H12 : subset NFVs Vs
  H13 : pruned_env nil NFVs SL SL'
  H14 : islist NFVs
  H15 : subset NFVs NFVs
  H17 : sctx' SL'
  H18 : reified_env SL' Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : {SL', [of X T1] |- of (abs M1) T}
  H21 : member (of X T1) SL'
  H22 : tname X
  ============================
   {CL |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H22.</b>
</pre>
<a name="556"></a>
<pre>
Subgoal 3.2:

  Variables: SL, CL, Map, M, N, T, Vs, NFVs, NMap, P, M1, PE, SL', Ty, F, X,
             T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n4)
  H2 : cctx (CL n4)
  H3 : of_ml (CL n4) (Map n4) (SL n4)
  H4 : {SL n4 |- of (abs (M1 n4)) T}
  H5 : vars_of_sctx (SL n4) (Vs n4)
  H7 : {fvars (abs (M1 n4)) (Vs n4) (NFVs n4)}*
  H8 : {mapenv (NFVs n4) (Map n4) PE}*
  H9 : {mapvar (NFVs n4) n1 (NMap n4 n1)}*
  H10 : {cc (M1 n4 n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n4 n3)) (tl_cons n1 (NFVs n4))}*
  H11 : bvars nil
  H12 : subset (NFVs n4) (Vs n4)
  H13 : pruned_env nil (NFVs n4) (SL n4) (SL' n4)
  H14 : islist (NFVs n4)
  H15 : subset (NFVs n4) (NFVs n4)
  H17 : sctx' (SL' n4)
  H18 : reified_env (SL' n4) Ty
  H19 : of_ml (cof n1 Ty :: nil) (NMap n4 n1) (SL' n4)
  H20 : {SL' n4, [of n4 T1] |- of (abs (M1 n4)) T}
  H21 : member (of n4 T1) (SL' n4)
  ============================
   {CL n4 |- cof (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) T}

Subgoal 4 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H20.</b>
</pre>
<a name="557"></a>
<pre>
Subgoal 4:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (app M1 M2) T}
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H4.</b>
</pre>
<a name="558"></a>
<pre>
Subgoal 4.1:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  H9 : {SL |- of M1 (arr T1 T)}
  H10 : {SL |- of M2 T1}
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 4.2 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply IH to H1 H2 H3 H9 H5 H7.</b>
</pre>
<a name="559"></a>
<pre>
Subgoal 4.1:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  H9 : {SL |- of M1 (arr T1 T)}
  H10 : {SL |- of M2 T1}
  H11 : {CL |- cof CM1 (arr T1 T)}
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 4.2 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply IH to H1 H2 H3 H10 H5 H8.</b>
</pre>
<a name="560"></a>
<pre>
Subgoal 4.1:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  H9 : {SL |- of M1 (arr T1 T)}
  H10 : {SL |- of M2 T1}
  H11 : {CL |- cof CM1 (arr T1 T)}
  H12 : {CL |- cof CM2 T1}
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 4.2 is:
 {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>search.</b>
</pre>
<a name="561"></a>
<pre>
Subgoal 4.2:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, F
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  H9 : {SL, [F] |- of (app M1 M2) T}
  H10 : member F SL
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply sctx'_mem to H1 H10.</b>
</pre>
<a name="562"></a>
<pre>
Subgoal 4.2:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {cc M1 CM1 Map Vs}*
  H8 : {cc M2 CM2 Map Vs}*
  H9 : {SL, [of X T1] |- of (app M1 M2) T}
  H10 : member (of X T1) SL
  H11 : tname X
  ============================
   {CL |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H11.</b>
</pre>
<a name="563"></a>
<pre>
Subgoal 4.2:

  Variables: SL, CL, Map, M, N, T, Vs, CM2, M2, CM1, M1, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' (SL n1)
  H2 : cctx (CL n1)
  H3 : of_ml (CL n1) (Map n1) (SL n1)
  H5 : vars_of_sctx (SL n1) (Vs n1)
  H7 : {cc (M1 n1) CM1 (Map n1) (Vs n1)}*
  H8 : {cc (M2 n1) CM2 (Map n1) (Vs n1)}*
  H9 : {SL n1, [of n1 T1] |- of (app (M1 n1) (M2 n1)) T}
  H10 : member (of n1 T1) (SL n1)
  ============================
   {CL n1 |- cof (cunpair CM1 (f\env\capp f (cross CM2 env))) T}

Subgoal 5 is:
 {CL |- cof (ccst C) T}

type_pres < <b>case H9.</b>
</pre>
<a name="564"></a>
<pre>
Subgoal 5:

  Variables: SL, CL, Map, M, N, T, Vs, C
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H4 : {SL |- of (cst C) T}
  H5 : vars_of_sctx SL Vs
  ============================
   {CL |- cof (ccst C) T}

type_pres < <b>case H4.</b>
</pre>
<a name="565"></a>
<pre>
Subgoal 5.1:

  Variables: SL, CL, Map, M, N, T, Vs, C
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL |- of_const C T}
  ============================
   {CL |- cof (ccst C) T}

Subgoal 5.2 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply of_const_sctx' to H1 H7.</b>
</pre>
<a name="566"></a>
<pre>
Subgoal 5.1:

  Variables: SL, CL, Map, M, N, T, Vs, C
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL |- of_const C T}
  H8 : {of_const C T}
  ============================
   {CL |- cof (ccst C) T}

Subgoal 5.2 is:
 {CL |- cof (ccst C) T}

type_pres < <b>apply presv_const_typ to H8.</b>
</pre>
<a name="567"></a>
<pre>
Subgoal 5.1:

  Variables: SL, CL, Map, M, N, T, Vs, C
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL |- of_const C T}
  H8 : {of_const C T}
  H9 : {cof_const C T}
  ============================
   {CL |- cof (ccst C) T}

Subgoal 5.2 is:
 {CL |- cof (ccst C) T}

type_pres < <b>search.</b>
</pre>
<a name="568"></a>
<pre>
Subgoal 5.2:

  Variables: SL, CL, Map, M, N, T, Vs, C, F
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL, [F] |- of (cst C) T}
  H8 : member F SL
  ============================
   {CL |- cof (ccst C) T}

type_pres < <b>apply sctx'_mem to H1 H8.</b>
</pre>
<a name="569"></a>
<pre>
Subgoal 5.2:

  Variables: SL, CL, Map, M, N, T, Vs, C, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H7 : {SL, [of X T1] |- of (cst C) T}
  H8 : member (of X T1) SL
  H9 : tname X
  ============================
   {CL |- cof (ccst C) T}

type_pres < <b>case H7.</b>
</pre>
<a name="570"></a>
<pre>
Subgoal 5.2:

  Variables: SL, CL, Map, M, N, T, Vs, C, F, X, T1
  IH : forall SL CL Map M N T Vs, sctx' SL -> cctx CL -> of_ml CL Map SL ->
         {SL |- of M T} -> vars_of_sctx SL Vs -> {cc M N Map Vs}* ->
         {CL |- cof N T}
  H1 : sctx' SL
  H2 : cctx CL
  H3 : of_ml CL Map SL
  H5 : vars_of_sctx SL Vs
  H8 : member (of (cst C) T) SL
  H9 : tname (cst C)
  ============================
   {CL |- cof (ccst C) T}

type_pres < <b>case H9.</b>
Proof completed.
</pre>
<a name="571"></a>
<pre class="code">
Abella < <b>Theorem type_pres' : 
forall M N T, {of M T} -> {cc' M N} -> {cof N T}.</b>
</pre>
<a name="572"></a>
<pre>


  ============================
   forall M N T, {of M T} -> {cc' M N} -> {cof N T}

type_pres' < <b>intros.</b>
</pre>
<a name="573"></a>
<pre>

  Variables: M, N, T
  H1 : {of M T}
  H2 : {cc' M N}
  ============================
   {cof N T}

type_pres' < <b>case H2.</b>
</pre>
<a name="574"></a>
<pre>

  Variables: M, N, T
  H1 : {of M T}
  H3 : {cc M N ml_nil tl_nil}
  ============================
   {cof N T}

type_pres' < <b>apply type_pres to _ _ _ H1 _ H3.</b>
</pre>
<a name="575"></a>
<pre>

  Variables: M, N, T
  H1 : {of M T}
  H3 : {cc M N ml_nil tl_nil}
  H4 : {cof N T}
  ============================
   {cof N T}

type_pres' < <b>search.</b>
Proof completed.
</pre>
<a name="576"></a>
<pre class="code">
Abella < <b>Define name_map : map_list -> prop by 
name_map ml_nil;
name_map (ml_cons (map X V) ML) := name_map ML /\ tname X.</b>
</pre>
<a name="577"></a>
<pre class="code">
Abella < <b>Theorem name_map_nominal : 
forall Map X V, name_map Map -> {ml_member (map X V) Map} -> tname X.</b>
</pre>
<a name="578"></a>
<pre>


  ============================
   forall Map X V, name_map Map -> {ml_member (map X V) Map} -> tname X

name_map_nominal < <b>induction on 1.</b>
</pre>
<a name="579"></a>
<pre>


  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  ============================
   forall Map X V, name_map Map @ -> {ml_member (map X V) Map} -> tname X

name_map_nominal < <b>intros.</b>
</pre>
<a name="580"></a>
<pre>

  Variables: Map, X, V
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H1 : name_map Map @
  H2 : {ml_member (map X V) Map}
  ============================
   tname X

name_map_nominal < <b>case H1.</b>
</pre>
<a name="581"></a>
<pre>
Subgoal 1:

  Variables: Map, X, V
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H2 : {ml_member (map X V) ml_nil}
  ============================
   tname X

Subgoal 2 is:
 tname X

name_map_nominal < <b>case H2.</b>
</pre>
<a name="582"></a>
<pre>
Subgoal 2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H2 : {ml_member (map X V) (ml_cons (map X1 V1) ML)}
  H3 : name_map ML *
  H4 : tname X1
  ============================
   tname X

name_map_nominal < <b>case H2.</b>
</pre>
<a name="583"></a>
<pre>
Subgoal 2.1:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

name_map_nominal < <b>search.</b>
</pre>
<a name="584"></a>
<pre>
Subgoal 2.2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  H5 : {ml_member (map X V) ML}
  ============================
   tname X

name_map_nominal < <b>apply IH to H3 H5.</b>
</pre>
<a name="585"></a>
<pre>
Subgoal 2.2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  H5 : {ml_member (map X V) ML}
  H6 : tname X
  ============================
   tname X

name_map_nominal < <b>search.</b>
Proof completed.
</pre>
<a name="586"></a>
<pre class="code">
Abella < <b>Theorem clos_closed : 
forall SL Map R F E T1 T2 Vs, sctx' SL -> name_map Map ->
  {SL |- of (abs R) (arr T1 T2)} -> vars_of_sctx SL Vs ->
  {cc (abs R) (cpair F E) Map Vs} -> (exists TE,
  {cof F (code (product T1 TE) T2)}).</b>
</pre>
<a name="587"></a>
<pre>


  ============================
   forall SL Map R F E T1 T2 Vs, sctx' SL -> name_map Map ->
     {SL |- of (abs R) (arr T1 T2)} -> vars_of_sctx SL Vs ->
     {cc (abs R) (cpair F E) Map Vs} -> (exists TE,
     {cof F (code (product T1 TE) T2)})

clos_closed < <b>intros.</b>
</pre>
<a name="588"></a>
<pre>

  Variables: SL, Map, R, F, E, T1, T2, Vs
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H5 : {cc (abs R) (cpair F E) Map Vs}
  ============================
   exists TE, {cof F (code (product T1 TE) T2)}

clos_closed < <b>case H5.</b>
</pre>
<a name="589"></a>
<pre>
Subgoal 1:

  Variables: SL, Map, R, F, E, T1, T2, Vs
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {ml_member (map (abs R) (cpair F E)) Map}
  ============================
   exists TE, {cof F (code (product T1 TE) T2)}

Subgoal 2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply name_map_nominal to H2 H6.</b>
</pre>
<a name="590"></a>
<pre>
Subgoal 1:

  Variables: SL, Map, R, F, E, T1, T2, Vs
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {ml_member (map (abs R) (cpair F E)) Map}
  H7 : tname (abs R)
  ============================
   exists TE, {cof F (code (product T1 TE) T2)}

Subgoal 2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>case H7.</b>
</pre>
<a name="591"></a>
<pre>
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>assert bvars nil.</b>
</pre>
<a name="592"></a>
<pre>
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply fvars_subset to H10 H6.</b>
</pre>
<a name="593"></a>
<pre>
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply pruned_env_exists to H1 H4 H11.</b>
</pre>
<a name="594"></a>
<pre>
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL'
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply fvars_islist to H10 H6.</b>
</pre>
<a name="595"></a>
<pre>
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL'
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply subset_refl to H13.</b>
</pre>
<a name="596"></a>
<pre>
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL'
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply pruned_env_typing to H1 H3 H4 H10 H6 H14 H12.</b>
</pre>
<a name="597"></a>
<pre>
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL'
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H15 : {SL' |- of (abs R) (arr T1 T2)}
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply pruned_env_sctx to H1 H10 H12.</b>
</pre>
<a name="598"></a>
<pre>
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL'
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H15 : {SL' |- of (abs R) (arr T1 T2)}
  H16 : sctx' SL'
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply reified_env_exists to H16.</b>
</pre>
<a name="599"></a>
<pre>
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H15 : {SL' |- of (abs R) (arr T1 T2)}
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply pruned_env_reification_type to H12 H16 H8 H17.</b>
</pre>
<a name="600"></a>
<pre>
Subgoal 2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H15 : {SL' |- of (abs R) (arr T1 T2)}
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>case H15.</b>
</pre>
<a name="601"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>assert tname n1.</b>
</pre>
<a name="602"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply of_ml_extend_map to H18 H20 with X = n1, Y = n2, T = T1.</b>
</pre>
<a name="603"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply pruned_env_vars to H12.</b>
</pre>
<a name="604"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H22 : vars_of_sctx SL' NFVs
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>assert vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs).</b>
</pre>
<a name="605"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H22 : vars_of_sctx SL' NFVs
  H23 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply sctx'_extend to H16 with T = T1.</b>
</pre>
<a name="606"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H22 : vars_of_sctx SL' NFVs
  H23 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H24 : sctx' (of n1 T1 :: SL')
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>assert cctx (cof n2 T1 :: cof n3 Ty :: nil).</b>
</pre>
<a name="607"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H22 : vars_of_sctx SL' NFVs
  H23 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H24 : sctx' (of n1 T1 :: SL')
  H25 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply type_pres to H24 H25 H21 H19 H23 H9.</b>
</pre>
<a name="608"></a>
<pre>
Subgoal 2.1:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', of n1 T1 |- of (R n1) T2}
  H20 : tname n1
  H21 : of_ml (cof n2 T1 :: cof n3 Ty :: nil) (ml_cons (map n1 n2) (NMap n3)) (of n1 T1 :: SL')
  H22 : vars_of_sctx SL' NFVs
  H23 : vars_of_sctx (of n1 T1 :: SL') (tl_cons n1 NFVs)
  H24 : sctx' (of n1 T1 :: SL')
  H25 : cctx (cof n2 T1 :: cof n3 Ty :: nil)
  H26 : {cof n3 Ty, cof n2 T1 |- cof (P n3 n2) T2}
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

Subgoal 2.2 is:
 exists TE,
   {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>search.</b>
</pre>
<a name="609"></a>
<pre>
Subgoal 2.2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty, F1
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', [F1] |- of (abs R) (arr T1 T2)}
  H20 : member F1 SL'
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>apply sctx'_mem to H16 H20.</b>
</pre>
<a name="610"></a>
<pre>
Subgoal 2.2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty, F1, X, T
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H19 : {SL', [of X T] |- of (abs R) (arr T1 T2)}
  H20 : member (of X T) SL'
  H21 : tname X
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>case H19.</b>
</pre>
<a name="611"></a>
<pre>
Subgoal 2.2:

  Variables: SL, Map, R, F, E, T1, T2, Vs, NFVs, NMap, P, SL', Ty, F1, X, T
  H1 : sctx' SL
  H2 : name_map Map
  H3 : {SL |- of (abs R) (arr T1 T2)}
  H4 : vars_of_sctx SL Vs
  H6 : {fvars (abs R) Vs NFVs}
  H7 : {mapenv NFVs Map E}
  H8 : {mapvar NFVs n1 (NMap n1)}
  H9 : {cc (R n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}
  H10 : bvars nil
  H11 : subset NFVs Vs
  H12 : pruned_env nil NFVs SL SL'
  H13 : islist NFVs
  H14 : subset NFVs NFVs
  H16 : sctx' SL'
  H17 : reified_env SL' Ty
  H18 : of_ml (cof n1 Ty :: nil) (NMap n1) SL'
  H20 : member (of (abs R) (arr T1 T2)) SL'
  H21 : tname (abs R)
  ============================
   exists TE,
     {cof (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) (code (product T1 TE) T2)}

clos_closed < <b>case H21.</b>
Proof completed.
</pre>
<a name="612"></a>
<pre class="code">
Abella < Goodbye.
</pre>
</div>

</body>
</html>
