Welcome to Abella 2.0.2-dev
Abella < Specification "cc".
Reading specification "cc"

Abella < Close nat, tm, tm_list, ctm, ctm_list, ty.

Abella < Theorem eq_ml_member : 
forall A B X, A = B -> {ml_member X A} -> {ml_member X B}.


  ============================
   forall A B X, A = B -> {ml_member X A} -> {ml_member X B}

eq_ml_member < intros.

  Variables: A, B, X
  H1 : A = B
  H2 : {ml_member X A}
  ============================
   {ml_member X B}

eq_ml_member < case H1.

  Variables: A, B, X
  H2 : {ml_member X B}
  ============================
   {ml_member X B}

eq_ml_member < search.
Proof completed.

Abella < Theorem eq_inst_eval : 
forall A B C V, nabla x, A x = B x -> {evalcc (B C) V} -> {evalcc (A C) V}.


  ============================
   forall A B C V, nabla x, A x = B x -> {evalcc (B C) V} -> {evalcc (A C) V}

eq_inst_eval < intros.

  Variables: A, B, C, V
  H1 : A n1 = B n1
  H2 : {evalcc (B C) V}
  ============================
   {evalcc (A C) V}

eq_inst_eval < case H1.

  Variables: A, B, C, V
  H2 : {evalcc (B C) V}
  ============================
   {evalcc (B C) V}

eq_inst_eval < search.
Proof completed.

Abella < Define tname : tm -> prop by 
nabla n, tname n.

Abella < Define ctname : ctm -> prop by 
nabla n, ctname n.

Abella < Define fresh_tm : tm -> tm -> prop by 
nabla x, fresh_tm x M.

Abella < Define fresh_tm_tm : tm -> (tm -> tm) -> prop by 
nabla x, fresh_tm_tm x M.

Abella < Define fresh_ctm_ctm : ctm -> (ctm -> ctm) -> prop by 
nabla x, fresh_ctm_ctm x M.

Abella < Define fresh_ctm_ml : ctm -> ctm -> (ctm -> map_list) -> prop by 
nabla x, fresh_ctm_ml x (M x) N.

Abella < Define fresh_smap_list : tm -> smap_list -> prop by 
fresh_smap_list M sml_nil;
nabla x, fresh_smap_list M (sml_cons (smap x V) (ML x)) := nabla x, fresh_smap_list M (ML x).

Abella < Define fresh_tmctx : tm -> olist -> prop by 
nabla x, fresh_tmctx x L.

Abella < Theorem member_prune_tm : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').


  ============================
   forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

member_prune_tm < induction on 1.


  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  ============================
   forall M L, nabla x, member (M x) L @ -> (exists M', M = y\M')

member_prune_tm < intros.

  Variables: M, L
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H1 : member (M n1) L @
  ============================
   exists M', M = y\M'

member_prune_tm < case H1.
Subgoal 1:

  Variables: M, L, L3, L2
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  ============================
   exists M', z1\L2 = y\M'

Subgoal 2 is:
 exists M', M = y\M'

member_prune_tm < search.
Subgoal 2:

  Variables: M, L, L3, L2
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H2 : member (M n1) L3 *
  ============================
   exists M', M = y\M'

member_prune_tm < apply IH to H2.
Subgoal 2:

  Variables: M, L, L3, L2, M'
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H2 : member M' L3 *
  ============================
   exists M'1, z1\M' = y\M'1

member_prune_tm < search.
Proof completed.

Abella < Theorem member_prune_ctm : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').


  ============================
   forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

member_prune_ctm < induction on 1.


  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  ============================
   forall M L, nabla x, member (M x) L @ -> (exists M', M = y\M')

member_prune_ctm < intros.

  Variables: M, L
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H1 : member (M n1) L @
  ============================
   exists M', M = y\M'

member_prune_ctm < case H1.
Subgoal 1:

  Variables: M, L, L3, L2
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  ============================
   exists M', z1\L2 = y\M'

Subgoal 2 is:
 exists M', M = y\M'

member_prune_ctm < search.
Subgoal 2:

  Variables: M, L, L3, L2
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H2 : member (M n1) L3 *
  ============================
   exists M', M = y\M'

member_prune_ctm < apply IH to H2.
Subgoal 2:

  Variables: M, L, L3, L2, M'
  IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
  H2 : member M' L3 *
  ============================
   exists M'1, z1\M' = y\M'1

member_prune_ctm < search.
Proof completed.

Abella < Theorem mem_of_absurd : 
forall T L, nabla x, member (of x T) L -> false.


  ============================
   forall T L, nabla x, member (of x T) L -> false

mem_of_absurd < induction on 1.


  IH : forall T L, nabla x, member (of x T) L * -> false
  ============================
   forall T L, nabla x, member (of x T) L @ -> false

mem_of_absurd < intros.

  Variables: T, L
  IH : forall T L, nabla x, member (of x T) L * -> false
  H1 : member (of n1 T) L @
  ============================
   false

mem_of_absurd < case H1.

  Variables: T, L, L3, L2
  IH : forall T L, nabla x, member (of x T) L * -> false
  H2 : member (of n1 T) L3 *
  ============================
   false

mem_of_absurd < apply IH to H2.
Proof completed.

Abella < Theorem mem_of_absurd' : 
forall T L, nabla x, member (cof x T) L -> false.


  ============================
   forall T L, nabla x, member (cof x T) L -> false

mem_of_absurd' < induction on 1.


  IH : forall T L, nabla x, member (cof x T) L * -> false
  ============================
   forall T L, nabla x, member (cof x T) L @ -> false

mem_of_absurd' < intros.

  Variables: T, L
  IH : forall T L, nabla x, member (cof x T) L * -> false
  H1 : member (cof n1 T) L @
  ============================
   false

mem_of_absurd' < case H1.

  Variables: T, L, L3, L2
  IH : forall T L, nabla x, member (cof x T) L * -> false
  H2 : member (cof n1 T) L3 *
  ============================
   false

mem_of_absurd' < apply IH to H2.
Proof completed.

Abella < Theorem sml_mem_absurd : 
forall V ML, nabla x, {sml_member (smap x (V x)) ML} -> false.


  ============================
   forall V ML, nabla x, {sml_member (smap x (V x)) ML} -> false

sml_mem_absurd < induction on 1.


  IH : forall V ML, nabla x, {sml_member (smap x (V x)) ML}* -> false
  ============================
   forall V ML, nabla x, {sml_member (smap x (V x)) ML}@ -> false

sml_mem_absurd < intros.

  Variables: V, ML
  IH : forall V ML, nabla x, {sml_member (smap x (V x)) ML}* -> false
  H1 : {sml_member (smap n1 (V n1)) ML}@
  ============================
   false

sml_mem_absurd < case H1.

  Variables: V, ML, ML2, ML1
  IH : forall V ML, nabla x, {sml_member (smap x (V x)) ML}* -> false
  H2 : {sml_member (smap n1 (V n1)) ML2}*
  ============================
   false

sml_mem_absurd < apply IH to H2.
Proof completed.

Abella < Theorem cml_mem_absurd : 
forall V ML, nabla x, {cml_member (cmap x (V x)) ML} -> false.


  ============================
   forall V ML, nabla x, {cml_member (cmap x (V x)) ML} -> false

cml_mem_absurd < induction on 1.


  IH : forall V ML, nabla x, {cml_member (cmap x (V x)) ML}* -> false
  ============================
   forall V ML, nabla x, {cml_member (cmap x (V x)) ML}@ -> false

cml_mem_absurd < intros.

  Variables: V, ML
  IH : forall V ML, nabla x, {cml_member (cmap x (V x)) ML}* -> false
  H1 : {cml_member (cmap n1 (V n1)) ML}@
  ============================
   false

cml_mem_absurd < case H1.

  Variables: V, ML, ML2, ML1
  IH : forall V ML, nabla x, {cml_member (cmap x (V x)) ML}* -> false
  H2 : {cml_member (cmap n1 (V n1)) ML2}*
  ============================
   false

cml_mem_absurd < apply IH to H2.
Proof completed.

Abella < Theorem ml_member_prune1 : 
forall E E' Map, nabla x, {ml_member (map (E x) E') Map} -> (exists E1,
  E = y\E1).


  ============================
   forall E E' Map, nabla x, {ml_member (map (E x) E') Map} -> (exists E1,
     E = y\E1)

ml_member_prune1 < induction on 1.


  IH : forall E E' Map, nabla x, {ml_member (map (E x) E') Map}* ->
         (exists E1, E = y\E1)
  ============================
   forall E E' Map, nabla x, {ml_member (map (E x) E') Map}@ -> (exists E1,
     E = y\E1)

ml_member_prune1 < intros.

  Variables: E, E', Map
  IH : forall E E' Map, nabla x, {ml_member (map (E x) E') Map}* ->
         (exists E1, E = y\E1)
  H1 : {ml_member (map (E n1) E') Map}@
  ============================
   exists E1, E = y\E1

ml_member_prune1 < case H1.
Subgoal 1:

  Variables: E, E', Map, Map2, Map1
  IH : forall E E' Map, nabla x, {ml_member (map (E x) E') Map}* ->
         (exists E1, E = y\E1)
  ============================
   exists E1, z1\Map1 = y\E1

Subgoal 2 is:
 exists E1, E = y\E1

ml_member_prune1 < search.
Subgoal 2:

  Variables: E, E', Map, Map2, Map1
  IH : forall E E' Map, nabla x, {ml_member (map (E x) E') Map}* ->
         (exists E1, E = y\E1)
  H2 : {ml_member (map (E n1) E') Map2}*
  ============================
   exists E1, E = y\E1

ml_member_prune1 < apply IH to H2.
Subgoal 2:

  Variables: E, E', Map, Map2, Map1, E1
  IH : forall E E' Map, nabla x, {ml_member (map (E x) E') Map}* ->
         (exists E1, E = y\E1)
  H2 : {ml_member (map E1 E') Map2}*
  ============================
   exists E2, z1\E1 = y\E2

ml_member_prune1 < search.
Proof completed.

Abella < Theorem ml_member_prune2 : 
forall E E' Map, nabla x, {ml_member (map E (E' x)) Map} -> (exists E1',
  E' = y\E1').


  ============================
   forall E E' Map, nabla x, {ml_member (map E (E' x)) Map} -> (exists E1',
     E' = y\E1')

ml_member_prune2 < induction on 1.


  IH : forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}* ->
         (exists E1', E' = y\E1')
  ============================
   forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}@ -> (exists E1',
     E' = y\E1')

ml_member_prune2 < intros.

  Variables: E, E', Map
  IH : forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}* ->
         (exists E1', E' = y\E1')
  H1 : {ml_member (map E (E' n1)) Map}@
  ============================
   exists E1', E' = y\E1'

ml_member_prune2 < case H1.
Subgoal 1:

  Variables: E, E', Map, Map2, Map1
  IH : forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}* ->
         (exists E1', E' = y\E1')
  ============================
   exists E1', z1\Map1 = y\E1'

Subgoal 2 is:
 exists E1', E' = y\E1'

ml_member_prune2 < search.
Subgoal 2:

  Variables: E, E', Map, Map2, Map1
  IH : forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}* ->
         (exists E1', E' = y\E1')
  H2 : {ml_member (map E (E' n1)) Map2}*
  ============================
   exists E1', E' = y\E1'

ml_member_prune2 < apply IH to H2.
Subgoal 2:

  Variables: E, E', Map, Map2, Map1, E1'
  IH : forall E E' Map, nabla x, {ml_member (map E (E' x)) Map}* ->
         (exists E1', E' = y\E1')
  H2 : {ml_member (map E E1') Map2}*
  ============================
   exists E1'1, z1\E1' = y\E1'1

ml_member_prune2 < search.
Proof completed.

Abella < Theorem eq_map_list_inv : 
forall A B, nabla x, A x = B x -> A = B.


  ============================
   forall A B, nabla x, A x = B x -> A = B

eq_map_list_inv < intros.

  Variables: A, B
  H1 : A n1 = B n1
  ============================
   A = B

eq_map_list_inv < case H1.

  Variables: A, B
  ============================
   z1\B z1 = B

eq_map_list_inv < search.
Proof completed.

Abella < Theorem eq_map_list_rewrite : 
forall A B X, A = B ->
  z1\z2\ml_cons (map X (fst z2)) (A z1 z2) = y\z2\ml_cons (map X (fst z2)) (B y z2).


  ============================
   forall A B X, A = B ->
     z1\z2\ml_cons (map X (fst z2)) (A z1 z2) = y\z2\ml_cons (map X (fst z2)) (B y z2)

eq_map_list_rewrite < intros.

  Variables: A, B, X
  H1 : A = B
  ============================
   z1\z2\ml_cons (map X (fst z2)) (A z1 z2) = y\z2\ml_cons (map X (fst z2)) (B y z2)

eq_map_list_rewrite < case H1.

  Variables: A, B, X
  ============================
   z1\z2\ml_cons (map X (fst z2)) (B z1 z2) = y\z2\ml_cons (map X (fst z2)) (B y z2)

eq_map_list_rewrite < search.
Proof completed.

Abella < Theorem mapvar_prune : 
forall FVs ML, nabla x, {mapvar FVs (ML x)} -> (exists ML', ML = y\ML').


  ============================
   forall FVs ML, nabla x, {mapvar FVs (ML x)} -> (exists ML', ML = y\ML')

mapvar_prune < induction on 1.


  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  ============================
   forall FVs ML, nabla x, {mapvar FVs (ML x)}@ -> (exists ML', ML = y\ML')

mapvar_prune < intros.

  Variables: FVs, ML
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H1 : {mapvar FVs (ML n1)}@
  ============================
   exists ML', ML = y\ML'

mapvar_prune < case H1.
Subgoal 1:

  Variables: FVs, ML
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  ============================
   exists ML', z1\z2\ml_nil = y\ML'

Subgoal 2 is:
 exists ML', ML = y\ML'

mapvar_prune < search.
Subgoal 2:

  Variables: FVs, ML, Map, L, X
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H2 : xenv\ml_cons (map X (fst xenv)) (Map n1 (rst xenv)) = xenv\ML n1 xenv
  H3 : {mapvar L (Map n1)}*
  ============================
   exists ML', ML = y\ML'

mapvar_prune < apply IH to H3.
Subgoal 2:

  Variables: FVs, ML, Map, L, X, ML'
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H2 : xenv\ml_cons (map X (fst xenv)) (ML' (rst xenv)) = xenv\ML n1 xenv
  H3 : {mapvar L ML'}*
  ============================
   exists ML', ML = y\ML'

mapvar_prune < case H2.
Subgoal 2:

  Variables: FVs, ML, Map, L, X, ML', ML2
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H3 : {mapvar L ML'}*
  H4 : xenv\ML2 n1 xenv = xenv\ML' (rst xenv)
  ============================
   exists ML', z1\z2\ml_cons (map X (fst z2)) (ML2 z1 z2) = y\ML'

mapvar_prune < exists z2\ml_cons (map X (fst z2)) (ML' (rst z2)).
Subgoal 2:

  Variables: FVs, ML, Map, L, X, ML', ML2
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H3 : {mapvar L ML'}*
  H4 : xenv\ML2 n1 xenv = xenv\ML' (rst xenv)
  ============================
   z1\z2\ml_cons (map X (fst z2)) (ML2 z1 z2) = y\z2\ml_cons (map X (fst z2)) (ML' (rst z2))

mapvar_prune < apply eq_map_list_inv to H4.
Subgoal 2:

  Variables: FVs, ML, Map, L, X, ML', ML2
  IH : forall FVs ML, nabla x, {mapvar FVs (ML x)}* -> (exists ML',
         ML = y\ML')
  H3 : {mapvar L ML'}*
  H4 : xenv\ML2 n1 xenv = xenv\ML' (rst xenv)
  H5 : z2\z3\ML2 z2 z3 = z2\z3\ML' (rst z3)
  ============================
   z1\z2\ml_cons (map X (fst z2)) (ML2 z1 z2) = y\z2\ml_cons (map X (fst z2)) (ML' (rst z2))

mapvar_prune < backchain eq_map_list_rewrite.
Proof completed.

Abella < Define tmctx : olist -> prop by 
tmctx nil;
nabla x, tmctx (tm x :: L x) := nabla x, tmctx (L x).

Abella < Define ctmctx : olist -> prop by 
ctmctx nil;
nabla x, ctmctx (ctm x :: L x) := nabla x, ctmctx (L x).

Abella < Theorem tmctx_mem : 
forall L E, tmctx L -> member E L -> (exists X, E = tm X /\ tname X).


  ============================
   forall L E, tmctx L -> member E L -> (exists X, E = tm X /\ tname X)

tmctx_mem < induction on 1.


  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  ============================
   forall L E, tmctx L @ -> member E L -> (exists X, E = tm X /\ tname X)

tmctx_mem < intros.

  Variables: L, E
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H1 : tmctx L @
  H2 : member E L
  ============================
   exists X, E = tm X /\ tname X

tmctx_mem < case H1.
Subgoal 1:

  Variables: L, E
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H2 : member E nil
  ============================
   exists X, E = tm X /\ tname X

Subgoal 2 is:
 exists X, E n1 = tm X /\ tname X

tmctx_mem < case H2.
Subgoal 2:

  Variables: L, E, L1
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H2 : member (E n1) (tm n1 :: L1 n1)
  H3 : tmctx (L1 n1) *
  ============================
   exists X, E n1 = tm X /\ tname X

tmctx_mem < case H2.
Subgoal 2.1:

  Variables: L, E, L1
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H3 : tmctx (L1 n1) *
  ============================
   exists X, tm n1 = tm X /\ tname X

Subgoal 2.2 is:
 exists X, E n1 = tm X /\ tname X

tmctx_mem < search.
Subgoal 2.2:

  Variables: L, E, L1
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H3 : tmctx (L1 n1) *
  H4 : member (E n1) (L1 n1)
  ============================
   exists X, E n1 = tm X /\ tname X

tmctx_mem < apply IH to H3 H4.
Subgoal 2.2:

  Variables: L, E, L1, X
  IH : forall L E, tmctx L * -> member E L -> (exists X, E = tm X /\ tname X)
  H3 : tmctx (L1 n1) *
  H4 : member (tm (X n1)) (L1 n1)
  H5 : tname (X n1)
  ============================
   exists X1, tm (X n1) = tm X1 /\ tname X1

tmctx_mem < search.
Proof completed.

Abella < Theorem ctmctx_mem : 
forall L E, ctmctx L -> member E L -> (exists X, E = ctm X /\ ctname X).


  ============================
   forall L E, ctmctx L -> member E L -> (exists X, E = ctm X /\ ctname X)

ctmctx_mem < induction on 1.


  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  ============================
   forall L E, ctmctx L @ -> member E L -> (exists X, E = ctm X /\ ctname X)

ctmctx_mem < intros.

  Variables: L, E
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H1 : ctmctx L @
  H2 : member E L
  ============================
   exists X, E = ctm X /\ ctname X

ctmctx_mem < case H1.
Subgoal 1:

  Variables: L, E
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H2 : member E nil
  ============================
   exists X, E = ctm X /\ ctname X

Subgoal 2 is:
 exists X, E n1 = ctm X /\ ctname X

ctmctx_mem < case H2.
Subgoal 2:

  Variables: L, E, L1
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H2 : member (E n1) (ctm n1 :: L1 n1)
  H3 : ctmctx (L1 n1) *
  ============================
   exists X, E n1 = ctm X /\ ctname X

ctmctx_mem < case H2.
Subgoal 2.1:

  Variables: L, E, L1
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H3 : ctmctx (L1 n1) *
  ============================
   exists X, ctm n1 = ctm X /\ ctname X

Subgoal 2.2 is:
 exists X, E n1 = ctm X /\ ctname X

ctmctx_mem < search.
Subgoal 2.2:

  Variables: L, E, L1
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H3 : ctmctx (L1 n1) *
  H4 : member (E n1) (L1 n1)
  ============================
   exists X, E n1 = ctm X /\ ctname X

ctmctx_mem < apply IH to H3 H4.
Subgoal 2.2:

  Variables: L, E, L1, X
  IH : forall L E, ctmctx L * -> member E L -> (exists X, E = ctm X /\
         ctname X)
  H3 : ctmctx (L1 n1) *
  H4 : member (ctm (X n1)) (L1 n1)
  H5 : ctname (X n1)
  ============================
   exists X1, ctm (X n1) = ctm X1 /\ ctname X1

ctmctx_mem < search.
Proof completed.

Abella < Theorem closed_tm_prune_aux : 
forall M L, nabla x, tmctx L -> {L |- tm (M x)} -> (exists M', M = y\M').


  ============================
   forall M L, nabla x, tmctx L -> {L |- tm (M x)} -> (exists M', M = y\M')

closed_tm_prune_aux < induction on 2.


  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  ============================
   forall M L, nabla x, tmctx L -> {L |- tm (M x)}@ -> (exists M', M = y\M')

closed_tm_prune_aux < intros.

  Variables: M, L
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H2 : {L |- tm (M n1)}@
  ============================
   exists M', M = y\M'

closed_tm_prune_aux < case H2.
Subgoal 1:

  Variables: M, L, N
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  ============================
   exists M', z1\lnat N = y\M'

Subgoal 2 is:
 exists M', z1\app (M1 z1) (N z1) = y\M'

Subgoal 3 is:
 exists M', z1\abs (R z1) = y\M'

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < search.
Subgoal 2:

  Variables: M, L, N, M1
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L |- tm (M1 n1)}*
  H4 : {L |- tm (N n1)}*
  ============================
   exists M', z1\app (M1 z1) (N z1) = y\M'

Subgoal 3 is:
 exists M', z1\abs (R z1) = y\M'

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < apply IH to H1 H3.
Subgoal 2:

  Variables: M, L, N, M1, M'
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L |- tm M'}*
  H4 : {L |- tm (N n1)}*
  ============================
   exists M'1, z1\app M' (N z1) = y\M'1

Subgoal 3 is:
 exists M', z1\abs (R z1) = y\M'

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < apply IH to H1 H4.
Subgoal 2:

  Variables: M, L, N, M1, M', M'1
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L |- tm M'}*
  H4 : {L |- tm M'1}*
  ============================
   exists M'2, z1\app M' M'1 = y\M'2

Subgoal 3 is:
 exists M', z1\abs (R z1) = y\M'

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < search.
Subgoal 3:

  Variables: M, L, R
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L, tm n2 |- tm (R n1 n2)}*
  ============================
   exists M', z1\abs (R z1) = y\M'

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < apply IH to _ H3.
Subgoal 3:

  Variables: M, L, R, M'
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L, tm n2 |- tm (M' n2)}*
  ============================
   exists M'1, z1\abs (z2\M' z2) = y\M'1

Subgoal 4 is:
 exists M', M = y\M'

closed_tm_prune_aux < search.
Subgoal 4:

  Variables: M, L, F
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L, [F n1] |- tm (M n1)}*
  H4 : member (F n1) L
  ============================
   exists M', M = y\M'

closed_tm_prune_aux < apply tmctx_mem to H1 H4.
Subgoal 4:

  Variables: M, L, F, X
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H3 : {L, [tm (X n1)] |- tm (M n1)}*
  H4 : member (tm (X n1)) L
  H5 : tname (X n1)
  ============================
   exists M', M = y\M'

closed_tm_prune_aux < case H3.
Subgoal 4:

  Variables: M, L, F, X
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H4 : member (tm (M n1)) L
  H5 : tname (M n1)
  ============================
   exists M', M = y\M'

closed_tm_prune_aux < apply member_prune_tm to H4.
Subgoal 4:

  Variables: M, L, F, X, M', M'1
  IH : forall M L, nabla x, tmctx L -> {L |- tm (M x)}* -> (exists M',
         M = y\M')
  H1 : tmctx L
  H4 : member (tm M'1) L
  H5 : tname M'1
  ============================
   exists M', z1\M'1 = y\M'

closed_tm_prune_aux < search.
Proof completed.

Abella < Theorem closed_tm_prune : 
forall M, nabla x, {tm (M x)} -> (exists M', M = y\M').


  ============================
   forall M, nabla x, {tm (M x)} -> (exists M', M = y\M')

closed_tm_prune < intros.

  Variables: M
  H1 : {tm (M n1)}
  ============================
   exists M', M = y\M'

closed_tm_prune < apply closed_tm_prune_aux to _ H1.

  Variables: M, M'
  H1 : {tm M'}
  ============================
   exists M'1, z1\M' = y\M'1

closed_tm_prune < search.
Proof completed.

Abella < Theorem closed_ctm_prune_aux : 
forall M L, nabla x, ctmctx L -> {L |- ctm (M x)} -> (exists M', M = y\M').


  ============================
   forall M L, nabla x, ctmctx L -> {L |- ctm (M x)} -> (exists M', M = y\M')

closed_ctm_prune_aux < induction on 2.


  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  ============================
   forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}@ -> (exists M',
     M = y\M')

closed_ctm_prune_aux < intros.

  Variables: M, L
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H2 : {L |- ctm (M n1)}@
  ============================
   exists M', M = y\M'

closed_ctm_prune_aux < case H2.
Subgoal 1:

  Variables: M, L
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  ============================
   exists M', z1\unit = y\M'

Subgoal 2 is:
 exists M', z1\clnat N = y\M'

Subgoal 3 is:
 exists M', z1\clet (M1 z1) (F z1) = y\M'

Subgoal 4 is:
 exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < search.
Subgoal 2:

  Variables: M, L, N
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  ============================
   exists M', z1\clnat N = y\M'

Subgoal 3 is:
 exists M', z1\clet (M1 z1) (F z1) = y\M'

Subgoal 4 is:
 exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < search.
Subgoal 3:

  Variables: M, L, F, M1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (M1 n1)}*
  H4 : {L, ctm n2 |- ctm (F n1 n2)}*
  ============================
   exists M', z1\clet (M1 z1) (F z1) = y\M'

Subgoal 4 is:
 exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to H1 H3.
Subgoal 3:

  Variables: M, L, F, M1, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L, ctm n2 |- ctm (F n1 n2)}*
  ============================
   exists M'1, z1\clet M' (F z1) = y\M'1

Subgoal 4 is:
 exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to _ H4.
Subgoal 3:

  Variables: M, L, F, M1, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L, ctm n2 |- ctm (M'1 n2)}*
  ============================
   exists M'2, z1\clet M' (z2\M'1 z2) = y\M'2

Subgoal 4 is:
 exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < search.
Subgoal 4:

  Variables: M, L, M1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (M1 n1)}*
  ============================
   exists M', z1\fst (M1 z1) = y\M'

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to H1 H3.
Subgoal 4:

  Variables: M, L, M1, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  ============================
   exists M'1, z1\fst M' = y\M'1

Subgoal 5 is:
 exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < search.
Subgoal 5:

  Variables: M, L, M1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (M1 n1)}*
  ============================
   exists M', z1\rst (M1 z1) = y\M'

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to H1 H3.
Subgoal 5:

  Variables: M, L, M1, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  ============================
   exists M'1, z1\rst M' = y\M'1

Subgoal 6 is:
 exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < search.
Subgoal 6:

  Variables: M, L, N, M1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (M1 n1)}*
  H4 : {L |- ctm (N n1)}*
  ============================
   exists M', z1\cross (M1 z1) (N z1) = y\M'

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to H1 H3.
Subgoal 6:

  Variables: M, L, N, M1, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm (N n1)}*
  ============================
   exists M'1, z1\cross M' (N z1) = y\M'1

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to H1 H4.
Subgoal 6:

  Variables: M, L, N, M1, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm M'1}*
  ============================
   exists M'2, z1\cross M' M'1 = y\M'2

Subgoal 7 is:
 exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < search.
Subgoal 7:

  Variables: M, L, N, M1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (M1 n1)}*
  H4 : {L |- ctm (N n1)}*
  ============================
   exists M', z1\capp (M1 z1) (N z1) = y\M'

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to H1 H3.
Subgoal 7:

  Variables: M, L, N, M1, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm (N n1)}*
  ============================
   exists M'1, z1\capp M' (N z1) = y\M'1

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to H1 H4.
Subgoal 7:

  Variables: M, L, N, M1, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm M'1}*
  ============================
   exists M'2, z1\capp M' M'1 = y\M'2

Subgoal 8 is:
 exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < search.
Subgoal 8:

  Variables: M, L, R
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L, ctm n2 |- ctm (R n1 n2)}*
  ============================
   exists M', z1\cabs (R z1) = y\M'

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to _ H3.
Subgoal 8:

  Variables: M, L, R, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L, ctm n2 |- ctm (M' n2)}*
  ============================
   exists M'1, z1\cabs (z2\M' z2) = y\M'1

Subgoal 9 is:
 exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < search.
Subgoal 9:

  Variables: M, L, PE, F
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (F n1)}*
  H4 : {L |- ctm (PE n1)}*
  ============================
   exists M', z1\cpair (F z1) (PE z1) = y\M'

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to H1 H3.
Subgoal 9:

  Variables: M, L, PE, F, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm (PE n1)}*
  ============================
   exists M'1, z1\cpair M' (PE z1) = y\M'1

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to H1 H4.
Subgoal 9:

  Variables: M, L, PE, F, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L |- ctm M'1}*
  ============================
   exists M'2, z1\cpair M' M'1 = y\M'2

Subgoal 10 is:
 exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < search.
Subgoal 10:

  Variables: M, L, F, P
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm (P n1)}*
  H4 : {L, ctm n2, ctm n3 |- ctm (F n1 n2 n3)}*
  ============================
   exists M', z1\cunpair (P z1) (F z1) = y\M'

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to H1 H3.
Subgoal 10:

  Variables: M, L, F, P, M'
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L, ctm n2, ctm n3 |- ctm (F n1 n2 n3)}*
  ============================
   exists M'1, z1\cunpair M' (F z1) = y\M'1

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < apply IH to _ H4.
Subgoal 10:

  Variables: M, L, F, P, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L |- ctm M'}*
  H4 : {L, ctm n2, ctm n3 |- ctm (M'1 n3 n2)}*
  ============================
   exists M'2, z1\cunpair M' (z2\z3\M'1 z3 z2) = y\M'2

Subgoal 11 is:
 exists M', M = y\M'

closed_ctm_prune_aux < search.
Subgoal 11:

  Variables: M, L, F
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L, [F n1] |- ctm (M n1)}*
  H4 : member (F n1) L
  ============================
   exists M', M = y\M'

closed_ctm_prune_aux < apply ctmctx_mem to H1 H4.
Subgoal 11:

  Variables: M, L, F, X
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H3 : {L, [ctm (X n1)] |- ctm (M n1)}*
  H4 : member (ctm (X n1)) L
  H5 : ctname (X n1)
  ============================
   exists M', M = y\M'

closed_ctm_prune_aux < case H3.
Subgoal 11:

  Variables: M, L, F, X
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H4 : member (ctm (M n1)) L
  H5 : ctname (M n1)
  ============================
   exists M', M = y\M'

closed_ctm_prune_aux < apply member_prune_ctm to H4.
Subgoal 11:

  Variables: M, L, F, X, M', M'1
  IH : forall M L, nabla x, ctmctx L -> {L |- ctm (M x)}* -> (exists M',
         M = y\M')
  H1 : ctmctx L
  H4 : member (ctm M'1) L
  H5 : ctname M'1
  ============================
   exists M', z1\M'1 = y\M'

closed_ctm_prune_aux < search.
Proof completed.

Abella < Theorem closed_ctm_prune : 
forall M, nabla x, {ctm (M x)} -> (exists M', M = y\M').


  ============================
   forall M, nabla x, {ctm (M x)} -> (exists M', M = y\M')

closed_ctm_prune < intros.

  Variables: M
  H1 : {ctm (M n1)}
  ============================
   exists M', M = y\M'

closed_ctm_prune < apply closed_ctm_prune_aux to _ H1.

  Variables: M, M'
  H1 : {ctm M'}
  ============================
   exists M'1, z1\M' = y\M'1

closed_ctm_prune < search.
Proof completed.

Abella < Define tmctx_rst : o -> olist -> olist -> prop by 
nabla x, tmctx_rst (tm x) nil nil;
nabla x, tmctx_rst (tm x) (tm x :: L x) L' := nabla x, tmctx_rst (tm x) (L x) L';
nabla x, tmctx_rst (tm x) (tm Y :: L x) (tm Y :: L') := nabla x, tmctx_rst (tm x) (L x) L'.

Abella < Theorem tmctx_rst_mem_inv : 
forall X L L' E, tmctx_rst X L L' -> member E L' -> member E L.


  ============================
   forall X L L' E, tmctx_rst X L L' -> member E L' -> member E L

tmctx_rst_mem_inv < induction on 1.


  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  ============================
   forall X L L' E, tmctx_rst X L L' @ -> member E L' -> member E L

tmctx_rst_mem_inv < intros.

  Variables: X, L, L', E
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H1 : tmctx_rst X L L' @
  H2 : member E L'
  ============================
   member E L

tmctx_rst_mem_inv < case H1.
Subgoal 1:

  Variables: X, L, L', E
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H2 : member (E n1) nil
  ============================
   member (E n1) nil

Subgoal 2 is:
 member (E n1) (tm n1 :: L1 n1)

Subgoal 3 is:
 member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < search.
Subgoal 2:

  Variables: X, L, L', E, L'1, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H2 : member (E n1) L'1
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  ============================
   member (E n1) (tm n1 :: L1 n1)

Subgoal 3 is:
 member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < apply IH to H3 H2.
Subgoal 2:

  Variables: X, L, L', E, L'1, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H2 : member (E n1) L'1
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  H4 : member (E n1) (L1 n1)
  ============================
   member (E n1) (tm n1 :: L1 n1)

Subgoal 3 is:
 member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < search.
Subgoal 3:

  Variables: X, L, L', E, L'1, Y, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H2 : member (E n1) (tm Y :: L'1)
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  ============================
   member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < case H2.
Subgoal 3.1:

  Variables: X, L, L', E, L'1, Y, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  ============================
   member (tm Y) (tm Y :: L1 n1)

Subgoal 3.2 is:
 member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < search.
Subgoal 3.2:

  Variables: X, L, L', E, L'1, Y, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  H4 : member (E n1) L'1
  ============================
   member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < apply IH to H3 H4.
Subgoal 3.2:

  Variables: X, L, L', E, L'1, Y, L1
  IH : forall X L L' E, tmctx_rst X L L' * -> member E L' -> member E L
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  H4 : member (E n1) L'1
  H5 : member (E n1) (L1 n1)
  ============================
   member (E n1) (tm Y :: L1 n1)

tmctx_rst_mem_inv < search.
Proof completed.

Abella < Theorem tmctx_rst_exists : 
forall L, nabla x, tmctx (L x) -> (exists L', tmctx_rst (tm x) (L x) L' /\
  fresh_tmctx x L').


  ============================
   forall L, nabla x, tmctx (L x) -> (exists L', tmctx_rst (tm x) (L x) L' /\
     fresh_tmctx x L')

tmctx_rst_exists < induction on 1.


  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  ============================
   forall L, nabla x, tmctx (L x) @ -> (exists L',
     tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')

tmctx_rst_exists < intros.

  Variables: L
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H1 : tmctx (L n1) @
  ============================
   exists L', tmctx_rst (tm n1) (L n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < case H1.
Subgoal 1:

  Variables: L
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  ============================
   exists L', tmctx_rst (tm n1) nil L' /\ fresh_tmctx n1 L'

Subgoal 2 is:
 exists L', tmctx_rst (tm n1) (tm n2 :: L1 n1 n2) L' /\ fresh_tmctx n1 L'

Subgoal 3 is:
 exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < search.
Subgoal 2:

  Variables: L, L1
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1 n2) *
  ============================
   exists L', tmctx_rst (tm n1) (tm n2 :: L1 n1 n2) L' /\ fresh_tmctx n1 L'

Subgoal 3 is:
 exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < apply IH to H2.
Subgoal 2:

  Variables: L, L1, L'
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1 n2) *
  H3 : tmctx_rst (tm n1) (L1 n1 n2) (L' n2 n1)
  H4 : fresh_tmctx n1 (L' n2 n1)
  ============================
   exists L', tmctx_rst (tm n1) (tm n2 :: L1 n1 n2) L' /\ fresh_tmctx n1 L'

Subgoal 3 is:
 exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < case H4.
Subgoal 2:

  Variables: L, L1, L', L3
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1 n2) *
  H3 : tmctx_rst (tm n1) (L1 n1 n2) (L3 n2)
  ============================
   exists L', tmctx_rst (tm n1) (tm n2 :: L1 n1 n2) L' /\ fresh_tmctx n1 L'

Subgoal 3 is:
 exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < search.
Subgoal 3:

  Variables: L, L1
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1) *
  ============================
   exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < apply IH to H2.
Subgoal 3:

  Variables: L, L1, L'
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1) *
  H3 : tmctx_rst (tm n1) (L1 n1) (L' n1)
  H4 : fresh_tmctx n1 (L' n1)
  ============================
   exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < case H4.
Subgoal 3:

  Variables: L, L1, L', L2
  IH : forall L, nabla x, tmctx (L x) * -> (exists L',
         tmctx_rst (tm x) (L x) L' /\ fresh_tmctx x L')
  H2 : tmctx (L1 n1) *
  H3 : tmctx_rst (tm n1) (L1 n1) L2
  ============================
   exists L', tmctx_rst (tm n1) (tm n1 :: L1 n1) L' /\ fresh_tmctx n1 L'

tmctx_rst_exists < search.
Proof completed.

Abella < Theorem tmctx_rst_pres : 
forall L L', nabla x, tmctx (L x) -> tmctx_rst (tm x) (L x) L' -> tmctx L'.


  ============================
   forall L L', nabla x, tmctx (L x) -> tmctx_rst (tm x) (L x) L' -> tmctx L'

tmctx_rst_pres < induction on 1.


  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  ============================
   forall L L', nabla x, tmctx (L x) @ -> tmctx_rst (tm x) (L x) L' ->
     tmctx L'

tmctx_rst_pres < intros.

  Variables: L, L'
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H1 : tmctx (L n1) @
  H2 : tmctx_rst (tm n1) (L n1) L'
  ============================
   tmctx L'

tmctx_rst_pres < case H1.
Subgoal 1:

  Variables: L, L'
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H2 : tmctx_rst (tm n1) nil L'
  ============================
   tmctx L'

Subgoal 2 is:
 tmctx (L' n2)

Subgoal 3 is:
 tmctx L'

tmctx_rst_pres < case H2.
Subgoal 1:

  Variables: L, L'
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  ============================
   tmctx nil

Subgoal 2 is:
 tmctx (L' n2)

Subgoal 3 is:
 tmctx L'

tmctx_rst_pres < search.
Subgoal 2:

  Variables: L, L', L1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H2 : tmctx_rst (tm n1) (tm n2 :: L1 n1 n2) (L' n2)
  H3 : tmctx (L1 n1 n2) *
  ============================
   tmctx (L' n2)

Subgoal 3 is:
 tmctx L'

tmctx_rst_pres < case H2.
Subgoal 2:

  Variables: L, L', L1, L'1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H3 : tmctx (L1 n1 n2) *
  H4 : tmctx_rst (tm n1) (L1 n1 n2) (L'1 n2)
  ============================
   tmctx (tm n2 :: L'1 n2)

Subgoal 3 is:
 tmctx L'

tmctx_rst_pres < apply IH to H3 H4.
Subgoal 2:

  Variables: L, L', L1, L'1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H3 : tmctx (L1 n1 n2) *
  H4 : tmctx_rst (tm n1) (L1 n1 n2) (L'1 n2)
  H5 : tmctx (L'1 n2)
  ============================
   tmctx (tm n2 :: L'1 n2)

Subgoal 3 is:
 tmctx L'

tmctx_rst_pres < search.
Subgoal 3:

  Variables: L, L', L1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H2 : tmctx_rst (tm n1) (tm n1 :: L1 n1) L'
  H3 : tmctx (L1 n1) *
  ============================
   tmctx L'

tmctx_rst_pres < case H2.
Subgoal 3:

  Variables: L, L', L1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H3 : tmctx (L1 n1) *
  H4 : tmctx_rst (tm n1) (L1 n1) L'
  ============================
   tmctx L'

tmctx_rst_pres < apply IH to H3 H4.
Subgoal 3:

  Variables: L, L', L1
  IH : forall L L', nabla x, tmctx (L x) * -> tmctx_rst (tm x) (L x) L' ->
         tmctx L'
  H3 : tmctx (L1 n1) *
  H4 : tmctx_rst (tm n1) (L1 n1) L'
  H5 : tmctx L'
  ============================
   tmctx L'

tmctx_rst_pres < search.
Proof completed.

Abella < Theorem tmctx_rst_mem_str : 
forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' -> member (tm X) (L x) ->
  member (tm X) L'.


  ============================
   forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' ->
     member (tm X) (L x) -> member (tm X) L'

tmctx_rst_mem_str < induction on 1.


  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  ============================
   forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' @ ->
     member (tm X) (L x) -> member (tm X) L'

tmctx_rst_mem_str < intros.

  Variables: L, L', X
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H1 : tmctx_rst (tm n1) (L n1) L' @
  H2 : member (tm X) (L n1)
  ============================
   member (tm X) L'

tmctx_rst_mem_str < case H1.
Subgoal 1:

  Variables: L, L', X
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H2 : member (tm X) nil
  ============================
   member (tm X) nil

Subgoal 2 is:
 member (tm X) L'

Subgoal 3 is:
 member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < case H2.
Subgoal 2:

  Variables: L, L', X, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H2 : member (tm X) (tm n1 :: L1 n1)
  H3 : tmctx_rst (tm n1) (L1 n1) L' *
  ============================
   member (tm X) L'

Subgoal 3 is:
 member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < case H2.
Subgoal 2:

  Variables: L, L', X, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H3 : tmctx_rst (tm n1) (L1 n1) L' *
  H4 : member (tm X) (L1 n1)
  ============================
   member (tm X) L'

Subgoal 3 is:
 member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < apply IH to H3 H4.
Subgoal 2:

  Variables: L, L', X, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H3 : tmctx_rst (tm n1) (L1 n1) L' *
  H4 : member (tm X) (L1 n1)
  H5 : member (tm X) L'
  ============================
   member (tm X) L'

Subgoal 3 is:
 member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < search.
Subgoal 3:

  Variables: L, L', X, L'1, Y, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H2 : member (tm X) (tm Y :: L1 n1)
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  ============================
   member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < case H2.
Subgoal 3.1:

  Variables: L, L', X, L'1, Y, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  ============================
   member (tm Y) (tm Y :: L'1)

Subgoal 3.2 is:
 member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < search.
Subgoal 3.2:

  Variables: L, L', X, L'1, Y, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  H4 : member (tm X) (L1 n1)
  ============================
   member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < apply IH to H3 H4.
Subgoal 3.2:

  Variables: L, L', X, L'1, Y, L1
  IH : forall L L' X, nabla x, tmctx_rst (tm x) (L x) L' * ->
         member (tm X) (L x) -> member (tm X) L'
  H3 : tmctx_rst (tm n1) (L1 n1) L'1 *
  H4 : member (tm X) (L1 n1)
  H5 : member (tm X) L'1
  ============================
   member (tm X) (tm Y :: L'1)

tmctx_rst_mem_str < search.
Proof completed.

Abella < Theorem tm_strenghten : 
forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M} ->
  tmctx_rst (tm x) (L x) L' -> {L' |- tm M}.


  ============================
   forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M} ->
     tmctx_rst (tm x) (L x) L' -> {L' |- tm M}

tm_strenghten < induction on 2.


  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  ============================
   forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}@ ->
     tmctx_rst (tm x) (L x) L' -> {L' |- tm M}

tm_strenghten < intros.

  Variables: L, L', M
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H2 : {L n1 |- tm M}@
  H3 : tmctx_rst (tm n1) (L n1) L'
  ============================
   {L' |- tm M}

tm_strenghten < case H2.
Subgoal 1:

  Variables: L, L', M, N
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  ============================
   {L' |- tm (lnat N)}

Subgoal 2 is:
 {L' |- tm (app M2 M3)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < search.
Subgoal 2:

  Variables: L, L', M, M3, M2
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1 |- tm M2}*
  H5 : {L n1 |- tm M3}*
  ============================
   {L' |- tm (app M2 M3)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < apply IH to H1 H4 H3.
Subgoal 2:

  Variables: L, L', M, M3, M2
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1 |- tm M2}*
  H5 : {L n1 |- tm M3}*
  H6 : {L' |- tm M2}
  ============================
   {L' |- tm (app M2 M3)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < apply IH to H1 H5 H3.
Subgoal 2:

  Variables: L, L', M, M3, M2
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1 |- tm M2}*
  H5 : {L n1 |- tm M3}*
  H6 : {L' |- tm M2}
  H7 : {L' |- tm M3}
  ============================
   {L' |- tm (app M2 M3)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < search.
Subgoal 3:

  Variables: L, L', M, M1
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, tm n2 |- tm (M1 n2)}*
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < assert tmctx (tm n2 :: L n1).
Subgoal 3:

  Variables: L, L', M, M1
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, tm n2 |- tm (M1 n2)}*
  H5 : tmctx (tm n2 :: L n1)
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < assert tmctx_rst (tm n1) (tm n2 :: L n1) (tm n2 :: L').
Subgoal 3:

  Variables: L, L', M, M1
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, tm n2 |- tm (M1 n2)}*
  H5 : tmctx (tm n2 :: L n1)
  H6 : tmctx_rst (tm n1) (tm n2 :: L n1) (tm n2 :: L')
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < apply IH to H5 H4 H6.
Subgoal 3:

  Variables: L, L', M, M1
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, tm n2 |- tm (M1 n2)}*
  H5 : tmctx (tm n2 :: L n1)
  H6 : tmctx_rst (tm n1) (tm n2 :: L n1) (tm n2 :: L')
  H7 : {L', tm n2 |- tm (M1 n2)}
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

tm_strenghten < search.
Subgoal 4:

  Variables: L, L', M, F
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, [F n1] |- tm M}*
  H5 : member (F n1) (L n1)
  ============================
   {L' |- tm M}

tm_strenghten < apply tmctx_mem to H1 H5.
Subgoal 4:

  Variables: L, L', M, F, X
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {L n1, [tm (X n1)] |- tm M}*
  H5 : member (tm (X n1)) (L n1)
  H6 : tname (X n1)
  ============================
   {L' |- tm M}

tm_strenghten < case H4.
Subgoal 4:

  Variables: L, L', M, F, X
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H5 : member (tm M) (L n1)
  H6 : tname M
  ============================
   {L' |- tm M}

tm_strenghten < case H6.
Subgoal 4:

  Variables: L, L', M, F, X
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n2 n1)
  H3 : tmctx_rst (tm n1) (L n2 n1) (L' n2)
  H5 : member (tm n2) (L n2 n1)
  ============================
   {L' n2 |- tm n2}

tm_strenghten < apply tmctx_rst_mem_str to H3 H5.
Subgoal 4:

  Variables: L, L', M, F, X
  IH : forall L L' M, nabla x, tmctx (L x) -> {L x |- tm M}* ->
         tmctx_rst (tm x) (L x) L' -> {L' |- tm M}
  H1 : tmctx (L n2 n1)
  H3 : tmctx_rst (tm n1) (L n2 n1) (L' n2)
  H5 : member (tm n2) (L n2 n1)
  H7 : member (tm n2) (L' n2)
  ============================
   {L' n2 |- tm n2}

tm_strenghten < search.
Proof completed.

Abella < Theorem tm_cut : 
forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)} ->
  tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}.


  ============================
   forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)} ->
     tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}

tm_cut < induction on 2.


  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  ============================
   forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}@ ->
     tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}

tm_cut < intros.

  Variables: L, M, L', V
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H2 : {L n1 |- tm (M n1)}@
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  ============================
   {L' |- tm (M V)}

tm_cut < case H2.
Subgoal 1:

  Variables: L, M, L', V, N
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  ============================
   {L' |- tm (lnat N)}

Subgoal 2 is:
 {L' |- tm (app (M1 V) (N V))}

Subgoal 3 is:
 {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < search.
Subgoal 2:

  Variables: L, M, L', V, N, M1
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1 |- tm (M1 n1)}*
  H6 : {L n1 |- tm (N n1)}*
  ============================
   {L' |- tm (app (M1 V) (N V))}

Subgoal 3 is:
 {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < apply IH to H1 H5 H3 H4.
Subgoal 2:

  Variables: L, M, L', V, N, M1
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1 |- tm (M1 n1)}*
  H6 : {L n1 |- tm (N n1)}*
  H7 : {L' |- tm (M1 V)}
  ============================
   {L' |- tm (app (M1 V) (N V))}

Subgoal 3 is:
 {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < apply IH to H1 H6 H3 H4.
Subgoal 2:

  Variables: L, M, L', V, N, M1
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1 |- tm (M1 n1)}*
  H6 : {L n1 |- tm (N n1)}*
  H7 : {L' |- tm (M1 V)}
  H8 : {L' |- tm (N V)}
  ============================
   {L' |- tm (app (M1 V) (N V))}

Subgoal 3 is:
 {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < search.
Subgoal 3:

  Variables: L, M, L', V, R
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1, tm n2 |- tm (R n1 n2)}*
  ============================
   {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < apply IH to _ H5 _ H4.
Subgoal 3:

  Variables: L, M, L', V, R
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1, tm n2 |- tm (R n1 n2)}*
  H6 : {L', tm n2 |- tm (R V n2)}
  ============================
   {L' |- tm (abs (R V))}

Subgoal 4 is:
 {L' |- tm (M V)}

tm_cut < search.
Subgoal 4:

  Variables: L, M, L', V, F
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1, [F n1] |- tm (M n1)}*
  H6 : member (F n1) (L n1)
  ============================
   {L' |- tm (M V)}

tm_cut < apply tmctx_mem to H1 H6.
Subgoal 4:

  Variables: L, M, L', V, F, X
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H5 : {L n1, [tm (X n1)] |- tm (M n1)}*
  H6 : member (tm (X n1)) (L n1)
  H7 : tname (X n1)
  ============================
   {L' |- tm (M V)}

tm_cut < case H5.
Subgoal 4:

  Variables: L, M, L', V, F, X
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H6 : member (tm (M n1)) (L n1)
  H7 : tname (M n1)
  ============================
   {L' |- tm (M V)}

tm_cut < case H7.
Subgoal 4.1:

  Variables: L, M, L', V, F, X
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n2 n1)
  H3 : tmctx_rst (tm n1) (L n2 n1) (L' n2)
  H4 : {tm (V n2)}
  H6 : member (tm n2) (L n2 n1)
  ============================
   {L' n2 |- tm n2}

Subgoal 4.2 is:
 {L' |- tm V}

tm_cut < apply tmctx_rst_mem_str to H3 H6.
Subgoal 4.1:

  Variables: L, M, L', V, F, X
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n2 n1)
  H3 : tmctx_rst (tm n1) (L n2 n1) (L' n2)
  H4 : {tm (V n2)}
  H6 : member (tm n2) (L n2 n1)
  H8 : member (tm n2) (L' n2)
  ============================
   {L' n2 |- tm n2}

Subgoal 4.2 is:
 {L' |- tm V}

tm_cut < search.
Subgoal 4.2:

  Variables: L, M, L', V, F, X
  IH : forall L M L' V, nabla x, tmctx (L x) -> {L x |- tm (M x)}* ->
         tmctx_rst (tm x) (L x) L' -> {tm V} -> {L' |- tm (M V)}
  H1 : tmctx (L n1)
  H3 : tmctx_rst (tm n1) (L n1) L'
  H4 : {tm V}
  H6 : member (tm n1) (L n1)
  ============================
   {L' |- tm V}

tm_cut < search.
Proof completed.

Abella < Define env_elem_aux : (ctm -> ctm) -> prop by 
env_elem_aux (x\x);
env_elem_aux (x\rst (R x)) := env_elem_aux R.

Abella < Define env_elem : (ctm -> ctm) -> prop by 
env_elem (x\fst (R x)) := env_elem_aux R.

Abella < Define env_map : (ctm -> map_list) -> prop by 
env_map (x\ml_nil);
env_map (x\ml_cons (map X (V x)) (ML x)) := env_map ML /\ env_elem V.

Abella < Theorem env_elem_aux_closed : 
forall E, nabla x, env_elem_aux (E x) -> (exists E', E = y\E').


  ============================
   forall E, nabla x, env_elem_aux (E x) -> (exists E', E = y\E')

env_elem_aux_closed < induction on 1.


  IH : forall E, nabla x, env_elem_aux (E x) * -> (exists E', E = y\E')
  ============================
   forall E, nabla x, env_elem_aux (E x) @ -> (exists E', E = y\E')

env_elem_aux_closed < intros.

  Variables: E
  IH : forall E, nabla x, env_elem_aux (E x) * -> (exists E', E = y\E')
  H1 : env_elem_aux (E n1) @
  ============================
   exists E', E = y\E'

env_elem_aux_closed < case H1.
Subgoal 1:

  Variables: E
  IH : forall E, nabla x, env_elem_aux (E x) * -> (exists E', E = y\E')
  ============================
   exists E', z1\z2\z2 = y\E'

Subgoal 2 is:
 exists E', z1\z2\rst (R z1 z2) = y\E'

env_elem_aux_closed < search.
Subgoal 2:

  Variables: E, R
  IH : forall E, nabla x, env_elem_aux (E x) * -> (exists E', E = y\E')
  H2 : env_elem_aux (R n1) *
  ============================
   exists E', z1\z2\rst (R z1 z2) = y\E'

env_elem_aux_closed < apply IH to H2.
Subgoal 2:

  Variables: E, R, E'
  IH : forall E, nabla x, env_elem_aux (E x) * -> (exists E', E = y\E')
  H2 : env_elem_aux E' *
  ============================
   exists E'1, z1\z2\rst (E' z2) = y\E'1

env_elem_aux_closed < search.
Proof completed.

Abella < Theorem env_elem_closed : 
forall E, nabla x, env_elem (E x) -> (exists E', E = y\E').


  ============================
   forall E, nabla x, env_elem (E x) -> (exists E', E = y\E')

env_elem_closed < intros.

  Variables: E
  H1 : env_elem (E n1)
  ============================
   exists E', E = y\E'

env_elem_closed < case H1.

  Variables: E, R
  H2 : env_elem_aux (R n1)
  ============================
   exists E', z1\z2\fst (R z1 z2) = y\E'

env_elem_closed < apply env_elem_aux_closed to H2.

  Variables: E, R, E'
  H2 : env_elem_aux E'
  ============================
   exists E'1, z1\z2\fst (E' z2) = y\E'1

env_elem_closed < search.
Proof completed.

Abella < Theorem env_elem_aux_extend : 
forall E, env_elem_aux E -> env_elem_aux (x\E (rst x)).


  ============================
   forall E, env_elem_aux E -> env_elem_aux (x\E (rst x))

env_elem_aux_extend < induction on 1.


  IH : forall E, env_elem_aux E * -> env_elem_aux (x\E (rst x))
  ============================
   forall E, env_elem_aux E @ -> env_elem_aux (x\E (rst x))

env_elem_aux_extend < intros.

  Variables: E
  IH : forall E, env_elem_aux E * -> env_elem_aux (x\E (rst x))
  H1 : env_elem_aux E @
  ============================
   env_elem_aux (x\E (rst x))

env_elem_aux_extend < case H1.
Subgoal 1:

  Variables: E
  IH : forall E, env_elem_aux E * -> env_elem_aux (x\E (rst x))
  ============================
   env_elem_aux (x\rst x)

Subgoal 2 is:
 env_elem_aux (x\rst (R (rst x)))

env_elem_aux_extend < search.
Subgoal 2:

  Variables: E, R
  IH : forall E, env_elem_aux E * -> env_elem_aux (x\E (rst x))
  H2 : env_elem_aux R *
  ============================
   env_elem_aux (x\rst (R (rst x)))

env_elem_aux_extend < apply IH to H2.
Subgoal 2:

  Variables: E, R
  IH : forall E, env_elem_aux E * -> env_elem_aux (x\E (rst x))
  H2 : env_elem_aux R *
  H3 : env_elem_aux (x\R (rst x))
  ============================
   env_elem_aux (x\rst (R (rst x)))

env_elem_aux_extend < search.
Proof completed.

Abella < Theorem env_elem_extend : 
forall E, env_elem E -> env_elem (x\E (rst x)).


  ============================
   forall E, env_elem E -> env_elem (x\E (rst x))

env_elem_extend < intros.

  Variables: E
  H1 : env_elem E
  ============================
   env_elem (x\E (rst x))

env_elem_extend < case H1.

  Variables: E, R
  H2 : env_elem_aux R
  ============================
   env_elem (x\fst (R (rst x)))

env_elem_extend < apply env_elem_aux_extend to H2.

  Variables: E, R
  H2 : env_elem_aux R
  H3 : env_elem_aux (x\R (rst x))
  ============================
   env_elem (x\fst (R (rst x)))

env_elem_extend < search.
Proof completed.

Abella < Theorem mapvar_mem : 
forall FVs Map X E Env, nabla x, {mapvar FVs Map} ->
  {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\ env_elem E' /\
  {ml_member (map X (E' x)) (Map x)}).


  ============================
   forall FVs Map X E Env, nabla x, {mapvar FVs Map} ->
     {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
     env_elem E' /\ {ml_member (map X (E' x)) (Map x)})

mapvar_mem < induction on 1.


  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  ============================
   forall FVs Map X E Env, nabla x, {mapvar FVs Map}@ ->
     {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
     env_elem E' /\ {ml_member (map X (E' x)) (Map x)})

mapvar_mem < intros.

  Variables: FVs, Map, X, E, Env
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H1 : {mapvar FVs Map}@
  H2 : {ml_member (map X E) (Map Env)}
  ============================
   exists E', E = E' Env /\ env_elem E' /\
     {ml_member (map X (E' n1)) (Map n1)}

mapvar_mem < case H1.
Subgoal 1:

  Variables: FVs, Map, X, E, Env
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H2 : {ml_member (map X E) ml_nil}
  ============================
   exists E', E = E' Env /\ env_elem E' /\ {ml_member (map X (E' n1)) ml_nil}

Subgoal 2 is:
 exists E', E = E' Env /\ env_elem E' /\
   {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < case H2.
Subgoal 2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H2 : {ml_member (map X E) (ml_cons (map X1 (fst Env)) (Map1 (rst Env)))}
  H3 : {mapvar L Map1}*
  ============================
   exists E', E = E' Env /\ env_elem E' /\
     {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < case H2.
Subgoal 2.1:

  Variables: FVs, Map, X, E, Env, Map1, L, X1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  ============================
   exists E', fst Env = E' Env /\ env_elem E' /\
     {ml_member (map X1 (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

Subgoal 2.2 is:
 exists E', E = E' Env /\ env_elem E' /\
   {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < exists x\fst x.
Subgoal 2.1:

  Variables: FVs, Map, X, E, Env, Map1, L, X1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  ============================
   fst Env = fst Env /\ env_elem (x\fst x) /\
     {ml_member (map X1 (fst n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

Subgoal 2.2 is:
 exists E', E = E' Env /\ env_elem E' /\
   {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < search.
Subgoal 2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  ============================
   exists E', E = E' Env /\ env_elem E' /\
     {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < apply IH to H3 H4.
Subgoal 2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E'
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E' n1 (rst Env)
  H6 : env_elem (E' n1)
  H7 : {ml_member (map X (E' n1 n1)) (Map1 n1)}
  ============================
   exists E', E = E' Env /\ env_elem E' /\
     {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < apply env_elem_closed to H6.
Subgoal 2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  ============================
   exists E', E = E' Env /\ env_elem E' /\
     {ml_member (map X (E' n1)) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < exists x\E'1 (rst x).
Subgoal 2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  ============================
   E = E'1 (rst Env) /\ env_elem (x\E'1 (rst x)) /\
     {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < split.
Subgoal 2.2.1:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  ============================
   E = E'1 (rst Env)

Subgoal 2.2.2 is:
 env_elem (x\E'1 (rst x))

Subgoal 2.2.3 is:
 {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < search.
Subgoal 2.2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  ============================
   env_elem (x\E'1 (rst x))

Subgoal 2.2.3 is:
 {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < apply env_elem_extend to H6.
Subgoal 2.2.2:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  H8 : env_elem (x\E'1 (rst x))
  ============================
   env_elem (x\E'1 (rst x))

Subgoal 2.2.3 is:
 {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < search.
Subgoal 2.2.3:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  ============================
   {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < inst H7 with n1 = rst n1.
Subgoal 2.2.3:

  Variables: FVs, Map, X, E, Env, Map1, L, X1, E', E'1
  IH : forall FVs Map X E Env, nabla x, {mapvar FVs Map}* ->
         {ml_member (map X E) (Map Env)} -> (exists E', E = E' Env /\
         env_elem E' /\ {ml_member (map X (E' x)) (Map x)})
  H3 : {mapvar L Map1}*
  H4 : {ml_member (map X E) (Map1 (rst Env))}
  H5 : E = E'1 (rst Env)
  H6 : env_elem E'1
  H7 : {ml_member (map X (E'1 n1)) (Map1 n1)}
  H8 : {ml_member (map X (E'1 (rst n1))) (Map1 (rst n1))}
  ============================
   {ml_member (map X (E'1 (rst n1))) (ml_cons (map X1 (fst n1)) (Map1 (rst n1)))}

mapvar_mem < search.
Proof completed.

Abella < Theorem env_map_rst : 
forall Map, env_map Map -> env_map (x\Map (rst x)).


  ============================
   forall Map, env_map Map -> env_map (x\Map (rst x))

env_map_rst < induction on 1.


  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  ============================
   forall Map, env_map Map @ -> env_map (x\Map (rst x))

env_map_rst < intros.

  Variables: Map
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H1 : env_map Map @
  ============================
   env_map (x\Map (rst x))

env_map_rst < case H1.
Subgoal 1:

  Variables: Map
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  ============================
   env_map (x\ml_nil)

Subgoal 2 is:
 env_map (x\ml_cons (map X (V (rst x))) (ML (rst x)))

env_map_rst < search.
Subgoal 2:

  Variables: Map, ML, V, X
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H2 : env_map ML *
  H3 : env_elem V
  ============================
   env_map (x\ml_cons (map X (V (rst x))) (ML (rst x)))

env_map_rst < apply IH to H2.
Subgoal 2:

  Variables: Map, ML, V, X
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H2 : env_map ML *
  H3 : env_elem V
  H4 : env_map (x\ML (rst x))
  ============================
   env_map (x\ml_cons (map X (V (rst x))) (ML (rst x)))

env_map_rst < unfold.
Subgoal 2.1:

  Variables: Map, ML, V, X
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H2 : env_map ML *
  H3 : env_elem V
  H4 : env_map (x\ML (rst x))
  ============================
   env_map (z1\ML (rst z1))

Subgoal 2.2 is:
 env_elem (z1\V (rst z1))

env_map_rst < search.
Subgoal 2.2:

  Variables: Map, ML, V, X
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H2 : env_map ML *
  H3 : env_elem V
  H4 : env_map (x\ML (rst x))
  ============================
   env_elem (z1\V (rst z1))

env_map_rst < apply env_elem_extend to H3.
Subgoal 2.2:

  Variables: Map, ML, V, X
  IH : forall Map, env_map Map * -> env_map (x\Map (rst x))
  H2 : env_map ML *
  H3 : env_elem V
  H4 : env_map (x\ML (rst x))
  H5 : env_elem (x\V (rst x))
  ============================
   env_elem (z1\V (rst z1))

env_map_rst < search.
Proof completed.

Abella < Theorem mapvar_env_map : 
forall FVs Map, {mapvar FVs Map} -> env_map Map.


  ============================
   forall FVs Map, {mapvar FVs Map} -> env_map Map

mapvar_env_map < induction on 1.


  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  ============================
   forall FVs Map, {mapvar FVs Map}@ -> env_map Map

mapvar_env_map < intros.

  Variables: FVs, Map
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H1 : {mapvar FVs Map}@
  ============================
   env_map Map

mapvar_env_map < case H1.
Subgoal 1:

  Variables: FVs, Map
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  ============================
   env_map (xenv\ml_nil)

Subgoal 2 is:
 env_map (xenv\ml_cons (map X (fst xenv)) (Map1 (rst xenv)))

mapvar_env_map < search.
Subgoal 2:

  Variables: FVs, Map, Map1, L, X
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H2 : {mapvar L Map1}*
  ============================
   env_map (xenv\ml_cons (map X (fst xenv)) (Map1 (rst xenv)))

mapvar_env_map < apply IH to H2.
Subgoal 2:

  Variables: FVs, Map, Map1, L, X
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H2 : {mapvar L Map1}*
  H3 : env_map Map1
  ============================
   env_map (xenv\ml_cons (map X (fst xenv)) (Map1 (rst xenv)))

mapvar_env_map < unfold.
Subgoal 2.1:

  Variables: FVs, Map, Map1, L, X
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H2 : {mapvar L Map1}*
  H3 : env_map Map1
  ============================
   env_map (z1\Map1 (rst z1))

Subgoal 2.2 is:
 env_elem (z1\fst z1)

mapvar_env_map < apply env_map_rst to H3.
Subgoal 2.1:

  Variables: FVs, Map, Map1, L, X
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H2 : {mapvar L Map1}*
  H3 : env_map Map1
  H4 : env_map (x\Map1 (rst x))
  ============================
   env_map (z1\Map1 (rst z1))

Subgoal 2.2 is:
 env_elem (z1\fst z1)

mapvar_env_map < search.
Subgoal 2.2:

  Variables: FVs, Map, Map1, L, X
  IH : forall FVs Map, {mapvar FVs Map}* -> env_map Map
  H2 : {mapvar L Map1}*
  H3 : env_map Map1
  ============================
   env_elem (z1\fst z1)

mapvar_env_map < search.
Proof completed.

Abella < Theorem env_elem_aux_ctm : 
forall V, nabla xenv, env_elem_aux V -> {ctm xenv |- ctm (V xenv)}.


  ============================
   forall V, nabla xenv, env_elem_aux V -> {ctm xenv |- ctm (V xenv)}

env_elem_aux_ctm < induction on 1.


  IH : forall V, nabla xenv, env_elem_aux V * -> {ctm xenv |- ctm (V xenv)}
  ============================
   forall V, nabla xenv, env_elem_aux V @ -> {ctm xenv |- ctm (V xenv)}

env_elem_aux_ctm < intros.

  Variables: V
  IH : forall V, nabla xenv, env_elem_aux V * -> {ctm xenv |- ctm (V xenv)}
  H1 : env_elem_aux V @
  ============================
   {ctm n1 |- ctm (V n1)}

env_elem_aux_ctm < case H1.
Subgoal 1:

  Variables: V
  IH : forall V, nabla xenv, env_elem_aux V * -> {ctm xenv |- ctm (V xenv)}
  ============================
   {ctm n1 |- ctm n1}

Subgoal 2 is:
 {ctm n1 |- ctm (rst (R n1))}

env_elem_aux_ctm < search.
Subgoal 2:

  Variables: V, R
  IH : forall V, nabla xenv, env_elem_aux V * -> {ctm xenv |- ctm (V xenv)}
  H2 : env_elem_aux R *
  ============================
   {ctm n1 |- ctm (rst (R n1))}

env_elem_aux_ctm < apply IH to H2.
Subgoal 2:

  Variables: V, R
  IH : forall V, nabla xenv, env_elem_aux V * -> {ctm xenv |- ctm (V xenv)}
  H2 : env_elem_aux R *
  H3 : {ctm n1 |- ctm (R n1)}
  ============================
   {ctm n1 |- ctm (rst (R n1))}

env_elem_aux_ctm < search.
Proof completed.

Abella < Theorem env_elem_ctm : 
forall V, nabla xenv, env_elem V -> {ctm xenv |- ctm (V xenv)}.


  ============================
   forall V, nabla xenv, env_elem V -> {ctm xenv |- ctm (V xenv)}

env_elem_ctm < intros.

  Variables: V
  H1 : env_elem V
  ============================
   {ctm n1 |- ctm (V n1)}

env_elem_ctm < case H1.

  Variables: V, R
  H2 : env_elem_aux R
  ============================
   {ctm n1 |- ctm (fst (R n1))}

env_elem_ctm < apply env_elem_aux_ctm to H2.

  Variables: V, R
  H2 : env_elem_aux R
  H3 : {ctm n1 |- ctm (R n1)}
  ============================
   {ctm n1 |- ctm (fst (R n1))}

env_elem_ctm < search.
Proof completed.

Abella < Theorem env_map_ctm : 
forall Map V X, nabla xenv, env_map Map ->
  {ml_member (map X (V xenv)) (Map xenv)} -> {ctm xenv |- ctm (V xenv)}.


  ============================
   forall Map V X, nabla xenv, env_map Map ->
     {ml_member (map X (V xenv)) (Map xenv)} -> {ctm xenv |- ctm (V xenv)}

env_map_ctm < induction on 1.


  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  ============================
   forall Map V X, nabla xenv, env_map Map @ ->
     {ml_member (map X (V xenv)) (Map xenv)} -> {ctm xenv |- ctm (V xenv)}

env_map_ctm < intros.

  Variables: Map, V, X
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H1 : env_map Map @
  H2 : {ml_member (map X (V n1)) (Map n1)}
  ============================
   {ctm n1 |- ctm (V n1)}

env_map_ctm < case H1.
Subgoal 1:

  Variables: Map, V, X
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H2 : {ml_member (map X (V n1)) ml_nil}
  ============================
   {ctm n1 |- ctm (V n1)}

Subgoal 2 is:
 {ctm n1 |- ctm (V n1)}

env_map_ctm < case H2.
Subgoal 2:

  Variables: Map, V, X, ML, V1, X1
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H2 : {ml_member (map X (V n1)) (ml_cons (map X1 (V1 n1)) (ML n1))}
  H3 : env_map ML *
  H4 : env_elem V1
  ============================
   {ctm n1 |- ctm (V n1)}

env_map_ctm < case H2.
Subgoal 2.1:

  Variables: Map, V, X, ML, V1, X1
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H3 : env_map ML *
  H4 : env_elem V1
  ============================
   {ctm n1 |- ctm (V1 n1)}

Subgoal 2.2 is:
 {ctm n1 |- ctm (V n1)}

env_map_ctm < apply env_elem_ctm to H4.
Subgoal 2.1:

  Variables: Map, V, X, ML, V1, X1
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H3 : env_map ML *
  H4 : env_elem V1
  H5 : {ctm n1 |- ctm (V1 n1)}
  ============================
   {ctm n1 |- ctm (V1 n1)}

Subgoal 2.2 is:
 {ctm n1 |- ctm (V n1)}

env_map_ctm < search.
Subgoal 2.2:

  Variables: Map, V, X, ML, V1, X1
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H3 : env_map ML *
  H4 : env_elem V1
  H5 : {ml_member (map X (V n1)) (ML n1)}
  ============================
   {ctm n1 |- ctm (V n1)}

env_map_ctm < apply IH to H3 H5.
Subgoal 2.2:

  Variables: Map, V, X, ML, V1, X1
  IH : forall Map V X, nabla xenv, env_map Map * ->
         {ml_member (map X (V xenv)) (Map xenv)} ->
         {ctm xenv |- ctm (V xenv)}
  H3 : env_map ML *
  H4 : env_elem V1
  H5 : {ml_member (map X (V n1)) (ML n1)}
  H6 : {ctm n1 |- ctm (V n1)}
  ============================
   {ctm n1 |- ctm (V n1)}

env_map_ctm < search.
Proof completed.

Abella < Theorem mapenv_ctm : 
forall FVs PE Map, nabla x y xenv, env_map Map ->
  {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)} ->
  {ctm xenv, ctm y |- ctm (PE xenv y)}.


  ============================
   forall FVs PE Map, nabla x y xenv, env_map Map ->
     {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)} ->
     {ctm xenv, ctm y |- ctm (PE xenv y)}

mapenv_ctm < induction on 2.


  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  ============================
   forall FVs PE Map, nabla x y xenv, env_map Map ->
     {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}@ ->
     {ctm xenv, ctm y |- ctm (PE xenv y)}

mapenv_ctm < intros.

  Variables: FVs, PE, Map
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H2 : {mapenv (FVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}@
  ============================
   {ctm n3, ctm n2 |- ctm (PE n3 n2)}

mapenv_ctm < case H2.
Subgoal 1:

  Variables: FVs, PE, Map
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  ============================
   {ctm n3, ctm n2 |- ctm unit}

Subgoal 2 is:
 {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < search.
Subgoal 2:

  Variables: FVs, PE, Map, ML, L, M, X
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H3 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H4 : {mapenv (L n1) (ml_cons (map n1 n2) (Map n3)) (ML n2 n3)}*
  ============================
   {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < apply IH to H1 H4.
Subgoal 2:

  Variables: FVs, PE, Map, ML, L, M, X
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H3 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H4 : {mapenv (L n1) (ml_cons (map n1 n2) (Map n3)) (ML n2 n3)}*
  H5 : {ctm n3, ctm n2 |- ctm (ML n2 n3)}
  ============================
   {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < case H3.
Subgoal 2.1:

  Variables: FVs, PE, Map, ML, L, M, X
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H4 : {mapenv (L n1) (ml_cons (map n1 n2) (Map n3)) (ML n2 n3)}*
  H5 : {ctm n3, ctm n2 |- ctm (ML n2 n3)}
  ============================
   {ctm n3, ctm n2 |- ctm (cross n2 (ML n2 n3))}

Subgoal 2.2 is:
 {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < search.
Subgoal 2.2:

  Variables: FVs, PE, Map, ML, L, M, X
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H4 : {mapenv (L n1) (ml_cons (map n1 n2) (Map n3)) (ML n2 n3)}*
  H5 : {ctm n3, ctm n2 |- ctm (ML n2 n3)}
  H6 : {ml_member (map (X n1) (M n2 n3)) (Map n3)}*
  ============================
   {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < apply env_map_ctm to H1 H6.
Subgoal 2.2:

  Variables: FVs, PE, Map, ML, L, M, X
  IH : forall FVs PE Map, nabla x y xenv, env_map Map ->
         {mapenv (FVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         {ctm xenv, ctm y |- ctm (PE xenv y)}
  H1 : env_map Map
  H4 : {mapenv (L n1) (ml_cons (map n1 n2) (Map n3)) (ML n2 n3)}*
  H5 : {ctm n3, ctm n2 |- ctm (ML n2 n3)}
  H6 : {ml_member (map (X n1) (M n2 n3)) (Map n3)}*
  H7 : {ctm n3 |- ctm (M n2 n3)}
  ============================
   {ctm n3, ctm n2 |- ctm (cross (M n2 n3) (ML n2 n3))}

mapenv_ctm < search.
Proof completed.

Abella < Theorem cc_ctm : 
forall M P Map FVs, nabla x xenv y, env_map Map ->
  {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
  {ctm xenv, ctm y |- ctm (P xenv y)}.


  ============================
   forall M P Map FVs, nabla x xenv y, env_map Map ->
     {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
     {ctm xenv, ctm y |- ctm (P xenv y)}

cc_ctm < induction on 2.


  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  ============================
   forall M P Map FVs, nabla x xenv y, env_map Map ->
     {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}@ ->
     {ctm xenv, ctm y |- ctm (P xenv y)}

cc_ctm < intros.

  Variables: M, P, Map, FVs
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H2 : {cc (M n1) (P n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}@
  ============================
   {ctm n2, ctm n3 |- ctm (P n2 n3)}

cc_ctm < case H2.
Subgoal 1:

  Variables: M, P, Map, FVs
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {ml_member (map (M n1) (P n2 n3)) (ml_cons (map n1 n3) (Map n2))}*
  ============================
   {ctm n2, ctm n3 |- ctm (P n2 n3)}

Subgoal 2 is:
 {ctm n2, ctm n3 |- ctm (clnat N)}

Subgoal 3 is:
 {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < case H3.
Subgoal 1.1:

  Variables: M, P, Map, FVs
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  ============================
   {ctm n2, ctm n3 |- ctm n3}

Subgoal 1.2 is:
 {ctm n2, ctm n3 |- ctm (P n2 n3)}

Subgoal 2 is:
 {ctm n2, ctm n3 |- ctm (clnat N)}

Subgoal 3 is:
 {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < search.
Subgoal 1.2:

  Variables: M, P, Map, FVs
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H4 : {ml_member (map (M n1) (P n2 n3)) (Map n2)}*
  ============================
   {ctm n2, ctm n3 |- ctm (P n2 n3)}

Subgoal 2 is:
 {ctm n2, ctm n3 |- ctm (clnat N)}

Subgoal 3 is:
 {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < apply env_map_ctm to H1 H4.
Subgoal 1.2:

  Variables: M, P, Map, FVs
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H4 : {ml_member (map (M n1) (P n2 n3)) (Map n2)}*
  H5 : {ctm n2 |- ctm (P n2 n3)}
  ============================
   {ctm n2, ctm n3 |- ctm (P n2 n3)}

Subgoal 2 is:
 {ctm n2, ctm n3 |- ctm (clnat N)}

Subgoal 3 is:
 {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < search.
Subgoal 2:

  Variables: M, P, Map, FVs, N
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  ============================
   {ctm n2, ctm n3 |- ctm (clnat N)}

Subgoal 3 is:
 {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < search.
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (NMap n1 n2 n3)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n2 n3 n6)) (tl_cons n4 (NFVs n1))}*
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < apply mapvar_prune to H5.
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML'
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML' n3 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML' n3 n1 n6)) (tl_cons n4 (NFVs n1))}*
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < apply mapvar_prune to H5.
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML', ML'1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML'1 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < apply mapvar_env_map to H5.
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML', ML'1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML'1 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H7 : env_map (ML'1 n1)
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < apply IH to H7 H6.
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML', ML'1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML'1 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H7 : env_map (ML'1 n1)
  H8 : {ctm n6, ctm n5 |- ctm (P1 n2 n3 n6 n5)}
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < apply mapenv_ctm to H1 H4.
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML', ML'1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML'1 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H7 : env_map (ML'1 n1)
  H8 : {ctm n6, ctm n5 |- ctm (P1 n2 n3 n6 n5)}
  H9 : {ctm n2, ctm n3 |- ctm (PE n2 n3)}
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < assert {ctm n2, ctm n3 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y))))}.
Subgoal 3:

  Variables: M, P, Map, FVs, NFVs, NMap, P1, M1, PE, ML', ML'1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {fvars (abs (M1 n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H4 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (PE n2 n3)}*
  H5 : {mapvar (NFVs n1) (ML'1 n1)}*
  H6 : {cc (M1 n1 n4) (P1 n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H7 : env_map (ML'1 n1)
  H8 : {ctm n6, ctm n5 |- ctm (P1 n2 n3 n6 n5)}
  H9 : {ctm n2, ctm n3 |- ctm (PE n2 n3)}
  H10 : {ctm n2, ctm n3 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y))))}
  ============================
   {ctm n2, ctm n3 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P1 n2 n3 xenv y)))) (PE n2 n3))}

Subgoal 4 is:
 {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < search.
Subgoal 4:

  Variables: M, P, Map, FVs, CM2, M2, CM1, M1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {cc (M1 n1) (CM1 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  H4 : {cc (M2 n1) (CM2 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  ============================
   {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < apply IH to H1 H3.
Subgoal 4:

  Variables: M, P, Map, FVs, CM2, M2, CM1, M1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {cc (M1 n1) (CM1 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  H4 : {cc (M2 n1) (CM2 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  H5 : {ctm n2, ctm n3 |- ctm (CM1 n2 n3)}
  ============================
   {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < apply IH to H1 H4.
Subgoal 4:

  Variables: M, P, Map, FVs, CM2, M2, CM1, M1
  IH : forall M P Map FVs, nabla x xenv y, env_map Map ->
         {cc (M x) (P xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         {ctm xenv, ctm y |- ctm (P xenv y)}
  H1 : env_map Map
  H3 : {cc (M1 n1) (CM1 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  H4 : {cc (M2 n1) (CM2 n2 n3) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}*
  H5 : {ctm n2, ctm n3 |- ctm (CM1 n2 n3)}
  H6 : {ctm n2, ctm n3 |- ctm (CM2 n2 n3)}
  ============================
   {ctm n2, ctm n3 |- ctm (cunpair (CM1 n2 n3) (f\env\capp f (cross (CM2 n2 n3) env)))}

cc_ctm < search.
Proof completed.

Abella < Define name_map : map_list -> prop by 
name_map ml_nil;
name_map (ml_cons (map X V) ML) := name_map ML /\ tname X.

Abella < Theorem name_map_nominal : 
forall Map X V, name_map Map -> {ml_member (map X V) Map} -> tname X.


  ============================
   forall Map X V, name_map Map -> {ml_member (map X V) Map} -> tname X

name_map_nominal < induction on 1.


  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  ============================
   forall Map X V, name_map Map @ -> {ml_member (map X V) Map} -> tname X

name_map_nominal < intros.

  Variables: Map, X, V
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H1 : name_map Map @
  H2 : {ml_member (map X V) Map}
  ============================
   tname X

name_map_nominal < case H1.
Subgoal 1:

  Variables: Map, X, V
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H2 : {ml_member (map X V) ml_nil}
  ============================
   tname X

Subgoal 2 is:
 tname X

name_map_nominal < case H2.
Subgoal 2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H2 : {ml_member (map X V) (ml_cons (map X1 V1) ML)}
  H3 : name_map ML *
  H4 : tname X1
  ============================
   tname X

name_map_nominal < case H2.
Subgoal 2.1:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

name_map_nominal < search.
Subgoal 2.2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  H5 : {ml_member (map X V) ML}
  ============================
   tname X

name_map_nominal < apply IH to H3 H5.
Subgoal 2.2:

  Variables: Map, X, V, ML, V1, X1
  IH : forall Map X V, name_map Map * -> {ml_member (map X V) Map} -> tname X
  H3 : name_map ML *
  H4 : tname X1
  H5 : {ml_member (map X V) ML}
  H6 : tname X
  ============================
   tname X

name_map_nominal < search.
Proof completed.

Abella < Theorem clos_closed : 
forall Map R E FVs F, nabla x xenv y, name_map (Map xenv) -> env_map Map ->
  {cc (abs (R x)) (cpair (F xenv y) (E xenv y)) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
  {ctm (F xenv y)}.


  ============================
   forall Map R E FVs F, nabla x xenv y, name_map (Map xenv) ->
     env_map Map ->
     {cc (abs (R x)) (cpair (F xenv y) (E xenv y)) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
     {ctm (F xenv y)}

clos_closed < intros.

  Variables: Map, R, E, FVs, F
  H1 : name_map (Map n2)
  H2 : env_map Map
  H3 : {cc (abs (R n1)) (cpair (F n2 n3) (E n2 n3)) (ml_cons (map n1 n3) (Map n2)) (tl_cons n1 FVs)}
  ============================
   {ctm (F n2 n3)}

clos_closed < case H3.
Subgoal 1:

  Variables: Map, R, E, FVs, F
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {ml_member (map (abs (R n1)) (cpair (F n2 n3) (E n2 n3))) (ml_cons (map n1 n3) (Map n2))}
  ============================
   {ctm (F n2 n3)}

Subgoal 2 is:
 {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < case H4.
Subgoal 1:

  Variables: Map, R, E, FVs, F
  H1 : name_map (Map n2)
  H2 : env_map Map
  H5 : {ml_member (map (abs (R n1)) (cpair (F n2 n3) (E n2 n3))) (Map n2)}
  ============================
   {ctm (F n2 n3)}

Subgoal 2 is:
 {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < assert name_map (Map n2).
Subgoal 1:

  Variables: Map, R, E, FVs, F
  H1 : name_map (Map n2)
  H2 : env_map Map
  H5 : {ml_member (map (abs (R n1)) (cpair (F n2 n3) (E n2 n3))) (Map n2)}
  H6 : name_map (Map n2)
  ============================
   {ctm (F n2 n3)}

Subgoal 2 is:
 {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < apply name_map_nominal to H6 H5.
Subgoal 1:

  Variables: Map, R, E, FVs, F
  H1 : name_map (Map n2)
  H2 : env_map Map
  H5 : {ml_member (map (abs (R n1)) (cpair (F n2 n3) (E n2 n3))) (Map n2)}
  H6 : name_map (Map n2)
  H7 : tname (abs (R n1))
  ============================
   {ctm (F n2 n3)}

Subgoal 2 is:
 {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < case H7.
Subgoal 2:

  Variables: Map, R, E, FVs, F, NFVs, NMap, P
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {fvars (abs (R n1)) (tl_cons n1 FVs) (NFVs n1)}
  H5 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (E n2 n3)}
  H6 : {mapvar (NFVs n1) (NMap n1 n2 n3)}
  H7 : {cc (R n1 n4) (P n2 n3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n2 n3 n6)) (tl_cons n4 (NFVs n1))}
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < apply mapvar_prune to H6.
Subgoal 2:

  Variables: Map, R, E, FVs, F, NFVs, NMap, P, ML'
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {fvars (abs (R n1)) (tl_cons n1 FVs) (NFVs n1)}
  H5 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (E n2 n3)}
  H6 : {mapvar (NFVs n1) (ML' n3 n1)}
  H7 : {cc (R n1 n4) (P n2 n3 n6 n5) (ml_cons (map n4 n5) (ML' n3 n1 n6)) (tl_cons n4 (NFVs n1))}
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < apply mapvar_prune to H6.
Subgoal 2:

  Variables: Map, R, E, FVs, F, NFVs, NMap, P, ML', ML'1
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {fvars (abs (R n1)) (tl_cons n1 FVs) (NFVs n1)}
  H5 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (E n2 n3)}
  H6 : {mapvar (NFVs n1) (ML'1 n1)}
  H7 : {cc (R n1 n4) (P n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < apply mapvar_env_map to H6.
Subgoal 2:

  Variables: Map, R, E, FVs, F, NFVs, NMap, P, ML', ML'1
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {fvars (abs (R n1)) (tl_cons n1 FVs) (NFVs n1)}
  H5 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (E n2 n3)}
  H6 : {mapvar (NFVs n1) (ML'1 n1)}
  H7 : {cc (R n1 n4) (P n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}
  H8 : env_map (ML'1 n1)
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < apply cc_ctm to H8 H7.
Subgoal 2:

  Variables: Map, R, E, FVs, F, NFVs, NMap, P, ML', ML'1
  H1 : name_map (Map n2)
  H2 : env_map Map
  H4 : {fvars (abs (R n1)) (tl_cons n1 FVs) (NFVs n1)}
  H5 : {mapenv (NFVs n1) (ml_cons (map n1 n3) (Map n2)) (E n2 n3)}
  H6 : {mapvar (NFVs n1) (ML'1 n1)}
  H7 : {cc (R n1 n4) (P n2 n3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}
  H8 : env_map (ML'1 n1)
  H9 : {ctm n6, ctm n5 |- ctm (P n2 n3 n6 n5)}
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n2 n3 xenv y))))}

clos_closed < search.
Proof completed.

Abella < Theorem val_eval : 
forall V, {val V} -> {eval V V}.


  ============================
   forall V, {val V} -> {eval V V}

val_eval < intros.

  Variables: V
  H1 : {val V}
  ============================
   {eval V V}

val_eval < case H1.
Subgoal 1:

  Variables: V, N
  ============================
   {eval (lnat N) (lnat N)}

Subgoal 2 is:
 {eval (abs F) (abs F)}

val_eval < search.
Subgoal 2:

  Variables: V, F
  ============================
   {eval (abs F) (abs F)}

val_eval < search.
Proof completed.

Abella < Theorem val_eval_refl : 
forall V M, {val V} -> {eval V M} -> V = M.


  ============================
   forall V M, {val V} -> {eval V M} -> V = M

val_eval_refl < induction on 1.


  IH : forall V M, {val V}* -> {eval V M} -> V = M
  ============================
   forall V M, {val V}@ -> {eval V M} -> V = M

val_eval_refl < intros.

  Variables: V, M
  IH : forall V M, {val V}* -> {eval V M} -> V = M
  H1 : {val V}@
  H2 : {eval V M}
  ============================
   V = M

val_eval_refl < case H1.
Subgoal 1:

  Variables: V, M, N
  IH : forall V M, {val V}* -> {eval V M} -> V = M
  H2 : {eval (lnat N) M}
  ============================
   lnat N = M

Subgoal 2 is:
 abs F = M

val_eval_refl < case H2.
Subgoal 1:

  Variables: V, M, N
  IH : forall V M, {val V}* -> {eval V M} -> V = M
  ============================
   lnat N = lnat N

Subgoal 2 is:
 abs F = M

val_eval_refl < search.
Subgoal 2:

  Variables: V, M, F
  IH : forall V M, {val V}* -> {eval V M} -> V = M
  H2 : {eval (abs F) M}
  ============================
   abs F = M

val_eval_refl < case H2.
Subgoal 2:

  Variables: V, M, F
  IH : forall V M, {val V}* -> {eval V M} -> V = M
  ============================
   abs F = abs F

val_eval_refl < search.
Proof completed.

Abella < Theorem eval_val : 
forall M M', {eval M M'} -> {val M'}.


  ============================
   forall M M', {eval M M'} -> {val M'}

eval_val < induction on 1.


  IH : forall M M', {eval M M'}* -> {val M'}
  ============================
   forall M M', {eval M M'}@ -> {val M'}

eval_val < intros.

  Variables: M, M'
  IH : forall M M', {eval M M'}* -> {val M'}
  H1 : {eval M M'}@
  ============================
   {val M'}

eval_val < case H1.
Subgoal 1:

  Variables: M, M', X
  IH : forall M M', {eval M M'}* -> {val M'}
  ============================
   {val (lnat X)}

Subgoal 2 is:
 {val M'}

Subgoal 3 is:
 {val (abs F)}

eval_val < search.
Subgoal 2:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {eval M M'}* -> {val M'}
  H2 : {eval M1 (abs F)}*
  H3 : {eval M2 V2}*
  H4 : {eval (F V2) M'}*
  ============================
   {val M'}

Subgoal 3 is:
 {val (abs F)}

eval_val < apply IH to H2.
Subgoal 2:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {eval M M'}* -> {val M'}
  H2 : {eval M1 (abs F)}*
  H3 : {eval M2 V2}*
  H4 : {eval (F V2) M'}*
  H5 : {val (abs F)}
  ============================
   {val M'}

Subgoal 3 is:
 {val (abs F)}

eval_val < apply IH to H3.
Subgoal 2:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {eval M M'}* -> {val M'}
  H2 : {eval M1 (abs F)}*
  H3 : {eval M2 V2}*
  H4 : {eval (F V2) M'}*
  H5 : {val (abs F)}
  H6 : {val V2}
  ============================
   {val M'}

Subgoal 3 is:
 {val (abs F)}

eval_val < apply IH to H4.
Subgoal 2:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {eval M M'}* -> {val M'}
  H2 : {eval M1 (abs F)}*
  H3 : {eval M2 V2}*
  H4 : {eval (F V2) M'}*
  H5 : {val (abs F)}
  H6 : {val V2}
  H7 : {val M'}
  ============================
   {val M'}

Subgoal 3 is:
 {val (abs F)}

eval_val < search.
Subgoal 3:

  Variables: M, M', F
  IH : forall M M', {eval M M'}* -> {val M'}
  ============================
   {val (abs F)}

eval_val < search.
Proof completed.

Abella < Theorem eval_trans : 
forall M1 M2 M3, {eval M1 M2} -> {eval M2 M3} -> {eval M1 M3}.


  ============================
   forall M1 M2 M3, {eval M1 M2} -> {eval M2 M3} -> {eval M1 M3}

eval_trans < intros.

  Variables: M1, M2, M3
  H1 : {eval M1 M2}
  H2 : {eval M2 M3}
  ============================
   {eval M1 M3}

eval_trans < apply eval_val to H1.

  Variables: M1, M2, M3
  H1 : {eval M1 M2}
  H2 : {eval M2 M3}
  H3 : {val M2}
  ============================
   {eval M1 M3}

eval_trans < apply val_eval_refl to H3 H2.

  Variables: M1, M2, M3
  H1 : {eval M1 M3}
  H2 : {eval M3 M3}
  H3 : {val M3}
  ============================
   {eval M1 M3}

eval_trans < search.
Proof completed.

Abella < Theorem eval_app_trans : 
forall E1 E2 V1 V2 V, {eval E1 V1} -> {eval E2 V2} -> {eval (app V1 V2) V} ->
  {eval (app E1 E2) V}.


  ============================
   forall E1 E2 V1 V2 V, {eval E1 V1} -> {eval E2 V2} ->
     {eval (app V1 V2) V} -> {eval (app E1 E2) V}

eval_app_trans < intros.

  Variables: E1, E2, V1, V2, V
  H1 : {eval E1 V1}
  H2 : {eval E2 V2}
  H3 : {eval (app V1 V2) V}
  ============================
   {eval (app E1 E2) V}

eval_app_trans < case H3.

  Variables: E1, E2, V1, V2, V, V3, F
  H1 : {eval E1 V1}
  H2 : {eval E2 V2}
  H4 : {eval V1 (abs F)}
  H5 : {eval V2 V3}
  H6 : {eval (F V3) V}
  ============================
   {eval (app E1 E2) V}

eval_app_trans < apply eval_trans to H1 H4.

  Variables: E1, E2, V1, V2, V, V3, F
  H1 : {eval E1 V1}
  H2 : {eval E2 V2}
  H4 : {eval V1 (abs F)}
  H5 : {eval V2 V3}
  H6 : {eval (F V3) V}
  H7 : {eval E1 (abs F)}
  ============================
   {eval (app E1 E2) V}

eval_app_trans < apply eval_trans to H2 H5.

  Variables: E1, E2, V1, V2, V, V3, F
  H1 : {eval E1 V1}
  H2 : {eval E2 V2}
  H4 : {eval V1 (abs F)}
  H5 : {eval V2 V3}
  H6 : {eval (F V3) V}
  H7 : {eval E1 (abs F)}
  H8 : {eval E2 V3}
  ============================
   {eval (app E1 E2) V}

eval_app_trans < search.
Proof completed.

Abella < Theorem val_evalcc : 
forall V, {cval V} -> {evalcc V V}.


  ============================
   forall V, {cval V} -> {evalcc V V}

val_evalcc < induction on 1.


  IH : forall V, {cval V}* -> {evalcc V V}
  ============================
   forall V, {cval V}@ -> {evalcc V V}

val_evalcc < intros.

  Variables: V
  IH : forall V, {cval V}* -> {evalcc V V}
  H1 : {cval V}@
  ============================
   {evalcc V V}

val_evalcc < case H1.
Subgoal 1:

  Variables: V
  IH : forall V, {cval V}* -> {evalcc V V}
  ============================
   {evalcc unit unit}

Subgoal 2 is:
 {evalcc (cross V1 V2) (cross V1 V2)}

Subgoal 3 is:
 {evalcc (clnat Num) (clnat Num)}

Subgoal 4 is:
 {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < search.
Subgoal 2:

  Variables: V, V2, V1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval V1}*
  H3 : {cval V2}*
  ============================
   {evalcc (cross V1 V2) (cross V1 V2)}

Subgoal 3 is:
 {evalcc (clnat Num) (clnat Num)}

Subgoal 4 is:
 {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < apply IH to H2.
Subgoal 2:

  Variables: V, V2, V1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval V1}*
  H3 : {cval V2}*
  H4 : {evalcc V1 V1}
  ============================
   {evalcc (cross V1 V2) (cross V1 V2)}

Subgoal 3 is:
 {evalcc (clnat Num) (clnat Num)}

Subgoal 4 is:
 {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < apply IH to H3.
Subgoal 2:

  Variables: V, V2, V1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval V1}*
  H3 : {cval V2}*
  H4 : {evalcc V1 V1}
  H5 : {evalcc V2 V2}
  ============================
   {evalcc (cross V1 V2) (cross V1 V2)}

Subgoal 3 is:
 {evalcc (clnat Num) (clnat Num)}

Subgoal 4 is:
 {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < search.
Subgoal 3:

  Variables: V, Num
  IH : forall V, {cval V}* -> {evalcc V V}
  ============================
   {evalcc (clnat Num) (clnat Num)}

Subgoal 4 is:
 {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < search.
Subgoal 4:

  Variables: V, F
  IH : forall V, {cval V}* -> {evalcc V V}
  ============================
   {evalcc (cabs F) (cabs F)}

Subgoal 5 is:
 {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < search.
Subgoal 5:

  Variables: V, N2, N1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval N1}*
  H3 : {cval N2}*
  ============================
   {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < apply IH to H2.
Subgoal 5:

  Variables: V, N2, N1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval N1}*
  H3 : {cval N2}*
  H4 : {evalcc N1 N1}
  ============================
   {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < apply IH to H3.
Subgoal 5:

  Variables: V, N2, N1
  IH : forall V, {cval V}* -> {evalcc V V}
  H2 : {cval N1}*
  H3 : {cval N2}*
  H4 : {evalcc N1 N1}
  H5 : {evalcc N2 N2}
  ============================
   {evalcc (cpair N1 N2) (cpair N1 N2)}

val_evalcc < search.
Proof completed.

Abella < Theorem val_evalcc_refl : 
forall V M, {cval V} -> {evalcc V M} -> V = M.


  ============================
   forall V M, {cval V} -> {evalcc V M} -> V = M

val_evalcc_refl < induction on 1.


  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  ============================
   forall V M, {cval V}@ -> {evalcc V M} -> V = M

val_evalcc_refl < intros.

  Variables: V, M
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H1 : {cval V}@
  H2 : {evalcc V M}
  ============================
   V = M

val_evalcc_refl < case H1.
Subgoal 1:

  Variables: V, M
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H2 : {evalcc unit M}
  ============================
   unit = M

Subgoal 2 is:
 cross V1 V2 = M

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < case H2.
Subgoal 1:

  Variables: V, M
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  ============================
   unit = unit

Subgoal 2 is:
 cross V1 V2 = M

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < search.
Subgoal 2:

  Variables: V, M, V2, V1
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H2 : {evalcc (cross V1 V2) M}
  H3 : {cval V1}*
  H4 : {cval V2}*
  ============================
   cross V1 V2 = M

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < case H2.
Subgoal 2:

  Variables: V, M, V2, V1, ML', M'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval V1}*
  H4 : {cval V2}*
  H5 : {evalcc V1 M'}
  H6 : {evalcc V2 ML'}
  ============================
   cross V1 V2 = cross M' ML'

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < apply IH to H3 H5.
Subgoal 2:

  Variables: V, M, V2, V1, ML', M'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval M'}*
  H4 : {cval V2}*
  H5 : {evalcc M' M'}
  H6 : {evalcc V2 ML'}
  ============================
   cross M' V2 = cross M' ML'

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < apply IH to H4 H6.
Subgoal 2:

  Variables: V, M, V2, V1, ML', M'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval M'}*
  H4 : {cval ML'}*
  H5 : {evalcc M' M'}
  H6 : {evalcc ML' ML'}
  ============================
   cross M' ML' = cross M' ML'

Subgoal 3 is:
 clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < search.
Subgoal 3:

  Variables: V, M, Num
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H2 : {evalcc (clnat Num) M}
  ============================
   clnat Num = M

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < case H2.
Subgoal 3:

  Variables: V, M, Num
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  ============================
   clnat Num = clnat Num

Subgoal 4 is:
 cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < search.
Subgoal 4:

  Variables: V, M, F
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H2 : {evalcc (cabs F) M}
  ============================
   cabs F = M

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < case H2.
Subgoal 4:

  Variables: V, M, F
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  ============================
   cabs F = cabs F

Subgoal 5 is:
 cpair N1 N2 = M

val_evalcc_refl < search.
Subgoal 5:

  Variables: V, M, N2, N1
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H2 : {evalcc (cpair N1 N2) M}
  H3 : {cval N1}*
  H4 : {cval N2}*
  ============================
   cpair N1 N2 = M

val_evalcc_refl < case H2.
Subgoal 5:

  Variables: V, M, N2, N1, E', F'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval N1}*
  H4 : {cval N2}*
  H5 : {evalcc N1 F'}
  H6 : {evalcc N2 E'}
  ============================
   cpair N1 N2 = cpair F' E'

val_evalcc_refl < apply IH to H3 H5.
Subgoal 5:

  Variables: V, M, N2, N1, E', F'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval F'}*
  H4 : {cval N2}*
  H5 : {evalcc F' F'}
  H6 : {evalcc N2 E'}
  ============================
   cpair F' N2 = cpair F' E'

val_evalcc_refl < apply IH to H4 H6.
Subgoal 5:

  Variables: V, M, N2, N1, E', F'
  IH : forall V M, {cval V}* -> {evalcc V M} -> V = M
  H3 : {cval F'}*
  H4 : {cval E'}*
  H5 : {evalcc F' F'}
  H6 : {evalcc E' E'}
  ============================
   cpair F' E' = cpair F' E'

val_evalcc_refl < search.
Proof completed.

Abella < Theorem evalcc_val : 
forall M M', {evalcc M M'} -> {cval M'}.


  ============================
   forall M M', {evalcc M M'} -> {cval M'}

evalcc_val < induction on 1.


  IH : forall M M', {evalcc M M'}* -> {cval M'}
  ============================
   forall M M', {evalcc M M'}@ -> {cval M'}

evalcc_val < intros.

  Variables: M, M'
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H1 : {evalcc M M'}@
  ============================
   {cval M'}

evalcc_val < case H1.
Subgoal 1:

  Variables: M, M'
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  ============================
   {cval unit}

Subgoal 2 is:
 {cval (cross M'1 ML')}

Subgoal 3 is:
 {cval (clnat N)}

Subgoal 4 is:
 {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < search.
Subgoal 2:

  Variables: M, M', ML', ML, M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc ML ML'}*
  ============================
   {cval (cross M'1 ML')}

Subgoal 3 is:
 {cval (clnat N)}

Subgoal 4 is:
 {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < apply IH to H2.
Subgoal 2:

  Variables: M, M', ML', ML, M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc ML ML'}*
  H4 : {cval M'1}
  ============================
   {cval (cross M'1 ML')}

Subgoal 3 is:
 {cval (clnat N)}

Subgoal 4 is:
 {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < apply IH to H3.
Subgoal 2:

  Variables: M, M', ML', ML, M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc ML ML'}*
  H4 : {cval M'1}
  H5 : {cval ML'}
  ============================
   {cval (cross M'1 ML')}

Subgoal 3 is:
 {cval (clnat N)}

Subgoal 4 is:
 {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < search.
Subgoal 3:

  Variables: M, M', N
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  ============================
   {cval (clnat N)}

Subgoal 4 is:
 {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < search.
Subgoal 4:

  Variables: M, M', M'1, F, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc (F M'1) M'}*
  ============================
   {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < apply IH to H2.
Subgoal 4:

  Variables: M, M', M'1, F, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc (F M'1) M'}*
  H4 : {cval M'1}
  ============================
   {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < apply IH to H3.
Subgoal 4:

  Variables: M, M', M'1, F, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 M'1}*
  H3 : {evalcc (F M'1) M'}*
  H4 : {cval M'1}
  H5 : {cval M'}
  ============================
   {cval M'}

Subgoal 5 is:
 {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < search.
Subgoal 5:

  Variables: M, M', ML', M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M' ML')}*
  ============================
   {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < apply IH to H2.
Subgoal 5:

  Variables: M, M', ML', M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M' ML')}*
  H3 : {cval (cross M' ML')}
  ============================
   {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < case H3.
Subgoal 5:

  Variables: M, M', ML', M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M' ML')}*
  H4 : {cval M'}
  H5 : {cval ML'}
  ============================
   {cval M'}

Subgoal 6 is:
 {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < search.
Subgoal 6:

  Variables: M, M', M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M'1 M')}*
  ============================
   {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < apply IH to H2.
Subgoal 6:

  Variables: M, M', M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M'1 M')}*
  H3 : {cval (cross M'1 M')}
  ============================
   {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < case H3.
Subgoal 6:

  Variables: M, M', M'1, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cross M'1 M')}*
  H4 : {cval M'1}
  H5 : {cval M'}
  ============================
   {cval M'}

Subgoal 7 is:
 {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < search.
Subgoal 7:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cabs F)}*
  H3 : {evalcc M2 V2}*
  H4 : {evalcc (F V2) M'}*
  ============================
   {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < apply IH to H4.
Subgoal 7:

  Variables: M, M', V2, F, M2, M1
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc M1 (cabs F)}*
  H3 : {evalcc M2 V2}*
  H4 : {evalcc (F V2) M'}*
  H5 : {cval M'}
  ============================
   {cval M'}

Subgoal 8 is:
 {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < search.
Subgoal 8:

  Variables: M, M', F
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  ============================
   {cval (cabs F)}

Subgoal 9 is:
 {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < search.
Subgoal 9:

  Variables: M, M', E', E, F', F
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc F F'}*
  H3 : {evalcc E E'}*
  ============================
   {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < apply IH to H2.
Subgoal 9:

  Variables: M, M', E', E, F', F
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc F F'}*
  H3 : {evalcc E E'}*
  H4 : {cval F'}
  ============================
   {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < apply IH to H3.
Subgoal 9:

  Variables: M, M', E', E, F', F
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc F F'}*
  H3 : {evalcc E E'}*
  H4 : {cval F'}
  H5 : {cval E'}
  ============================
   {cval (cpair F' E')}

Subgoal 10 is:
 {cval M'}

evalcc_val < search.
Subgoal 10:

  Variables: M, M', E, F, B, PPE'
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc PPE' (cpair F E)}*
  H3 : {evalcc (B F E) M'}*
  ============================
   {cval M'}

evalcc_val < apply IH to H3.
Subgoal 10:

  Variables: M, M', E, F, B, PPE'
  IH : forall M M', {evalcc M M'}* -> {cval M'}
  H2 : {evalcc PPE' (cpair F E)}*
  H3 : {evalcc (B F E) M'}*
  H4 : {cval M'}
  ============================
   {cval M'}

evalcc_val < search.
Proof completed.

Abella < Theorem evalcc_trans : 
forall M1 M2 M3, {evalcc M1 M2} -> {evalcc M2 M3} -> {evalcc M1 M3}.


  ============================
   forall M1 M2 M3, {evalcc M1 M2} -> {evalcc M2 M3} -> {evalcc M1 M3}

evalcc_trans < intros.

  Variables: M1, M2, M3
  H1 : {evalcc M1 M2}
  H2 : {evalcc M2 M3}
  ============================
   {evalcc M1 M3}

evalcc_trans < apply evalcc_val to H1.

  Variables: M1, M2, M3
  H1 : {evalcc M1 M2}
  H2 : {evalcc M2 M3}
  H3 : {cval M2}
  ============================
   {evalcc M1 M3}

evalcc_trans < apply val_evalcc_refl to H3 H2.

  Variables: M1, M2, M3
  H1 : {evalcc M1 M3}
  H2 : {evalcc M3 M3}
  H3 : {cval M3}
  ============================
   {evalcc M1 M3}

evalcc_trans < search.
Proof completed.

Abella < Theorem evalcc_det : 
forall E V V', {evalcc E V} -> {evalcc E V'} -> V = V'.


  ============================
   forall E V V', {evalcc E V} -> {evalcc E V'} -> V = V'

evalcc_det < induction on 1.


  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  ============================
   forall E V V', {evalcc E V}@ -> {evalcc E V'} -> V = V'

evalcc_det < intros.

  Variables: E, V, V'
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H1 : {evalcc E V}@
  H2 : {evalcc E V'}
  ============================
   V = V'

evalcc_det < case H1.
Subgoal 1:

  Variables: E, V, V'
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc unit V'}
  ============================
   unit = V'

Subgoal 2 is:
 cross M' ML' = V'

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < case H2.
Subgoal 1:

  Variables: E, V, V'
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  ============================
   unit = unit

Subgoal 2 is:
 cross M' ML' = V'

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < search.
Subgoal 2:

  Variables: E, V, V', ML', ML, M', M
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (cross M ML) V'}
  H3 : {evalcc M M'}*
  H4 : {evalcc ML ML'}*
  ============================
   cross M' ML' = V'

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < case H2.
Subgoal 2:

  Variables: E, V, V', ML', ML, M', M, ML'1, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'}*
  H4 : {evalcc ML ML'}*
  H5 : {evalcc M M'1}
  H6 : {evalcc ML ML'1}
  ============================
   cross M' ML' = cross M'1 ML'1

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < apply IH to H3 H5.
Subgoal 2:

  Variables: E, V, V', ML', ML, M', M, ML'1, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'1}*
  H4 : {evalcc ML ML'}*
  H5 : {evalcc M M'1}
  H6 : {evalcc ML ML'1}
  ============================
   cross M'1 ML' = cross M'1 ML'1

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < apply IH to H4 H6.
Subgoal 2:

  Variables: E, V, V', ML', ML, M', M, ML'1, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'1}*
  H4 : {evalcc ML ML'1}*
  H5 : {evalcc M M'1}
  H6 : {evalcc ML ML'1}
  ============================
   cross M'1 ML'1 = cross M'1 ML'1

Subgoal 3 is:
 clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < search.
Subgoal 3:

  Variables: E, V, V', N
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (clnat N) V'}
  ============================
   clnat N = V'

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < case H2.
Subgoal 3:

  Variables: E, V, V', N
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  ============================
   clnat N = clnat N

Subgoal 4 is:
 V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < search.
Subgoal 4:

  Variables: E, V, V', M', F, M
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (clet M F) V'}
  H3 : {evalcc M M'}*
  H4 : {evalcc (F M') V}*
  ============================
   V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < case H2.
Subgoal 4:

  Variables: E, V, V', M', F, M, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'}*
  H4 : {evalcc (F M') V}*
  H5 : {evalcc M M'1}
  H6 : {evalcc (F M'1) V'}
  ============================
   V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < apply IH to H3 H5.
Subgoal 4:

  Variables: E, V, V', M', F, M, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'1}*
  H4 : {evalcc (F M'1) V}*
  H5 : {evalcc M M'1}
  H6 : {evalcc (F M'1) V'}
  ============================
   V = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < apply IH to H4 H6.
Subgoal 4:

  Variables: E, V, V', M', F, M, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M M'1}*
  H4 : {evalcc (F M'1) V'}*
  H5 : {evalcc M M'1}
  H6 : {evalcc (F M'1) V'}
  ============================
   V' = V'

Subgoal 5 is:
 V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < search.
Subgoal 5:

  Variables: E, V, V', ML', M
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (fst M) V'}
  H3 : {evalcc M (cross V ML')}*
  ============================
   V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < case H2.
Subgoal 5:

  Variables: E, V, V', ML', M, ML'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M (cross V ML')}*
  H4 : {evalcc M (cross V' ML'1)}
  ============================
   V = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < apply IH to H3 H4.
Subgoal 5:

  Variables: E, V, V', ML', M, ML'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M (cross V' ML'1)}*
  H4 : {evalcc M (cross V' ML'1)}
  ============================
   V' = V'

Subgoal 6 is:
 V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < search.
Subgoal 6:

  Variables: E, V, V', M', M
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (rst M) V'}
  H3 : {evalcc M (cross M' V)}*
  ============================
   V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < case H2.
Subgoal 6:

  Variables: E, V, V', M', M, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M (cross M' V)}*
  H4 : {evalcc M (cross M'1 V')}
  ============================
   V = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < apply IH to H3 H4.
Subgoal 6:

  Variables: E, V, V', M', M, M'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M (cross M'1 V')}*
  H4 : {evalcc M (cross M'1 V')}
  ============================
   V' = V'

Subgoal 7 is:
 V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < search.
Subgoal 7:

  Variables: E, V, V', V2, F, M2, M1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (capp M1 M2) V'}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) V}*
  ============================
   V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < case H2.
Subgoal 7:

  Variables: E, V, V', V2, F, M2, M1, V1, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) V}*
  H6 : {evalcc M1 (cabs F1)}
  H7 : {evalcc M2 V1}
  H8 : {evalcc (F1 V1) V'}
  ============================
   V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < apply IH to H3 H6.
Subgoal 7:

  Variables: E, V, V', V2, F, M2, M1, V1, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M1 (cabs F1)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F1 V2) V}*
  H6 : {evalcc M1 (cabs F1)}
  H7 : {evalcc M2 V1}
  H8 : {evalcc (F1 V1) V'}
  ============================
   V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < apply IH to H4 H7.
Subgoal 7:

  Variables: E, V, V', V2, F, M2, M1, V1, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M1 (cabs F1)}*
  H4 : {evalcc M2 V1}*
  H5 : {evalcc (F1 V1) V}*
  H6 : {evalcc M1 (cabs F1)}
  H7 : {evalcc M2 V1}
  H8 : {evalcc (F1 V1) V'}
  ============================
   V = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < apply IH to H5 H8.
Subgoal 7:

  Variables: E, V, V', V2, F, M2, M1, V1, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc M1 (cabs F1)}*
  H4 : {evalcc M2 V1}*
  H5 : {evalcc (F1 V1) V'}*
  H6 : {evalcc M1 (cabs F1)}
  H7 : {evalcc M2 V1}
  H8 : {evalcc (F1 V1) V'}
  ============================
   V' = V'

Subgoal 8 is:
 cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < search.
Subgoal 8:

  Variables: E, V, V', F
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (cabs F) V'}
  ============================
   cabs F = V'

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < case H2.
Subgoal 8:

  Variables: E, V, V', F
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  ============================
   cabs F = cabs F

Subgoal 9 is:
 cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < search.
Subgoal 9:

  Variables: E, V, V', E', E1, F', F
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (cpair F E1) V'}
  H3 : {evalcc F F'}*
  H4 : {evalcc E1 E'}*
  ============================
   cpair F' E' = V'

Subgoal 10 is:
 V = V'

evalcc_det < case H2.
Subgoal 9:

  Variables: E, V, V', E', E1, F', F, E'1, F'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc F F'}*
  H4 : {evalcc E1 E'}*
  H5 : {evalcc F F'1}
  H6 : {evalcc E1 E'1}
  ============================
   cpair F' E' = cpair F'1 E'1

Subgoal 10 is:
 V = V'

evalcc_det < apply IH to H3 H5.
Subgoal 9:

  Variables: E, V, V', E', E1, F', F, E'1, F'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc F F'1}*
  H4 : {evalcc E1 E'}*
  H5 : {evalcc F F'1}
  H6 : {evalcc E1 E'1}
  ============================
   cpair F'1 E' = cpair F'1 E'1

Subgoal 10 is:
 V = V'

evalcc_det < apply IH to H4 H6.
Subgoal 9:

  Variables: E, V, V', E', E1, F', F, E'1, F'1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc F F'1}*
  H4 : {evalcc E1 E'1}*
  H5 : {evalcc F F'1}
  H6 : {evalcc E1 E'1}
  ============================
   cpair F'1 E'1 = cpair F'1 E'1

Subgoal 10 is:
 V = V'

evalcc_det < search.
Subgoal 10:

  Variables: E, V, V', E1, F, B, PPE'
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H2 : {evalcc (cunpair PPE' B) V'}
  H3 : {evalcc PPE' (cpair F E1)}*
  H4 : {evalcc (B F E1) V}*
  ============================
   V = V'

evalcc_det < case H2.
Subgoal 10:

  Variables: E, V, V', E1, F, B, PPE', E2, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc PPE' (cpair F E1)}*
  H4 : {evalcc (B F E1) V}*
  H5 : {evalcc PPE' (cpair F1 E2)}
  H6 : {evalcc (B F1 E2) V'}
  ============================
   V = V'

evalcc_det < apply IH to H3 H5.
Subgoal 10:

  Variables: E, V, V', E1, F, B, PPE', E2, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc PPE' (cpair F1 E2)}*
  H4 : {evalcc (B F1 E2) V}*
  H5 : {evalcc PPE' (cpair F1 E2)}
  H6 : {evalcc (B F1 E2) V'}
  ============================
   V = V'

evalcc_det < apply IH to H4 H6.
Subgoal 10:

  Variables: E, V, V', E1, F, B, PPE', E2, F1
  IH : forall E V V', {evalcc E V}* -> {evalcc E V'} -> V = V'
  H3 : {evalcc PPE' (cpair F1 E2)}*
  H4 : {evalcc (B F1 E2) V'}*
  H5 : {evalcc PPE' (cpair F1 E2)}
  H6 : {evalcc (B F1 E2) V'}
  ============================
   V' = V'

evalcc_det < search.
Proof completed.

Abella < Theorem env_elem_aux_eval_cong : 
forall E E1 E2 V V', env_elem_aux E -> {evalcc E1 V} -> {evalcc E2 V} ->
  {evalcc (E E1) V'} -> {evalcc (E E2) V'}.


  ============================
   forall E E1 E2 V V', env_elem_aux E -> {evalcc E1 V} -> {evalcc E2 V} ->
     {evalcc (E E1) V'} -> {evalcc (E E2) V'}

env_elem_aux_eval_cong < induction on 1.


  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  ============================
   forall E E1 E2 V V', env_elem_aux E @ -> {evalcc E1 V} -> {evalcc E2 V} ->
     {evalcc (E E1) V'} -> {evalcc (E E2) V'}

env_elem_aux_eval_cong < intros.

  Variables: E, E1, E2, V, V'
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H1 : env_elem_aux E @
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H4 : {evalcc (E E1) V'}
  ============================
   {evalcc (E E2) V'}

env_elem_aux_eval_cong < case H1.
Subgoal 1:

  Variables: E, E1, E2, V, V'
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H4 : {evalcc E1 V'}
  ============================
   {evalcc E2 V'}

Subgoal 2 is:
 {evalcc (rst (R E2)) V'}

env_elem_aux_eval_cong < apply evalcc_det to H2 H4.
Subgoal 1:

  Variables: E, E1, E2, V, V'
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H2 : {evalcc E1 V'}
  H3 : {evalcc E2 V'}
  H4 : {evalcc E1 V'}
  ============================
   {evalcc E2 V'}

Subgoal 2 is:
 {evalcc (rst (R E2)) V'}

env_elem_aux_eval_cong < search.
Subgoal 2:

  Variables: E, E1, E2, V, V', R
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H4 : {evalcc (rst (R E1)) V'}
  H5 : env_elem_aux R *
  ============================
   {evalcc (rst (R E2)) V'}

env_elem_aux_eval_cong < case H4.
Subgoal 2:

  Variables: E, E1, E2, V, V', R, M'
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H5 : env_elem_aux R *
  H6 : {evalcc (R E1) (cross M' V')}
  ============================
   {evalcc (rst (R E2)) V'}

env_elem_aux_eval_cong < apply IH to H5 H2 H3 H6.
Subgoal 2:

  Variables: E, E1, E2, V, V', R, M'
  IH : forall E E1 E2 V V', env_elem_aux E * -> {evalcc E1 V} ->
         {evalcc E2 V} -> {evalcc (E E1) V'} -> {evalcc (E E2) V'}
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H5 : env_elem_aux R *
  H6 : {evalcc (R E1) (cross M' V')}
  H7 : {evalcc (R E2) (cross M' V')}
  ============================
   {evalcc (rst (R E2)) V'}

env_elem_aux_eval_cong < search.
Proof completed.

Abella < Theorem env_elem_eval_cong : 
forall E E1 E2 V V', env_elem E -> {evalcc E1 V} -> {evalcc E2 V} ->
  {evalcc (E E1) V'} -> {evalcc (E E2) V'}.


  ============================
   forall E E1 E2 V V', env_elem E -> {evalcc E1 V} -> {evalcc E2 V} ->
     {evalcc (E E1) V'} -> {evalcc (E E2) V'}

env_elem_eval_cong < intros.

  Variables: E, E1, E2, V, V'
  H1 : env_elem E
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H4 : {evalcc (E E1) V'}
  ============================
   {evalcc (E E2) V'}

env_elem_eval_cong < case H1.

  Variables: E, E1, E2, V, V', R
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H4 : {evalcc (fst (R E1)) V'}
  H5 : env_elem_aux R
  ============================
   {evalcc (fst (R E2)) V'}

env_elem_eval_cong < case H4.

  Variables: E, E1, E2, V, V', R, ML'
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H5 : env_elem_aux R
  H6 : {evalcc (R E1) (cross V' ML')}
  ============================
   {evalcc (fst (R E2)) V'}

env_elem_eval_cong < apply env_elem_aux_eval_cong to H5 H2 H3 H6.

  Variables: E, E1, E2, V, V', R, ML'
  H2 : {evalcc E1 V}
  H3 : {evalcc E2 V}
  H5 : env_elem_aux R
  H6 : {evalcc (R E1) (cross V' ML')}
  H7 : {evalcc (R E2) (cross V' ML')}
  ============================
   {evalcc (fst (R E2)) V'}

env_elem_eval_cong < search.
Proof completed.

Abella < Theorem evalcc_ctm_pres : 
forall M N, {evalcc M N} -> {ctm M} -> {ctm N}.


  ============================
   forall M N, {evalcc M N} -> {ctm M} -> {ctm N}

evalcc_ctm_pres < induction on 1.


  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  ============================
   forall M N, {evalcc M N}@ -> {ctm M} -> {ctm N}

evalcc_ctm_pres < intros.

  Variables: M, N
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H1 : {evalcc M N}@
  H2 : {ctm M}
  ============================
   {ctm N}

evalcc_ctm_pres < case H1.
Subgoal 1:

  Variables: M, N
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm unit}
  ============================
   {ctm unit}

Subgoal 2 is:
 {ctm (cross M' ML')}

Subgoal 3 is:
 {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < search.
Subgoal 2:

  Variables: M, N, ML', ML, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (cross M1 ML)}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc ML ML'}*
  ============================
   {ctm (cross M' ML')}

Subgoal 3 is:
 {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < case H2.
Subgoal 2:

  Variables: M, N, ML', ML, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc ML ML'}*
  H5 : {ctm M1}
  H6 : {ctm ML}
  ============================
   {ctm (cross M' ML')}

Subgoal 3 is:
 {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < apply IH to H3 H5.
Subgoal 2:

  Variables: M, N, ML', ML, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc ML ML'}*
  H5 : {ctm M1}
  H6 : {ctm ML}
  H7 : {ctm M'}
  ============================
   {ctm (cross M' ML')}

Subgoal 3 is:
 {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < apply IH to H4 H6.
Subgoal 2:

  Variables: M, N, ML', ML, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc ML ML'}*
  H5 : {ctm M1}
  H6 : {ctm ML}
  H7 : {ctm M'}
  H8 : {ctm ML'}
  ============================
   {ctm (cross M' ML')}

Subgoal 3 is:
 {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < search.
Subgoal 3:

  Variables: M, N, N1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (clnat N1)}
  ============================
   {ctm (clnat N1)}

Subgoal 4 is:
 {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < search.
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (clet M1 F)}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < case H2.
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  H5 : {ctm M1}
  H6 : {ctm n1 |- ctm (F n1)}
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < apply IH to H3 H5.
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  H5 : {ctm M1}
  H6 : {ctm n1 |- ctm (F n1)}
  H7 : {ctm M'}
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < inst H6 with n1 = M'.
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  H5 : {ctm M1}
  H6 : {ctm n1 |- ctm (F n1)}
  H7 : {ctm M'}
  H8 : {ctm M' |- ctm (F M')}
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < cut H8 with H7.
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  H5 : {ctm M1}
  H6 : {ctm n1 |- ctm (F n1)}
  H7 : {ctm M'}
  H8 : {ctm M' |- ctm (F M')}
  H9 : {ctm (F M')}
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < apply IH to H4 H9.
Subgoal 4:

  Variables: M, N, M', F, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 M'}*
  H4 : {evalcc (F M') N}*
  H5 : {ctm M1}
  H6 : {ctm n1 |- ctm (F n1)}
  H7 : {ctm M'}
  H8 : {ctm M' |- ctm (F M')}
  H9 : {ctm (F M')}
  H10 : {ctm N}
  ============================
   {ctm N}

Subgoal 5 is:
 {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < search.
Subgoal 5:

  Variables: M, N, ML', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (fst M1)}
  H3 : {evalcc M1 (cross N ML')}*
  ============================
   {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < case H2.
Subgoal 5:

  Variables: M, N, ML', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross N ML')}*
  H4 : {ctm M1}
  ============================
   {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < apply IH to H3 H4.
Subgoal 5:

  Variables: M, N, ML', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross N ML')}*
  H4 : {ctm M1}
  H5 : {ctm (cross N ML')}
  ============================
   {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < case H5.
Subgoal 5:

  Variables: M, N, ML', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross N ML')}*
  H4 : {ctm M1}
  H6 : {ctm N}
  H7 : {ctm ML'}
  ============================
   {ctm N}

Subgoal 6 is:
 {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < search.
Subgoal 6:

  Variables: M, N, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (rst M1)}
  H3 : {evalcc M1 (cross M' N)}*
  ============================
   {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < case H2.
Subgoal 6:

  Variables: M, N, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross M' N)}*
  H4 : {ctm M1}
  ============================
   {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < apply IH to H3 H4.
Subgoal 6:

  Variables: M, N, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross M' N)}*
  H4 : {ctm M1}
  H5 : {ctm (cross M' N)}
  ============================
   {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < case H5.
Subgoal 6:

  Variables: M, N, M', M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cross M' N)}*
  H4 : {ctm M1}
  H6 : {ctm M'}
  H7 : {ctm N}
  ============================
   {ctm N}

Subgoal 7 is:
 {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < search.
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (capp M1 M2)}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < case H2.
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < apply IH to H3 H6.
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H8 : {ctm (cabs F)}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < apply IH to H4 H7.
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H8 : {ctm (cabs F)}
  H9 : {ctm V2}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < case H8.
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H9 : {ctm V2}
  H10 : {ctm n1 |- ctm (F n1)}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < inst H10 with n1 = V2.
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H9 : {ctm V2}
  H10 : {ctm n1 |- ctm (F n1)}
  H11 : {ctm V2 |- ctm (F V2)}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < cut H11 with H9.
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H9 : {ctm V2}
  H10 : {ctm n1 |- ctm (F n1)}
  H11 : {ctm V2 |- ctm (F V2)}
  H12 : {ctm (F V2)}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < apply IH to H5 H12.
Subgoal 7:

  Variables: M, N, V2, F, M2, M1
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc M1 (cabs F)}*
  H4 : {evalcc M2 V2}*
  H5 : {evalcc (F V2) N}*
  H6 : {ctm M1}
  H7 : {ctm M2}
  H9 : {ctm V2}
  H10 : {ctm n1 |- ctm (F n1)}
  H11 : {ctm V2 |- ctm (F V2)}
  H12 : {ctm (F V2)}
  H13 : {ctm N}
  ============================
   {ctm N}

Subgoal 8 is:
 {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < search.
Subgoal 8:

  Variables: M, N, F
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (cabs F)}
  ============================
   {ctm (cabs F)}

Subgoal 9 is:
 {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < search.
Subgoal 9:

  Variables: M, N, E', E, F', F
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (cpair F E)}
  H3 : {evalcc F F'}*
  H4 : {evalcc E E'}*
  ============================
   {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < case H2.
Subgoal 9:

  Variables: M, N, E', E, F', F
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc F F'}*
  H4 : {evalcc E E'}*
  H5 : {ctm F}
  H6 : {ctm E}
  ============================
   {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < apply IH to H3 H5.
Subgoal 9:

  Variables: M, N, E', E, F', F
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc F F'}*
  H4 : {evalcc E E'}*
  H5 : {ctm F}
  H6 : {ctm E}
  H7 : {ctm F'}
  ============================
   {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < apply IH to H4 H6.
Subgoal 9:

  Variables: M, N, E', E, F', F
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc F F'}*
  H4 : {evalcc E E'}*
  H5 : {ctm F}
  H6 : {ctm E}
  H7 : {ctm F'}
  H8 : {ctm E'}
  ============================
   {ctm (cpair F' E')}

Subgoal 10 is:
 {ctm N}

evalcc_ctm_pres < search.
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H2 : {ctm (cunpair PPE' B)}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  ============================
   {ctm N}

evalcc_ctm_pres < case H2.
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  ============================
   {ctm N}

evalcc_ctm_pres < apply IH to H3 H5.
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H7 : {ctm (cpair F E)}
  ============================
   {ctm N}

evalcc_ctm_pres < case H7.
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  ============================
   {ctm N}

evalcc_ctm_pres < inst H6 with n1 = F.
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  H10 : {ctm F, ctm n2 |- ctm (B F n2)}
  ============================
   {ctm N}

evalcc_ctm_pres < inst H10 with n2 = E.
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  H10 : {ctm F, ctm n2 |- ctm (B F n2)}
  H11 : {ctm F, ctm E |- ctm (B F E)}
  ============================
   {ctm N}

evalcc_ctm_pres < cut H11 with H8.
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  H10 : {ctm F, ctm n2 |- ctm (B F n2)}
  H11 : {ctm F, ctm E |- ctm (B F E)}
  H12 : {ctm E |- ctm (B F E)}
  ============================
   {ctm N}

evalcc_ctm_pres < cut H12 with H9.
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  H10 : {ctm F, ctm n2 |- ctm (B F n2)}
  H11 : {ctm F, ctm E |- ctm (B F E)}
  H12 : {ctm E |- ctm (B F E)}
  H13 : {ctm (B F E)}
  ============================
   {ctm N}

evalcc_ctm_pres < apply IH to H4 H13.
Subgoal 10:

  Variables: M, N, E, F, B, PPE'
  IH : forall M N, {evalcc M N}* -> {ctm M} -> {ctm N}
  H3 : {evalcc PPE' (cpair F E)}*
  H4 : {evalcc (B F E) N}*
  H5 : {ctm PPE'}
  H6 : {ctm n1, ctm n2 |- ctm (B n1 n2)}
  H8 : {ctm F}
  H9 : {ctm E}
  H10 : {ctm F, ctm n2 |- ctm (B F n2)}
  H11 : {ctm F, ctm E |- ctm (B F E)}
  H12 : {ctm E |- ctm (B F E)}
  H13 : {ctm (B F E)}
  H14 : {ctm N}
  ============================
   {ctm N}

evalcc_ctm_pres < search.
Proof completed.

Abella < Theorem evalcc_capp_trans : 
forall E V F E1 V1, {evalcc E V} -> {evalcc (capp F (cross V E1)) V1} ->
  {evalcc (capp F (cross E E1)) V1}.


  ============================
   forall E V F E1 V1, {evalcc E V} -> {evalcc (capp F (cross V E1)) V1} ->
     {evalcc (capp F (cross E E1)) V1}

evalcc_capp_trans < intros.

  Variables: E, V, F, E1, V1
  H1 : {evalcc E V}
  H2 : {evalcc (capp F (cross V E1)) V1}
  ============================
   {evalcc (capp F (cross E E1)) V1}

evalcc_capp_trans < case H2.

  Variables: E, V, F, E1, V1, V2, F1
  H1 : {evalcc E V}
  H3 : {evalcc F (cabs F1)}
  H4 : {evalcc (cross V E1) V2}
  H5 : {evalcc (F1 V2) V1}
  ============================
   {evalcc (capp F (cross E E1)) V1}

evalcc_capp_trans < case H4.

  Variables: E, V, F, E1, V1, V2, F1, ML', M'
  H1 : {evalcc E V}
  H3 : {evalcc F (cabs F1)}
  H5 : {evalcc (F1 (cross M' ML')) V1}
  H6 : {evalcc V M'}
  H7 : {evalcc E1 ML'}
  ============================
   {evalcc (capp F (cross E E1)) V1}

evalcc_capp_trans < apply evalcc_trans to H1 H6.

  Variables: E, V, F, E1, V1, V2, F1, ML', M'
  H1 : {evalcc E V}
  H3 : {evalcc F (cabs F1)}
  H5 : {evalcc (F1 (cross M' ML')) V1}
  H6 : {evalcc V M'}
  H7 : {evalcc E1 ML'}
  H8 : {evalcc E M'}
  ============================
   {evalcc (capp F (cross E E1)) V1}

evalcc_capp_trans < search.
Proof completed.

Abella < Define sctx' : olist -> prop by 
sctx' nil;
sctx' (of X T :: L) := sctx' L /\ tname X /\ (forall T', member (of X T') L -> T = T').

Abella < Define cctx' : olist -> prop by 
cctx' nil;
cctx' (cof X T :: L) := cctx' L /\ ctname X /\ (forall T', member (cof X T') L -> T = T').

Abella < Theorem sctx'_name : 
forall X T L, sctx' L -> member (of X T) L -> tname X.


  ============================
   forall X T L, sctx' L -> member (of X T) L -> tname X

sctx'_name < induction on 1.


  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  ============================
   forall X T L, sctx' L @ -> member (of X T) L -> tname X

sctx'_name < intros.

  Variables: X, T, L
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H1 : sctx' L @
  H2 : member (of X T) L
  ============================
   tname X

sctx'_name < case H1.
Subgoal 1:

  Variables: X, T, L
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H2 : member (of X T) nil
  ============================
   tname X

Subgoal 2 is:
 tname X

sctx'_name < case H2.
Subgoal 2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H2 : member (of X T) (of X1 T1 :: L1)
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   tname X

sctx'_name < case H2.
Subgoal 2.1:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

sctx'_name < search.
Subgoal 2.2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  H6 : member (of X T) L1
  ============================
   tname X

sctx'_name < apply IH to H3 H6.
Subgoal 2.2:

  Variables: X, T, L, L1, T1, X1
  IH : forall X T L, sctx' L * -> member (of X T) L -> tname X
  H3 : sctx' L1 *
  H4 : tname X1
  H5 : forall T', member (of X1 T') L1 -> T1 = T'
  H6 : member (of X T) L1
  H7 : tname X
  ============================
   tname X

sctx'_name < search.
Proof completed.

Abella < Theorem sctx'_mem : 
forall SL O, sctx' SL -> member O SL -> (exists X T, O = of X T /\ tname X).


  ============================
   forall SL O, sctx' SL -> member O SL -> (exists X T, O = of X T /\
     tname X)

sctx'_mem < induction on 1.


  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  ============================
   forall SL O, sctx' SL @ -> member O SL -> (exists X T, O = of X T /\
     tname X)

sctx'_mem < intros.

  Variables: SL, O
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H1 : sctx' SL @
  H2 : member O SL
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < case H1.
Subgoal 1:

  Variables: SL, O
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H2 : member O nil
  ============================
   exists X T, O = of X T /\ tname X

Subgoal 2 is:
 exists X T, O = of X T /\ tname X

sctx'_mem < case H2.
Subgoal 2:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H2 : member O (of X T :: L)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < case H2.
Subgoal 2.1:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  ============================
   exists X1 T1, of X T = of X1 T1 /\ tname X1

Subgoal 2.2 is:
 exists X T, O = of X T /\ tname X

sctx'_mem < search.
Subgoal 2.2:

  Variables: SL, O, L, T, X
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  H6 : member O L
  ============================
   exists X T, O = of X T /\ tname X

sctx'_mem < apply IH to H3 H6.
Subgoal 2.2:

  Variables: SL, O, L, T, X, X1, T1
  IH : forall SL O, sctx' SL * -> member O SL -> (exists X T, O = of X T /\
         tname X)
  H3 : sctx' L *
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  H6 : member (of X1 T1) L
  H7 : tname X1
  ============================
   exists X T, of X1 T1 = of X T /\ tname X

sctx'_mem < search.
Proof completed.

Abella < Theorem sctx'_extend : 
forall L T, nabla x, sctx' L -> sctx' (of x T :: L).


  ============================
   forall L T, nabla x, sctx' L -> sctx' (of x T :: L)

sctx'_extend < intros.

  Variables: L, T
  H1 : sctx' L
  ============================
   sctx' (of n1 T :: L)

sctx'_extend < unfold.
Subgoal 1:

  Variables: L, T
  H1 : sctx' L
  ============================
   sctx' L

Subgoal 2 is:
 tname n1

Subgoal 3 is:
 forall T', member (of n1 T') L -> T = T'

sctx'_extend < search.
Subgoal 2:

  Variables: L, T
  H1 : sctx' L
  ============================
   tname n1

Subgoal 3 is:
 forall T', member (of n1 T') L -> T = T'

sctx'_extend < search.
Subgoal 3:

  Variables: L, T
  H1 : sctx' L
  ============================
   forall T', member (of n1 T') L -> T = T'

sctx'_extend < intros.
Subgoal 3:

  Variables: L, T, T'
  H1 : sctx' L
  H2 : member (of n1 T') L
  ============================
   T = T'

sctx'_extend < apply mem_of_absurd to H2.
Proof completed.

Abella < Theorem sctx'_equal : 
forall L X T T', sctx' L -> member (of X T) L -> member (of X T') L -> T = T'.


  ============================
   forall L X T T', sctx' L -> member (of X T) L -> member (of X T') L ->
     T = T'

sctx'_equal < induction on 1.


  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  ============================
   forall L X T T', sctx' L @ -> member (of X T) L -> member (of X T') L ->
     T = T'

sctx'_equal < intros.

  Variables: L, X, T, T'
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H1 : sctx' L @
  H2 : member (of X T) L
  H3 : member (of X T') L
  ============================
   T = T'

sctx'_equal < case H1.
Subgoal 1:

  Variables: L, X, T, T'
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H2 : member (of X T) nil
  H3 : member (of X T') nil
  ============================
   T = T'

Subgoal 2 is:
 T = T'

sctx'_equal < case H2.
Subgoal 2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H2 : member (of X T) (of X1 T1 :: L1)
  H3 : member (of X T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T = T'

sctx'_equal < case H2.
Subgoal 2.1:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H3 : member (of X1 T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < case H3.
Subgoal 2.1.1:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  ============================
   T1 = T1

Subgoal 2.1.2 is:
 T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < search.
Subgoal 2.1.2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X1 T') L1
  ============================
   T1 = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < apply H6 to H7.
Subgoal 2.1.2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T'1, member (of X1 T'1) L1 -> T' = T'1
  H7 : member (of X1 T') L1
  ============================
   T' = T'

Subgoal 2.2 is:
 T = T'

sctx'_equal < search.
Subgoal 2.2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H3 : member (of X T') (of X1 T1 :: L1)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T) L1
  ============================
   T = T'

sctx'_equal < case H3.
Subgoal 2.2.1:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X1 T) L1
  ============================
   T = T1

Subgoal 2.2.2 is:
 T = T'

sctx'_equal < apply H6 to H7.
Subgoal 2.2.1:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  H7 : member (of X1 T) L1
  ============================
   T = T

Subgoal 2.2.2 is:
 T = T'

sctx'_equal < search.
Subgoal 2.2.2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T) L1
  H8 : member (of X T') L1
  ============================
   T = T'

sctx'_equal < apply IH to H4 H7 H8.
Subgoal 2.2.2:

  Variables: L, X, T, T', L1, T1, X1
  IH : forall L X T T', sctx' L * -> member (of X T) L ->
         member (of X T') L -> T = T'
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T1 = T'
  H7 : member (of X T') L1
  H8 : member (of X T') L1
  ============================
   T' = T'

sctx'_equal < search.
Proof completed.

Abella < Theorem cctx'_mem : 
forall SL O, cctx' SL -> member O SL -> (exists X T, O = cof X T /\ ctname X).


  ============================
   forall SL O, cctx' SL -> member O SL -> (exists X T, O = cof X T /\
     ctname X)

cctx'_mem < induction on 1.


  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  ============================
   forall SL O, cctx' SL @ -> member O SL -> (exists X T, O = cof X T /\
     ctname X)

cctx'_mem < intros.

  Variables: SL, O
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H1 : cctx' SL @
  H2 : member O SL
  ============================
   exists X T, O = cof X T /\ ctname X

cctx'_mem < case H1.
Subgoal 1:

  Variables: SL, O
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H2 : member O nil
  ============================
   exists X T, O = cof X T /\ ctname X

Subgoal 2 is:
 exists X T, O = cof X T /\ ctname X

cctx'_mem < case H2.
Subgoal 2:

  Variables: SL, O, L, T, X
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H2 : member O (cof X T :: L)
  H3 : cctx' L *
  H4 : ctname X
  H5 : forall T', member (cof X T') L -> T = T'
  ============================
   exists X T, O = cof X T /\ ctname X

cctx'_mem < case H2.
Subgoal 2.1:

  Variables: SL, O, L, T, X
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H3 : cctx' L *
  H4 : ctname X
  H5 : forall T', member (cof X T') L -> T = T'
  ============================
   exists X1 T1, cof X T = cof X1 T1 /\ ctname X1

Subgoal 2.2 is:
 exists X T, O = cof X T /\ ctname X

cctx'_mem < search.
Subgoal 2.2:

  Variables: SL, O, L, T, X
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H3 : cctx' L *
  H4 : ctname X
  H5 : forall T', member (cof X T') L -> T = T'
  H6 : member O L
  ============================
   exists X T, O = cof X T /\ ctname X

cctx'_mem < apply IH to H3 H6.
Subgoal 2.2:

  Variables: SL, O, L, T, X, X1, T1
  IH : forall SL O, cctx' SL * -> member O SL -> (exists X T, O = cof X T /\
         ctname X)
  H3 : cctx' L *
  H4 : ctname X
  H5 : forall T', member (cof X T') L -> T = T'
  H6 : member (cof X1 T1) L
  H7 : ctname X1
  ============================
   exists X T, cof X1 T1 = cof X T /\ ctname X

cctx'_mem < search.
Proof completed.

Abella < Theorem cctx'_extend : 
forall L T, nabla x, cctx' L -> cctx' (cof x T :: L).


  ============================
   forall L T, nabla x, cctx' L -> cctx' (cof x T :: L)

cctx'_extend < intros.

  Variables: L, T
  H1 : cctx' L
  ============================
   cctx' (cof n1 T :: L)

cctx'_extend < unfold.
Subgoal 1:

  Variables: L, T
  H1 : cctx' L
  ============================
   cctx' L

Subgoal 2 is:
 ctname n1

Subgoal 3 is:
 forall T', member (cof n1 T') L -> T = T'

cctx'_extend < search.
Subgoal 2:

  Variables: L, T
  H1 : cctx' L
  ============================
   ctname n1

Subgoal 3 is:
 forall T', member (cof n1 T') L -> T = T'

cctx'_extend < search.
Subgoal 3:

  Variables: L, T
  H1 : cctx' L
  ============================
   forall T', member (cof n1 T') L -> T = T'

cctx'_extend < intros.
Subgoal 3:

  Variables: L, T, T'
  H1 : cctx' L
  H2 : member (cof n1 T') L
  ============================
   T = T'

cctx'_extend < apply mem_of_absurd' to H2.
Proof completed.

Abella < Theorem of_mem : 
forall X T L, member (of X T) L -> {L |- of X T}.


  ============================
   forall X T L, member (of X T) L -> {L |- of X T}

of_mem < intros.

  Variables: X, T, L
  H1 : member (of X T) L
  ============================
   {L |- of X T}

of_mem < search.
Proof completed.

Abella < Theorem of_nat : 
forall L N T, sctx' L -> {L |- of (lnat N) T} -> T = nat_t.


  ============================
   forall L N T, sctx' L -> {L |- of (lnat N) T} -> T = nat_t

of_nat < intros.

  Variables: L, N, T
  H1 : sctx' L
  H2 : {L |- of (lnat N) T}
  ============================
   T = nat_t

of_nat < case H2.
Subgoal 1:

  Variables: L, N, T
  H1 : sctx' L
  ============================
   nat_t = nat_t

Subgoal 2 is:
 T = nat_t

of_nat < search.
Subgoal 2:

  Variables: L, N, T, F
  H1 : sctx' L
  H3 : {L, [F] |- of (lnat N) T}
  H4 : member F L
  ============================
   T = nat_t

of_nat < apply sctx'_mem to H1 H4.
Subgoal 2:

  Variables: L, N, T, F, X, T1
  H1 : sctx' L
  H3 : {L, [of X T1] |- of (lnat N) T}
  H4 : member (of X T1) L
  H5 : tname X
  ============================
   T = nat_t

of_nat < case H3.
Subgoal 2:

  Variables: L, N, T, F, X, T1
  H1 : sctx' L
  H4 : member (of (lnat N) T) L
  H5 : tname (lnat N)
  ============================
   T = nat_t

of_nat < case H5.
Proof completed.

Abella < Define sctx'_rst : o -> olist -> olist -> prop by 
nabla x, sctx'_rst (of x T) (of x T :: L) L;
nabla x, sctx'_rst (of x T) (of Y T' :: L x) (of Y T' :: L') := nabla x, sctx'_rst (of x T) (L x) L'.

Abella < Theorem sctx'_rst_mem_str : 
forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' ->
  member (of E T') (L x) -> member (of E T') L'.


  ============================
   forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' ->
     member (of E T') (L x) -> member (of E T') L'

sctx'_rst_mem_str < induction on 1.


  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  ============================
   forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' @ ->
     member (of E T') (L x) -> member (of E T') L'

sctx'_rst_mem_str < intros.

  Variables: T, T', L, L', E
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H1 : sctx'_rst (of n1 T) (L n1) L' @
  H2 : member (of E T') (L n1)
  ============================
   member (of E T') L'

sctx'_rst_mem_str < case H1.
Subgoal 1:

  Variables: T, T', L, L', E
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H2 : member (of E T') (of n1 T :: L')
  ============================
   member (of E T') L'

Subgoal 2 is:
 member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < case H2.
Subgoal 1:

  Variables: T, T', L, L', E
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H3 : member (of E T') L'
  ============================
   member (of E T') L'

Subgoal 2 is:
 member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < search.
Subgoal 2:

  Variables: T, T', L, L', E, L'1, T'1, Y, L1
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H2 : member (of E T') (of Y T'1 :: L1 n1)
  H3 : sctx'_rst (of n1 T) (L1 n1) L'1 *
  ============================
   member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < case H2.
Subgoal 2.1:

  Variables: T, T', L, L', E, L'1, T'1, Y, L1
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H3 : sctx'_rst (of n1 T) (L1 n1) L'1 *
  ============================
   member (of Y T'1) (of Y T'1 :: L'1)

Subgoal 2.2 is:
 member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < search.
Subgoal 2.2:

  Variables: T, T', L, L', E, L'1, T'1, Y, L1
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H3 : sctx'_rst (of n1 T) (L1 n1) L'1 *
  H4 : member (of E T') (L1 n1)
  ============================
   member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < apply IH to H3 H4.
Subgoal 2.2:

  Variables: T, T', L, L', E, L'1, T'1, Y, L1
  IH : forall T T' L L' E, nabla x, sctx'_rst (of x T) (L x) L' * ->
         member (of E T') (L x) -> member (of E T') L'
  H3 : sctx'_rst (of n1 T) (L1 n1) L'1 *
  H4 : member (of E T') (L1 n1)
  H5 : member (of E T') L'1
  ============================
   member (of E T') (of Y T'1 :: L'1)

sctx'_rst_mem_str < search.
Proof completed.

Abella < Theorem of_strenghten : 
forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'} ->
  sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}.


  ============================
   forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'} ->
     sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}

of_strenghten < induction on 2.


  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  ============================
   forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}@ ->
     sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}

of_strenghten < intros.

  Variables: L, L', T, E, T'
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H2 : {L n1 |- of E T'}@
  H3 : sctx'_rst (of n1 T) (L n1) L'
  ============================
   {L' |- of E T'}

of_strenghten < case H2.
Subgoal 1:

  Variables: L, L', T, E, T', X
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  ============================
   {L' |- of (lnat X) nat_t}

Subgoal 2 is:
 {L' |- of (app E1 E2) T'}

Subgoal 3 is:
 {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < search.
Subgoal 2:

  Variables: L, L', T, E, T', T1, E2, E1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1 |- of E1 (arr T1 T')}*
  H5 : {L n1 |- of E2 T1}*
  ============================
   {L' |- of (app E1 E2) T'}

Subgoal 3 is:
 {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < apply IH to H1 H4 H3.
Subgoal 2:

  Variables: L, L', T, E, T', T1, E2, E1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1 |- of E1 (arr T1 T')}*
  H5 : {L n1 |- of E2 T1}*
  H6 : {L' |- of E1 (arr T1 T')}
  ============================
   {L' |- of (app E1 E2) T'}

Subgoal 3 is:
 {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < apply IH to H1 H5 H3.
Subgoal 2:

  Variables: L, L', T, E, T', T1, E2, E1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1 |- of E1 (arr T1 T')}*
  H5 : {L n1 |- of E2 T1}*
  H6 : {L' |- of E1 (arr T1 T')}
  H7 : {L' |- of E2 T1}
  ============================
   {L' |- of (app E1 E2) T'}

Subgoal 3 is:
 {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < search.
Subgoal 3:

  Variables: L, L', T, E, T', T2, E1, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, of n2 T1 |- of (E1 n2) T2}*
  ============================
   {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < apply sctx'_extend to H1 with x = n2, T = T1.
Subgoal 3:

  Variables: L, L', T, E, T', T2, E1, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, of n2 T1 |- of (E1 n2) T2}*
  H5 : sctx' (of n2 T1 :: L n1)
  ============================
   {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < assert sctx'_rst (of n1 T) (of n2 T1 :: L n1) (of n2 T1 :: L').
Subgoal 3:

  Variables: L, L', T, E, T', T2, E1, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, of n2 T1 |- of (E1 n2) T2}*
  H5 : sctx' (of n2 T1 :: L n1)
  H6 : sctx'_rst (of n1 T) (of n2 T1 :: L n1) (of n2 T1 :: L')
  ============================
   {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < apply IH to H5 H4 H6.
Subgoal 3:

  Variables: L, L', T, E, T', T2, E1, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, of n2 T1 |- of (E1 n2) T2}*
  H5 : sctx' (of n2 T1 :: L n1)
  H6 : sctx'_rst (of n1 T) (of n2 T1 :: L n1) (of n2 T1 :: L')
  H7 : {L', of n2 T1 |- of (E1 n2) T2}
  ============================
   {L' |- of (abs E1) (arr T1 T2)}

Subgoal 4 is:
 {L' |- of E T'}

of_strenghten < search.
Subgoal 4:

  Variables: L, L', T, E, T', F
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, [F n1] |- of E T'}*
  H5 : member (F n1) (L n1)
  ============================
   {L' |- of E T'}

of_strenghten < apply sctx'_mem to H1 H5.
Subgoal 4:

  Variables: L, L', T, E, T', F, X, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H4 : {L n1, [of (X n1) T1] |- of E T'}*
  H5 : member (of (X n1) T1) (L n1)
  H6 : tname (X n1)
  ============================
   {L' |- of E T'}

of_strenghten < case H4.
Subgoal 4:

  Variables: L, L', T, E, T', F, X, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H5 : member (of E T') (L n1)
  H6 : tname E
  ============================
   {L' |- of E T'}

of_strenghten < apply sctx'_rst_mem_str to H3 H5.
Subgoal 4:

  Variables: L, L', T, E, T', F, X, T1
  IH : forall L L' T E T', nabla x, sctx' (L x) -> {L x |- of E T'}* ->
         sctx'_rst (of x T) (L x) L' -> {L' |- of E T'}
  H1 : sctx' (L n1)
  H3 : sctx'_rst (of n1 T) (L n1) L'
  H5 : member (of E T') (L n1)
  H6 : tname E
  H7 : member (of E T') L'
  ============================
   {L' |- of E T'}

of_strenghten < search.
Proof completed.

Abella < Theorem of_strenghten' : 
forall L T E T', nabla x, sctx' L -> {L, of x T |- of E T'} -> {L |- of E T'}.


  ============================
   forall L T E T', nabla x, sctx' L -> {L, of x T |- of E T'} ->
     {L |- of E T'}

of_strenghten' < intros.

  Variables: L, T, E, T'
  H1 : sctx' L
  H2 : {L, of n1 T |- of E T'}
  ============================
   {L |- of E T'}

of_strenghten' < apply sctx'_extend to H1 with x = n1, T = T.

  Variables: L, T, E, T'
  H1 : sctx' L
  H2 : {L, of n1 T |- of E T'}
  H3 : sctx' (of n1 T :: L)
  ============================
   {L |- of E T'}

of_strenghten' < assert sctx'_rst (of n1 T) (of n1 T :: L) L.

  Variables: L, T, E, T'
  H1 : sctx' L
  H2 : {L, of n1 T |- of E T'}
  H3 : sctx' (of n1 T :: L)
  H4 : sctx'_rst (of n1 T) (of n1 T :: L) L
  ============================
   {L |- of E T'}

of_strenghten' < apply of_strenghten to H3 H2 H4.

  Variables: L, T, E, T'
  H1 : sctx' L
  H2 : {L, of n1 T |- of E T'}
  H3 : sctx' (of n1 T :: L)
  H4 : sctx'_rst (of n1 T) (of n1 T :: L) L
  H5 : {L |- of E T'}
  ============================
   {L |- of E T'}

of_strenghten' < search.
Proof completed.

Abella < Theorem of_var_mem : 
forall L F T, nabla x, sctx' (L x) -> {L x, [F x] |- of x T} ->
  member (F x) (L x) -> member (of x T) (L x).


  ============================
   forall L F T, nabla x, sctx' (L x) -> {L x, [F x] |- of x T} ->
     member (F x) (L x) -> member (of x T) (L x)

of_var_mem < intros.

  Variables: L, F, T
  H1 : sctx' (L n1)
  H2 : {L n1, [F n1] |- of n1 T}
  H3 : member (F n1) (L n1)
  ============================
   member (of n1 T) (L n1)

of_var_mem < apply sctx'_mem to H1 H3.

  Variables: L, F, T, X, T1
  H1 : sctx' (L n1)
  H2 : {L n1, [of (X n1) T1] |- of n1 T}
  H3 : member (of (X n1) T1) (L n1)
  H4 : tname (X n1)
  ============================
   member (of n1 T) (L n1)

of_var_mem < case H2.

  Variables: L, F, T, X, T1
  H1 : sctx' (L n1)
  H3 : member (of n1 T) (L n1)
  H4 : tname n1
  ============================
   member (of n1 T) (L n1)

of_var_mem < search.
Proof completed.

Abella < Theorem of_var_inv : 
forall X T L T', sctx' (of X T :: L) -> {L, of X T |- of X T'} -> T = T'.


  ============================
   forall X T L T', sctx' (of X T :: L) -> {L, of X T |- of X T'} -> T = T'

of_var_inv < intros.

  Variables: X, T, L, T'
  H1 : sctx' (of X T :: L)
  H2 : {L, of X T |- of X T'}
  ============================
   T = T'

of_var_inv < case H1 (keep).

  Variables: X, T, L, T'
  H1 : sctx' (of X T :: L)
  H2 : {L, of X T |- of X T'}
  H3 : sctx' L
  H4 : tname X
  H5 : forall T', member (of X T') L -> T = T'
  ============================
   T = T'

of_var_inv < case H4.

  Variables: X, T, L, T'
  H1 : sctx' (of n1 T :: L n1)
  H2 : {L n1, of n1 T |- of n1 T'}
  H3 : sctx' (L n1)
  H5 : forall T', member (of n1 T') (L n1) -> T = T'
  ============================
   T = T'

of_var_inv < case H2.

  Variables: X, T, L, T', F
  H1 : sctx' (of n1 T :: L n1)
  H3 : sctx' (L n1)
  H5 : forall T', member (of n1 T') (L n1) -> T = T'
  H6 : {L n1, of n1 T, [F n1] |- of n1 T'}
  H7 : member (F n1) (of n1 T :: L n1)
  ============================
   T = T'

of_var_inv < apply of_var_mem to H1 H6 H7.

  Variables: X, T, L, T', F
  H1 : sctx' (of n1 T :: L n1)
  H3 : sctx' (L n1)
  H5 : forall T', member (of n1 T') (L n1) -> T = T'
  H6 : {L n1, of n1 T, [F n1] |- of n1 T'}
  H7 : member (F n1) (of n1 T :: L n1)
  H8 : member (of n1 T') (of n1 T :: L n1)
  ============================
   T = T'

of_var_inv < case H8.
Subgoal 1:

  Variables: X, T, L, T', F
  H1 : sctx' (of n1 T :: L n1)
  H3 : sctx' (L n1)
  H5 : forall T', member (of n1 T') (L n1) -> T = T'
  H6 : {L n1, of n1 T, [F n1] |- of n1 T}
  H7 : member (F n1) (of n1 T :: L n1)
  ============================
   T = T

Subgoal 2 is:
 T = T'

of_var_inv < search.
Subgoal 2:

  Variables: X, T, L, T', F
  H1 : sctx' (of n1 T :: L n1)
  H3 : sctx' (L n1)
  H5 : forall T', member (of n1 T') (L n1) -> T = T'
  H6 : {L n1, of n1 T, [F n1] |- of n1 T'}
  H7 : member (F n1) (of n1 T :: L n1)
  H9 : member (of n1 T') (L n1)
  ============================
   T = T'

of_var_inv < apply H5 to H9.
Subgoal 2:

  Variables: X, T, L, T', F
  H1 : sctx' (of n1 T' :: L n1)
  H3 : sctx' (L n1)
  H5 : forall T'1, member (of n1 T'1) (L n1) -> T' = T'1
  H6 : {L n1, of n1 T', [F n1] |- of n1 T'}
  H7 : member (F n1) (of n1 T' :: L n1)
  H9 : member (of n1 T') (L n1)
  ============================
   T' = T'

of_var_inv < search.
Proof completed.

Abella < Theorem of_var_strenghten : 
forall Y T L T' T'' X, sctx' (of Y T :: L) -> {L, of Y T |- of X T'} ->
  tname X -> member (of X T'') L -> {L |- of X T'}.


  ============================
   forall Y T L T' T'' X, sctx' (of Y T :: L) -> {L, of Y T |- of X T'} ->
     tname X -> member (of X T'') L -> {L |- of X T'}

of_var_strenghten < intros.

  Variables: Y, T, L, T', T'', X
  H1 : sctx' (of Y T :: L)
  H2 : {L, of Y T |- of X T'}
  H3 : tname X
  H4 : member (of X T'') L
  ============================
   {L |- of X T'}

of_var_strenghten < case H3.

  Variables: Y, T, L, T', T'', X
  H1 : sctx' (of (Y n1) T :: L n1)
  H2 : {L n1, of (Y n1) T |- of n1 T'}
  H4 : member (of n1 T'') (L n1)
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < case H2.

  Variables: Y, T, L, T', T'', X, F
  H1 : sctx' (of (Y n1) T :: L n1)
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [F n1] |- of n1 T'}
  H6 : member (F n1) (of (Y n1) T :: L n1)
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < case H6.
Subgoal 1:

  Variables: Y, T, L, T', T'', X, F
  H1 : sctx' (of (Y n1) T :: L n1)
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [of (Y n1) T] |- of n1 T'}
  ============================
   {L n1 |- of n1 T'}

Subgoal 2 is:
 {L n1 |- of n1 T'}

of_var_strenghten < case H5.
Subgoal 1:

  Variables: Y, T, L, T', T'', X, F
  H1 : sctx' (of n1 T' :: L n1)
  H4 : member (of n1 T'') (L n1)
  ============================
   {L n1 |- of n1 T'}

Subgoal 2 is:
 {L n1 |- of n1 T'}

of_var_strenghten < case H1.
Subgoal 1:

  Variables: Y, T, L, T', T'', X, F
  H4 : member (of n1 T'') (L n1)
  H7 : sctx' (L n1)
  H8 : tname n1
  H9 : forall T'1, member (of n1 T'1) (L n1) -> T' = T'1
  ============================
   {L n1 |- of n1 T'}

Subgoal 2 is:
 {L n1 |- of n1 T'}

of_var_strenghten < apply H9 to H4.
Subgoal 1:

  Variables: Y, T, L, T', T'', X, F
  H4 : member (of n1 T'') (L n1)
  H7 : sctx' (L n1)
  H8 : tname n1
  H9 : forall T'1, member (of n1 T'1) (L n1) -> T'' = T'1
  ============================
   {L n1 |- of n1 T''}

Subgoal 2 is:
 {L n1 |- of n1 T'}

of_var_strenghten < search.
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F
  H1 : sctx' (of (Y n1) T :: L n1)
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [F n1] |- of n1 T'}
  H7 : member (F n1) (L n1)
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < case H1.
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [F n1] |- of n1 T'}
  H7 : member (F n1) (L n1)
  H8 : sctx' (L n1)
  H9 : tname (Y n1)
  H10 : forall T', member (of (Y n1) T') (L n1) -> T = T'
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < clear H9.
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [F n1] |- of n1 T'}
  H7 : member (F n1) (L n1)
  H8 : sctx' (L n1)
  H10 : forall T', member (of (Y n1) T') (L n1) -> T = T'
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < clear H10.
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [F n1] |- of n1 T'}
  H7 : member (F n1) (L n1)
  H8 : sctx' (L n1)
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < apply sctx'_mem to H8 H7.
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F, X1, T1
  H4 : member (of n1 T'') (L n1)
  H5 : {L n1, of (Y n1) T, [of (X1 n1) T1] |- of n1 T'}
  H7 : member (of (X1 n1) T1) (L n1)
  H8 : sctx' (L n1)
  H11 : tname (X1 n1)
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < case H5.
Subgoal 2:

  Variables: Y, T, L, T', T'', X, F, X1, T1
  H4 : member (of n1 T'') (L n1)
  H7 : member (of n1 T') (L n1)
  H8 : sctx' (L n1)
  H11 : tname n1
  ============================
   {L n1 |- of n1 T'}

of_var_strenghten < search.
Proof completed.

Abella < Theorem of_abs_arrow_typ : 
forall L R T, sctx' L -> {L |- of (abs R) T} -> (exists T1 T2, T = arr T1 T2).


  ============================
   forall L R T, sctx' L -> {L |- of (abs R) T} -> (exists T1 T2,
     T = arr T1 T2)

of_abs_arrow_typ < intros.

  Variables: L, R, T
  H1 : sctx' L
  H2 : {L |- of (abs R) T}
  ============================
   exists T1 T2, T = arr T1 T2

of_abs_arrow_typ < case H2.
Subgoal 1:

  Variables: L, R, T, T2, T1
  H1 : sctx' L
  H3 : {L, of n1 T1 |- of (R n1) T2}
  ============================
   exists T3 T4, arr T1 T2 = arr T3 T4

Subgoal 2 is:
 exists T1 T2, T = arr T1 T2

of_abs_arrow_typ < search.
Subgoal 2:

  Variables: L, R, T, F
  H1 : sctx' L
  H3 : {L, [F] |- of (abs R) T}
  H4 : member F L
  ============================
   exists T1 T2, T = arr T1 T2

of_abs_arrow_typ < apply sctx'_mem to H1 H4.
Subgoal 2:

  Variables: L, R, T, F, X, T1
  H1 : sctx' L
  H3 : {L, [of X T1] |- of (abs R) T}
  H4 : member (of X T1) L
  H5 : tname X
  ============================
   exists T1 T2, T = arr T1 T2

of_abs_arrow_typ < case H3.
Subgoal 2:

  Variables: L, R, T, F, X, T1
  H1 : sctx' L
  H4 : member (of (abs R) T) L
  H5 : tname (abs R)
  ============================
   exists T1 T2, T = arr T1 T2

of_abs_arrow_typ < case H5.
Proof completed.

Abella < Define sctx'_tmctx : olist -> olist -> prop by 
sctx'_tmctx nil nil;
nabla x, sctx'_tmctx (of x T :: L x) (tm x :: L' x) := nabla x, sctx'_tmctx (L x) (L' x).

Abella < Theorem sctx'_tmctx_exists : 
forall L, sctx' L -> (exists L', sctx'_tmctx L L' /\ tmctx L').


  ============================
   forall L, sctx' L -> (exists L', sctx'_tmctx L L' /\ tmctx L')

sctx'_tmctx_exists < induction on 1.


  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  ============================
   forall L, sctx' L @ -> (exists L', sctx'_tmctx L L' /\ tmctx L')

sctx'_tmctx_exists < intros.

  Variables: L
  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  H1 : sctx' L @
  ============================
   exists L', sctx'_tmctx L L' /\ tmctx L'

sctx'_tmctx_exists < case H1.
Subgoal 1:

  Variables: L
  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  ============================
   exists L', sctx'_tmctx nil L' /\ tmctx L'

Subgoal 2 is:
 exists L', sctx'_tmctx (of X T :: L1) L' /\ tmctx L'

sctx'_tmctx_exists < search.
Subgoal 2:

  Variables: L, L1, T, X
  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  H2 : sctx' L1 *
  H3 : tname X
  H4 : forall T', member (of X T') L1 -> T = T'
  ============================
   exists L', sctx'_tmctx (of X T :: L1) L' /\ tmctx L'

sctx'_tmctx_exists < apply IH to H2.
Subgoal 2:

  Variables: L, L1, T, X, L'
  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  H2 : sctx' L1 *
  H3 : tname X
  H4 : forall T', member (of X T') L1 -> T = T'
  H5 : sctx'_tmctx L1 L'
  H6 : tmctx L'
  ============================
   exists L', sctx'_tmctx (of X T :: L1) L' /\ tmctx L'

sctx'_tmctx_exists < case H3.
Subgoal 2:

  Variables: L, L1, T, X, L'
  IH : forall L, sctx' L * -> (exists L', sctx'_tmctx L L' /\ tmctx L')
  H2 : sctx' (L1 n1) *
  H4 : forall T', member (of n1 T') (L1 n1) -> T = T'
  H5 : sctx'_tmctx (L1 n1) (L' n1)
  H6 : tmctx (L' n1)
  ============================
   exists L', sctx'_tmctx (of n1 T :: L1 n1) L' /\ tmctx L'

sctx'_tmctx_exists < search.
Proof completed.

Abella < Theorem sctx'_tmctx_mem1 : 
forall L L' F, sctx'_tmctx L L' -> member F L -> (exists X T, F = of X T /\
  tname X).


  ============================
   forall L L' F, sctx'_tmctx L L' -> member F L -> (exists X T,
     F = of X T /\ tname X)

sctx'_tmctx_mem1 < induction on 1.


  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  ============================
   forall L L' F, sctx'_tmctx L L' @ -> member F L -> (exists X T,
     F = of X T /\ tname X)

sctx'_tmctx_mem1 < intros.

  Variables: L, L', F
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H1 : sctx'_tmctx L L' @
  H2 : member F L
  ============================
   exists X T, F = of X T /\ tname X

sctx'_tmctx_mem1 < case H1.
Subgoal 1:

  Variables: L, L', F
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H2 : member F nil
  ============================
   exists X T, F = of X T /\ tname X

Subgoal 2 is:
 exists X T, F n1 = of X T /\ tname X

sctx'_tmctx_mem1 < case H2.
Subgoal 2:

  Variables: L, L', F, L'1, L1, T
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H2 : member (F n1) (of n1 T :: L1 n1)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   exists X T, F n1 = of X T /\ tname X

sctx'_tmctx_mem1 < case H2.
Subgoal 2.1:

  Variables: L, L', F, L'1, L1, T
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   exists X T1, of n1 T = of X T1 /\ tname X

Subgoal 2.2 is:
 exists X T, F n1 = of X T /\ tname X

sctx'_tmctx_mem1 < search.
Subgoal 2.2:

  Variables: L, L', F, L'1, L1, T
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (F n1) (L1 n1)
  ============================
   exists X T, F n1 = of X T /\ tname X

sctx'_tmctx_mem1 < apply IH to H3 H4.
Subgoal 2.2:

  Variables: L, L', F, L'1, L1, T, X, T1
  IH : forall L L' F, sctx'_tmctx L L' * -> member F L -> (exists X T,
         F = of X T /\ tname X)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (of (X n1) T1) (L1 n1)
  H5 : tname (X n1)
  ============================
   exists X1 T, of (X n1) T1 = of X1 T /\ tname X1

sctx'_tmctx_mem1 < search.
Proof completed.

Abella < Theorem sctx'_tmctx_sync1 : 
forall L L' X T, sctx'_tmctx L L' -> member (of X T) L -> member (tm X) L'.


  ============================
   forall L L' X T, sctx'_tmctx L L' -> member (of X T) L -> member (tm X) L'

sctx'_tmctx_sync1 < induction on 1.


  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  ============================
   forall L L' X T, sctx'_tmctx L L' @ -> member (of X T) L ->
     member (tm X) L'

sctx'_tmctx_sync1 < intros.

  Variables: L, L', X, T
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H1 : sctx'_tmctx L L' @
  H2 : member (of X T) L
  ============================
   member (tm X) L'

sctx'_tmctx_sync1 < case H1.
Subgoal 1:

  Variables: L, L', X, T
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H2 : member (of X T) nil
  ============================
   member (tm X) nil

Subgoal 2 is:
 member (tm (X n1)) (tm n1 :: L'1 n1)

sctx'_tmctx_sync1 < case H2.
Subgoal 2:

  Variables: L, L', X, T, L'1, L1, T1
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H2 : member (of (X n1) T) (of n1 T1 :: L1 n1)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   member (tm (X n1)) (tm n1 :: L'1 n1)

sctx'_tmctx_sync1 < case H2.
Subgoal 2.1:

  Variables: L, L', X, T, L'1, L1, T1
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   member (tm n1) (tm n1 :: L'1 n1)

Subgoal 2.2 is:
 member (tm (X n1)) (tm n1 :: L'1 n1)

sctx'_tmctx_sync1 < search.
Subgoal 2.2:

  Variables: L, L', X, T, L'1, L1, T1
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (of (X n1) T) (L1 n1)
  ============================
   member (tm (X n1)) (tm n1 :: L'1 n1)

sctx'_tmctx_sync1 < apply IH to H3 H4.
Subgoal 2.2:

  Variables: L, L', X, T, L'1, L1, T1
  IH : forall L L' X T, sctx'_tmctx L L' * -> member (of X T) L ->
         member (tm X) L'
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (of (X n1) T) (L1 n1)
  H5 : member (tm (X n1)) (L'1 n1)
  ============================
   member (tm (X n1)) (tm n1 :: L'1 n1)

sctx'_tmctx_sync1 < search.
Proof completed.

Abella < Theorem sctx'_tmctx_sync2 : 
forall L L' X, sctx'_tmctx L L' -> member (tm X) L' -> (exists T,
  member (of X T) L).


  ============================
   forall L L' X, sctx'_tmctx L L' -> member (tm X) L' -> (exists T,
     member (of X T) L)

sctx'_tmctx_sync2 < induction on 1.


  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  ============================
   forall L L' X, sctx'_tmctx L L' @ -> member (tm X) L' -> (exists T,
     member (of X T) L)

sctx'_tmctx_sync2 < intros.

  Variables: L, L', X
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H1 : sctx'_tmctx L L' @
  H2 : member (tm X) L'
  ============================
   exists T, member (of X T) L

sctx'_tmctx_sync2 < case H1.
Subgoal 1:

  Variables: L, L', X
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H2 : member (tm X) nil
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of (X n1) T1) (of n1 T :: L1 n1)

sctx'_tmctx_sync2 < case H2.
Subgoal 2:

  Variables: L, L', X, L'1, L1, T
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H2 : member (tm (X n1)) (tm n1 :: L'1 n1)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   exists T1, member (of (X n1) T1) (of n1 T :: L1 n1)

sctx'_tmctx_sync2 < case H2.
Subgoal 2.1:

  Variables: L, L', X, L'1, L1, T
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  ============================
   exists T1, member (of n1 T1) (of n1 T :: L1 n1)

Subgoal 2.2 is:
 exists T1, member (of (X n1) T1) (of n1 T :: L1 n1)

sctx'_tmctx_sync2 < search.
Subgoal 2.2:

  Variables: L, L', X, L'1, L1, T
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (tm (X n1)) (L'1 n1)
  ============================
   exists T1, member (of (X n1) T1) (of n1 T :: L1 n1)

sctx'_tmctx_sync2 < apply IH to H3 H4.
Subgoal 2.2:

  Variables: L, L', X, L'1, L1, T, T1
  IH : forall L L' X, sctx'_tmctx L L' * -> member (tm X) L' -> (exists T,
         member (of X T) L)
  H3 : sctx'_tmctx (L1 n1) (L'1 n1) *
  H4 : member (tm (X n1)) (L'1 n1)
  H5 : member (of (X n1) T1) (L1 n1)
  ============================
   exists T1, member (of (X n1) T1) (of n1 T :: L1 n1)

sctx'_tmctx_sync2 < search.
Proof completed.

Abella < Theorem of_tm : 
forall L L' M T, sctx'_tmctx L L' -> {L |- of M T} -> {L' |- tm M}.


  ============================
   forall L L' M T, sctx'_tmctx L L' -> {L |- of M T} -> {L' |- tm M}

of_tm < induction on 2.


  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  ============================
   forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}@ -> {L' |- tm M}

of_tm < intros.

  Variables: L, L', M, T
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H2 : {L |- of M T}@
  ============================
   {L' |- tm M}

of_tm < case H2.
Subgoal 1:

  Variables: L, L', M, T, X
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  ============================
   {L' |- tm (lnat X)}

Subgoal 2 is:
 {L' |- tm (app M1 N)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < search.
Subgoal 2:

  Variables: L, L', M, T, T1, N, M1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L |- of M1 (arr T1 T)}*
  H4 : {L |- of N T1}*
  ============================
   {L' |- tm (app M1 N)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < apply IH to H1 H3.
Subgoal 2:

  Variables: L, L', M, T, T1, N, M1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L |- of M1 (arr T1 T)}*
  H4 : {L |- of N T1}*
  H5 : {L' |- tm M1}
  ============================
   {L' |- tm (app M1 N)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < apply IH to H1 H4.
Subgoal 2:

  Variables: L, L', M, T, T1, N, M1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L |- of M1 (arr T1 T)}*
  H4 : {L |- of N T1}*
  H5 : {L' |- tm M1}
  H6 : {L' |- tm N}
  ============================
   {L' |- tm (app M1 N)}

Subgoal 3 is:
 {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < search.
Subgoal 3:

  Variables: L, L', M, T, T2, M1, T1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L, of n1 T1 |- of (M1 n1) T2}*
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < apply IH to _ H3.
Subgoal 3:

  Variables: L, L', M, T, T2, M1, T1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L, of n1 T1 |- of (M1 n1) T2}*
  H4 : {L', tm n1 |- tm (M1 n1)}
  ============================
   {L' |- tm (abs M1)}

Subgoal 4 is:
 {L' |- tm M}

of_tm < search.
Subgoal 4:

  Variables: L, L', M, T, F
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L, [F] |- of M T}*
  H4 : member F L
  ============================
   {L' |- tm M}

of_tm < apply sctx'_tmctx_mem1 to H1 H4.
Subgoal 4:

  Variables: L, L', M, T, F, X, T1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H3 : {L, [of X T1] |- of M T}*
  H4 : member (of X T1) L
  H5 : tname X
  ============================
   {L' |- tm M}

of_tm < case H3.
Subgoal 4:

  Variables: L, L', M, T, F, X, T1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H4 : member (of M T) L
  H5 : tname M
  ============================
   {L' |- tm M}

of_tm < apply sctx'_tmctx_sync1 to H1 H4.
Subgoal 4:

  Variables: L, L', M, T, F, X, T1
  IH : forall L L' M T, sctx'_tmctx L L' -> {L |- of M T}* -> {L' |- tm M}
  H1 : sctx'_tmctx L L'
  H4 : member (of M T) L
  H5 : tname M
  H6 : member (tm M) L'
  ============================
   {L' |- tm M}

of_tm < search.
Proof completed.

Abella < Theorem of_closed_tm : 
forall M T, {of M T} -> {tm M}.


  ============================
   forall M T, {of M T} -> {tm M}

of_closed_tm < intros.

  Variables: M, T
  H1 : {of M T}
  ============================
   {tm M}

of_closed_tm < apply of_tm to _ H1.

  Variables: M, T
  H1 : {of M T}
  H2 : {tm M}
  ============================
   {tm M}

of_closed_tm < search.
Proof completed.

Abella < Define vars_of_sctx : olist -> tm_list -> prop by 
vars_of_sctx nil tl_nil;
vars_of_sctx (of X T :: L) (tl_cons X Vs) := vars_of_sctx L Vs.

Abella < Theorem vars_of_sctx_mem_exists : 
forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
  (exists T, member (of X T) SL).


  ============================
   forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     (exists T, member (of X T) SL)

vars_of_sctx_mem_exists < induction on 1.


  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  ============================
   forall SL Vs X, sctx' SL @ -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     (exists T, member (of X T) SL)

vars_of_sctx_mem_exists < intros.

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H1 : sctx' SL @
  H2 : vars_of_sctx SL Vs
  H3 : {tl_member X Vs}
  ============================
   exists T, member (of X T) SL

vars_of_sctx_mem_exists < case H1.
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H2 : vars_of_sctx nil Vs
  H3 : {tl_member X Vs}
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < case H2.
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H3 : {tl_member X tl_nil}
  ============================
   exists T, member (of X T) nil

Subgoal 2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < case H3.
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H2 : vars_of_sctx (of X1 T :: L) Vs
  H3 : {tl_member X Vs}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < case H2.
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H3 : {tl_member X (tl_cons X1 Vs1)}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < case H3.
Subgoal 2.1:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   exists T1, member (of X1 T1) (of X1 T :: L)

Subgoal 2.2 is:
 exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < search.
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < apply IH to H4 H7 H8.
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1, T1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> (exists T, member (of X T) SL)
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  H9 : member (of X T1) L
  ============================
   exists T1, member (of X T1) (of X1 T :: L)

vars_of_sctx_mem_exists < search.
Proof completed.

Abella < Theorem sctx_env_sync : 
forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL ->
  {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
  member (of E T) L /\ tname E).


  ============================
   forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL ->
     {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
     member (of E T) L /\ tname E)

sctx_env_sync < induction on 2.


  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  ============================
   forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL @ ->
     {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
     member (of E T) L /\ tname E)

sctx_env_sync < intros.

  Variables: L, TL, Map, E, V
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' L
  H2 : vars_of_sctx L TL @
  H3 : {mapvar TL Map}
  H4 : {ml_member (map E (V n1)) (Map n1)}
  ============================
   exists T, member (of E T) L /\ tname E

sctx_env_sync < case H2.
Subgoal 1:

  Variables: L, TL, Map, E, V
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' nil
  H3 : {mapvar tl_nil Map}
  H4 : {ml_member (map E (V n1)) (Map n1)}
  ============================
   exists T, member (of E T) nil /\ tname E

Subgoal 2 is:
 exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < case H3.
Subgoal 1:

  Variables: L, TL, Map, E, V
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' nil
  H4 : {ml_member (map E (V n1)) ml_nil}
  ============================
   exists T, member (of E T) nil /\ tname E

Subgoal 2 is:
 exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < case H4.
Subgoal 2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H3 : {mapvar (tl_cons X Vs) Map}
  H4 : {ml_member (map E (V n1)) (Map n1)}
  H5 : vars_of_sctx L1 Vs *
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < case H3.
Subgoal 2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H4 : {ml_member (map E (V n1)) (ml_cons (map X (fst n1)) (Map1 (rst n1)))}
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < case H4.
Subgoal 2.1:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  ============================
   exists T1, member (of X T1) (of X T :: L1) /\ tname X

Subgoal 2.2 is:
 exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < case H1.
Subgoal 2.1:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : sctx' L1
  H9 : tname X
  H10 : forall T', member (of X T') L1 -> T = T'
  ============================
   exists T1, member (of X T1) (of X T :: L1) /\ tname X

Subgoal 2.2 is:
 exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < search.
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < apply eq_ml_member to H7 H8.
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < apply mapvar_mem to H6 H9.
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2, E'
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  H10 : V n1 = E' n1 n2 (rst n1)
  H11 : env_elem (E' n1 n2)
  H12 : {ml_member (map E (E' n1 n2 n2)) (Map1 n2)}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < apply env_elem_closed to H11.
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2, E', E'1
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  H10 : V n1 = E'1 n2 (rst n1)
  H11 : env_elem (E'1 n2)
  H12 : {ml_member (map E (E'1 n2 n2)) (Map1 n2)}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < apply env_elem_closed to H11.
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2, E', E'1, E'2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H1 : sctx' (of X T :: L1)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  H10 : V n1 = E'2 (rst n1)
  H11 : env_elem E'2
  H12 : {ml_member (map E (E'2 n2)) (Map1 n2)}
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < case H1.
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2, E', E'1, E'2
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  H10 : V n1 = E'2 (rst n1)
  H11 : env_elem E'2
  H12 : {ml_member (map E (E'2 n2)) (Map1 n2)}
  H13 : sctx' L1
  H14 : tname X
  H15 : forall T', member (of X T') L1 -> T = T'
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < apply IH to H13 H5 H6 H12.
Subgoal 2.2:

  Variables: L, TL, Map, E, V, Vs, X, L1, T, Map1, L2, E', E'1, E'2, T1
  IH : forall L TL Map E V, nabla x, sctx' L -> vars_of_sctx L TL * ->
         {mapvar TL Map} -> {ml_member (map E (V x)) (Map x)} -> (exists T,
         member (of E T) L /\ tname E)
  H5 : vars_of_sctx L1 Vs *
  H6 : {mapvar Vs Map1}
  H7 : L2 n1 = Map1 (rst n1)
  H8 : {ml_member (map E (V n1)) (L2 n1)}
  H9 : {ml_member (map E (V n1)) (Map1 (rst n1))}
  H10 : V n1 = E'2 (rst n1)
  H11 : env_elem E'2
  H12 : {ml_member (map E (E'2 n2)) (Map1 n2)}
  H13 : sctx' L1
  H14 : tname X
  H15 : forall T', member (of X T') L1 -> T = T'
  H16 : member (of E T1) L1
  H17 : tname E
  ============================
   exists T1, member (of E T1) (of X T :: L1) /\ tname E

sctx_env_sync < search.
Proof completed.

Abella < Define bvars : olist -> prop by 
bvars nil;
nabla x, bvars (notfree x :: L) := bvars L.

Abella < Theorem bvars_mem : 
forall BVs E, bvars BVs -> member E BVs -> (exists X, E = notfree X /\
  tname X).


  ============================
   forall BVs E, bvars BVs -> member E BVs -> (exists X, E = notfree X /\
     tname X)

bvars_mem < induction on 1.


  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  ============================
   forall BVs E, bvars BVs @ -> member E BVs -> (exists X, E = notfree X /\
     tname X)

bvars_mem < intros.

  Variables: BVs, E
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H1 : bvars BVs @
  H2 : member E BVs
  ============================
   exists X, E = notfree X /\ tname X

bvars_mem < case H1.
Subgoal 1:

  Variables: BVs, E
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H2 : member E nil
  ============================
   exists X, E = notfree X /\ tname X

Subgoal 2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < case H2.
Subgoal 2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H2 : member (E n1) (notfree n1 :: L)
  H3 : bvars L *
  ============================
   exists X, E n1 = notfree X /\ tname X

bvars_mem < case H2.
Subgoal 2.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   exists X, notfree n1 = notfree X /\ tname X

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < exists n1.
Subgoal 2.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   notfree n1 = notfree n1 /\ tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < split.
Subgoal 2.1.1:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   notfree n1 = notfree n1

Subgoal 2.1.2 is:
 tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < search.
Subgoal 2.1.2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  ============================
   tname n1

Subgoal 2.2 is:
 exists X, E n1 = notfree X /\ tname X

bvars_mem < search.
Subgoal 2.2:

  Variables: BVs, E, L
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (E n1) L
  ============================
   exists X, E n1 = notfree X /\ tname X

bvars_mem < apply IH to H3 H4.
Subgoal 2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   exists X1, notfree (X n1) = notfree X1 /\ tname X1

bvars_mem < exists X n1.
Subgoal 2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   notfree (X n1) = notfree (X n1) /\ tname (X n1)

bvars_mem < split.
Subgoal 2.2.1:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   notfree (X n1) = notfree (X n1)

Subgoal 2.2.2 is:
 tname (X n1)

bvars_mem < search.
Subgoal 2.2.2:

  Variables: BVs, E, L, X
  IH : forall BVs E, bvars BVs * -> member E BVs -> (exists X,
         E = notfree X /\ tname X)
  H3 : bvars L *
  H4 : member (notfree (X n1)) L
  H5 : tname (X n1)
  ============================
   tname (X n1)

bvars_mem < search.
Proof completed.

Abella < Theorem vars_of_sctx_mem_name : 
forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} -> tname X.


  ============================
   forall SL Vs X, sctx' SL -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     tname X

vars_of_sctx_mem_name < induction on 1.


  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  ============================
   forall SL Vs X, sctx' SL @ -> vars_of_sctx SL Vs -> {tl_member X Vs} ->
     tname X

vars_of_sctx_mem_name < intros.

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H1 : sctx' SL @
  H2 : vars_of_sctx SL Vs
  H3 : {tl_member X Vs}
  ============================
   tname X

vars_of_sctx_mem_name < case H1.
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H2 : vars_of_sctx nil Vs
  H3 : {tl_member X Vs}
  ============================
   tname X

Subgoal 2 is:
 tname X

vars_of_sctx_mem_name < case H2.
Subgoal 1:

  Variables: SL, Vs, X
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H3 : {tl_member X tl_nil}
  ============================
   tname X

Subgoal 2 is:
 tname X

vars_of_sctx_mem_name < case H3.
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H2 : vars_of_sctx (of X1 T :: L) Vs
  H3 : {tl_member X Vs}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  ============================
   tname X

vars_of_sctx_mem_name < case H2.
Subgoal 2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H3 : {tl_member X (tl_cons X1 Vs1)}
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   tname X

vars_of_sctx_mem_name < case H3.
Subgoal 2.1:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  ============================
   tname X1

Subgoal 2.2 is:
 tname X

vars_of_sctx_mem_name < search.
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  ============================
   tname X

vars_of_sctx_mem_name < apply IH to H4 H7 H8.
Subgoal 2.2:

  Variables: SL, Vs, X, L, T, X1, Vs1
  IH : forall SL Vs X, sctx' SL * -> vars_of_sctx SL Vs ->
         {tl_member X Vs} -> tname X
  H4 : sctx' L *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L -> T = T'
  H7 : vars_of_sctx L Vs1
  H8 : {tl_member X Vs1}
  H9 : tname X
  ============================
   tname X

vars_of_sctx_mem_name < search.
Proof completed.

Abella < Theorem bvars_notfree : 
forall BVs X, bvars BVs -> {BVs |- notfree X} -> tname X.


  ============================
   forall BVs X, bvars BVs -> {BVs |- notfree X} -> tname X

bvars_notfree < intros.

  Variables: BVs, X
  H1 : bvars BVs
  H2 : {BVs |- notfree X}
  ============================
   tname X

bvars_notfree < case H2.

  Variables: BVs, X, F
  H1 : bvars BVs
  H3 : {BVs, [F] |- notfree X}
  H4 : member F BVs
  ============================
   tname X

bvars_notfree < apply bvars_mem to H1 H4.

  Variables: BVs, X, F, X1
  H1 : bvars BVs
  H3 : {BVs, [notfree X1] |- notfree X}
  H4 : member (notfree X1) BVs
  H5 : tname X1
  ============================
   tname X

bvars_notfree < case H3.

  Variables: BVs, X, F, X1
  H1 : bvars BVs
  H4 : member (notfree X) BVs
  H5 : tname X
  ============================
   tname X

bvars_notfree < search.
Proof completed.

Abella < Define subset : tm_list -> tm_list -> prop by 
subset tl_nil L;
subset (tl_cons X L1) L2 := {tl_member X L2} /\ subset L1 L2.

Abella < Define islist : tm_list -> prop by 
islist tl_nil;
islist (tl_cons X L) := islist L.

Abella < Theorem combine_islist : 
forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> islist L3.


  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> islist L3

combine_islist < induction on 3.


  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     islist L3

combine_islist < intros.

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  ============================
   islist L3

combine_islist < case H3.
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist tl_nil
  H2 : islist L3
  ============================
   islist L3

Subgoal 2 is:
 islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < search.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < case H1.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : islist Fvs1
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < apply IH to H6 H2 H5.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : islist Fvs1
  H7 : islist L3
  ============================
   islist L3

Subgoal 3 is:
 islist (tl_cons X Fvs)

combine_islist < search.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  ============================
   islist (tl_cons X Fvs)

combine_islist < case H1.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  ============================
   islist (tl_cons X Fvs)

combine_islist < apply IH to H5 H2 H4.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         islist L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : islist Fvs
  ============================
   islist (tl_cons X Fvs)

combine_islist < search.
Proof completed.

Abella < Theorem tl_mem_bvar : 
forall Ps X L, bvars Ps -> {Ps |- tl_member X L} -> {tl_member X L}.


  ============================
   forall Ps X L, bvars Ps -> {Ps |- tl_member X L} -> {tl_member X L}

tl_mem_bvar < induction on 2.


  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  ============================
   forall Ps X L, bvars Ps -> {Ps |- tl_member X L}@ -> {tl_member X L}

tl_mem_bvar < intros.

  Variables: Ps, X, L
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H2 : {Ps |- tl_member X L}@
  ============================
   {tl_member X L}

tl_mem_bvar < case H2.
Subgoal 1:

  Variables: Ps, X, L, L1
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  ============================
   {tl_member X (tl_cons X L1)}

Subgoal 2 is:
 {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < search.
Subgoal 2:

  Variables: Ps, X, L, L1, Y
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L1}*
  ============================
   {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < apply IH to H1 H3.
Subgoal 2:

  Variables: Ps, X, L, L1, Y
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L1}*
  H4 : {tl_member X L1}
  ============================
   {tl_member X (tl_cons Y L1)}

Subgoal 3 is:
 {tl_member X L}

tl_mem_bvar < search.
Subgoal 3:

  Variables: Ps, X, L, F
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps, [F] |- tl_member X L}*
  H4 : member F Ps
  ============================
   {tl_member X L}

tl_mem_bvar < apply bvars_mem to H1 H4.
Subgoal 3:

  Variables: Ps, X, L, F, X1
  IH : forall Ps X L, bvars Ps -> {Ps |- tl_member X L}* -> {tl_member X L}
  H1 : bvars Ps
  H3 : {Ps, [notfree X1] |- tl_member X L}*
  H4 : member (notfree X1) Ps
  H5 : tname X1
  ============================
   {tl_member X L}

tl_mem_bvar < case H3.
Proof completed.

Abella < Theorem combine_bvar : 
forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3} ->
  {combine L1 L2 L3}.


  ============================
   forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3} ->
     {combine L1 L2 L3}

combine_bvar < induction on 2.


  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  ============================
   forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}@ ->
     {combine L1 L2 L3}

combine_bvar < intros.

  Variables: L1, L2, L3, Ps
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H2 : {Ps |- combine L1 L2 L3}@
  ============================
   {combine L1 L2 L3}

combine_bvar < case H2.
Subgoal 1:

  Variables: L1, L2, L3, Ps
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  ============================
   {combine tl_nil L3 L3}

Subgoal 2 is:
 {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < search.
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < apply IH to H1 H4.
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  H5 : {combine Fvs1 L2 L3}
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < apply tl_mem_bvar to H1 H3.
Subgoal 2:

  Variables: L1, L2, L3, Ps, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- tl_member X L2}*
  H4 : {Ps |- combine Fvs1 L2 L3}*
  H5 : {combine Fvs1 L2 L3}
  H6 : {tl_member X L2}
  ============================
   {combine (tl_cons X Fvs1) L2 L3}

Subgoal 3 is:
 {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < search.
Subgoal 3:

  Variables: L1, L2, L3, Ps, Fvs, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- combine Fvs1 L2 Fvs}*
  ============================
   {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < apply IH to H1 H3.
Subgoal 3:

  Variables: L1, L2, L3, Ps, Fvs, Fvs1, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps |- combine Fvs1 L2 Fvs}*
  H4 : {combine Fvs1 L2 Fvs}
  ============================
   {combine (tl_cons X Fvs1) L2 (tl_cons X Fvs)}

Subgoal 4 is:
 {combine L1 L2 L3}

combine_bvar < search.
Subgoal 4:

  Variables: L1, L2, L3, Ps, F
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps, [F] |- combine L1 L2 L3}*
  H4 : member F Ps
  ============================
   {combine L1 L2 L3}

combine_bvar < apply bvars_mem to H1 H4.
Subgoal 4:

  Variables: L1, L2, L3, Ps, F, X
  IH : forall L1 L2 L3 Ps, bvars Ps -> {Ps |- combine L1 L2 L3}* ->
         {combine L1 L2 L3}
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- combine L1 L2 L3}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   {combine L1 L2 L3}

combine_bvar < case H3.
Proof completed.

Abella < Theorem subset_mem : 
forall L1 L2 X, subset L1 L2 -> {tl_member X L1} -> {tl_member X L2}.


  ============================
   forall L1 L2 X, subset L1 L2 -> {tl_member X L1} -> {tl_member X L2}

subset_mem < induction on 2.


  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  ============================
   forall L1 L2 X, subset L1 L2 -> {tl_member X L1}@ -> {tl_member X L2}

subset_mem < intros.

  Variables: L1, L2, X
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset L1 L2
  H2 : {tl_member X L1}@
  ============================
   {tl_member X L2}

subset_mem < case H2.
Subgoal 1:

  Variables: L1, L2, X, L
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset (tl_cons X L) L2
  ============================
   {tl_member X L2}

Subgoal 2 is:
 {tl_member X L2}

subset_mem < case H1.
Subgoal 1:

  Variables: L1, L2, X, L
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L2}
  H4 : subset L L2
  ============================
   {tl_member X L2}

Subgoal 2 is:
 {tl_member X L2}

subset_mem < search.
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H1 : subset (tl_cons Y L) L2
  H3 : {tl_member X L}*
  ============================
   {tl_member X L2}

subset_mem < case H1.
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L}*
  H4 : {tl_member Y L2}
  H5 : subset L L2
  ============================
   {tl_member X L2}

subset_mem < apply IH to H5 H3.
Subgoal 2:

  Variables: L1, L2, X, L, Y
  IH : forall L1 L2 X, subset L1 L2 -> {tl_member X L1}* -> {tl_member X L2}
  H3 : {tl_member X L}*
  H4 : {tl_member Y L2}
  H5 : subset L L2
  H6 : {tl_member X L2}
  ============================
   {tl_member X L2}

subset_mem < search.
Proof completed.

Abella < Theorem subset_one : 
forall L1 L2 X, islist L1 -> subset L1 L2 -> subset L1 (tl_cons X L2).


  ============================
   forall L1 L2 X, islist L1 -> subset L1 L2 -> subset L1 (tl_cons X L2)

subset_one < induction on 1.


  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 -> subset L1 (tl_cons X L2)
  ============================
   forall L1 L2 X, islist L1 @ -> subset L1 L2 -> subset L1 (tl_cons X L2)

subset_one < intros.

  Variables: L1, L2, X
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H1 : islist L1 @
  H2 : subset L1 L2
  ============================
   subset L1 (tl_cons X L2)

subset_one < case H1.
Subgoal 1:

  Variables: L1, L2, X
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H2 : subset tl_nil L2
  ============================
   subset tl_nil (tl_cons X L2)

Subgoal 2 is:
 subset (tl_cons X1 L) (tl_cons X L2)

subset_one < search.
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H2 : subset (tl_cons X1 L) L2
  H3 : islist L *
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < case H2.
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < apply IH to H3 H5 with X = X.
Subgoal 2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   subset (tl_cons X1 L) (tl_cons X L2)

subset_one < unfold.
Subgoal 2.1:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   {tl_member X1 (tl_cons X L2)}

Subgoal 2.2 is:
 subset L (tl_cons X L2)

subset_one < search.
Subgoal 2.2:

  Variables: L1, L2, X, L, X1
  IH : forall L1 L2 X, islist L1 * -> subset L1 L2 ->
         subset L1 (tl_cons X L2)
  H3 : islist L *
  H4 : {tl_member X1 L2}
  H5 : subset L L2
  H6 : subset L (tl_cons X L2)
  ============================
   subset L (tl_cons X L2)

subset_one < search.
Proof completed.

Abella < Theorem subset_refl : 
forall L, islist L -> subset L L.


  ============================
   forall L, islist L -> subset L L

subset_refl < induction on 1.


  IH : forall L, islist L * -> subset L L
  ============================
   forall L, islist L @ -> subset L L

subset_refl < intros.

  Variables: L
  IH : forall L, islist L * -> subset L L
  H1 : islist L @
  ============================
   subset L L

subset_refl < case H1 (keep).
Subgoal 1:

  Variables: L
  IH : forall L, islist L * -> subset L L
  H1 : islist tl_nil @
  ============================
   subset tl_nil tl_nil

Subgoal 2 is:
 subset (tl_cons X L1) (tl_cons X L1)

subset_refl < search.
Subgoal 2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   subset (tl_cons X L1) (tl_cons X L1)

subset_refl < unfold.
Subgoal 2.1:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   {tl_member X (tl_cons X L1)}

Subgoal 2.2 is:
 subset L1 (tl_cons X L1)

subset_refl < search.
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  ============================
   subset L1 (tl_cons X L1)

subset_refl < apply IH to H2.
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  H3 : subset L1 L1
  ============================
   subset L1 (tl_cons X L1)

subset_refl < apply subset_one to H2 H3 with X = X.
Subgoal 2.2:

  Variables: L, L1, X
  IH : forall L, islist L * -> subset L L
  H1 : islist (tl_cons X L1) @
  H2 : islist L1 *
  H3 : subset L1 L1
  H4 : subset L1 (tl_cons X L1)
  ============================
   subset L1 (tl_cons X L1)

subset_refl < search.
Proof completed.

Abella < Theorem subset_trans : 
forall L1 L2 L3, subset L1 L2 -> subset L2 L3 -> subset L1 L3.


  ============================
   forall L1 L2 L3, subset L1 L2 -> subset L2 L3 -> subset L1 L3

subset_trans < induction on 1.


  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  ============================
   forall L1 L2 L3, subset L1 L2 @ -> subset L2 L3 -> subset L1 L3

subset_trans < intros.

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H1 : subset L1 L2 @
  H2 : subset L2 L3
  ============================
   subset L1 L3

subset_trans < case H1.
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  ============================
   subset tl_nil L3

Subgoal 2 is:
 subset (tl_cons X L4) L3

subset_trans < search.
Subgoal 2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   subset (tl_cons X L4) L3

subset_trans < unfold.
Subgoal 2.1:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   {tl_member X L3}

Subgoal 2.2 is:
 subset L4 L3

subset_trans < apply subset_mem to H2 H3.
Subgoal 2.1:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  H5 : {tl_member X L3}
  ============================
   {tl_member X L3}

Subgoal 2.2 is:
 subset L4 L3

subset_trans < search.
Subgoal 2.2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  ============================
   subset L4 L3

subset_trans < apply IH to H4 H2.
Subgoal 2.2:

  Variables: L1, L2, L3, L4, X
  IH : forall L1 L2 L3, subset L1 L2 * -> subset L2 L3 -> subset L1 L3
  H2 : subset L2 L3
  H3 : {tl_member X L2}
  H4 : subset L4 L2 *
  H5 : subset L4 L3
  ============================
   subset L4 L3

subset_trans < search.
Proof completed.

Abella < Theorem combine_subset1 : 
forall L1 L2 L3, islist L2 -> {combine L1 L2 L3} -> subset L2 L3.


  ============================
   forall L1 L2 L3, islist L2 -> {combine L1 L2 L3} -> subset L2 L3

combine_subset1 < induction on 2.


  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  ============================
   forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}@ -> subset L2 L3

combine_subset1 < intros.

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H2 : {combine L1 L2 L3}@
  ============================
   subset L2 L3

combine_subset1 < case H2.
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L3
  ============================
   subset L3 L3

Subgoal 2 is:
 subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < apply subset_refl to H1.
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L3
  H3 : subset L3 L3
  ============================
   subset L3 L3

Subgoal 2 is:
 subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < search.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {tl_member X L2}*
  H4 : {combine Fvs1 L2 L3}*
  ============================
   subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < apply IH to H1 H4 with L1 = Fvs1.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {tl_member X L2}*
  H4 : {combine Fvs1 L2 L3}*
  H5 : subset L2 L3
  ============================
   subset L2 L3

Subgoal 3 is:
 subset L2 (tl_cons X Fvs)

combine_subset1 < search.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < apply IH to H1 H3 with L1 = Fvs1.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  H4 : subset L2 Fvs
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < apply subset_one to H1 H4 with X = X.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L2 -> {combine L1 L2 L3}* -> subset L2 L3
  H1 : islist L2
  H3 : {combine Fvs1 L2 Fvs}*
  H4 : subset L2 Fvs
  H5 : subset L2 (tl_cons X Fvs)
  ============================
   subset L2 (tl_cons X Fvs)

combine_subset1 < search.
Proof completed.

Abella < Theorem combine_subset2 : 
forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} -> subset L1 L3.


  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
     subset L1 L3

combine_subset2 < induction on 3.


  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  ============================
   forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     subset L1 L3

combine_subset2 < intros.

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  ============================
   subset L1 L3

combine_subset2 < case H3.
Subgoal 1:

  Variables: L1, L2, L3
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist tl_nil
  H2 : islist L3
  ============================
   subset tl_nil L3

Subgoal 2 is:
 subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < search.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < apply combine_subset1 to H2 H5.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < apply subset_mem to H6 H4.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < case H1.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  H8 : islist Fvs1
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < apply IH to H8 H2 H5.
Subgoal 2:

  Variables: L1, L2, L3, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {tl_member X L2}*
  H5 : {combine Fvs1 L2 L3}*
  H6 : subset L2 L3
  H7 : {tl_member X L3}
  H8 : islist Fvs1
  H9 : subset Fvs1 L3
  ============================
   subset (tl_cons X Fvs1) L3

Subgoal 3 is:
 subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < search.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < case H1.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < apply IH to H5 H2 H4.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : subset Fvs1 Fvs
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < apply subset_one to H5 H6 with X = X.
Subgoal 3:

  Variables: L1, L2, L3, Fvs, Fvs1, X
  IH : forall L1 L2 L3, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L3
  H2 : islist L2
  H4 : {combine Fvs1 L2 Fvs}*
  H5 : islist Fvs1
  H6 : subset Fvs1 Fvs
  H7 : subset Fvs1 (tl_cons X Fvs)
  ============================
   subset (tl_cons X Fvs1) (tl_cons X Fvs)

combine_subset2 < search.
Proof completed.

Abella < Theorem subset_combine : 
forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
  subset L1 L4 -> subset L2 L4 -> subset L3 L4.


  ============================
   forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3} ->
     subset L1 L4 -> subset L2 L4 -> subset L3 L4

subset_combine < induction on 3.


  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  ============================
   forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}@ ->
     subset L1 L4 -> subset L2 L4 -> subset L3 L4

subset_combine < intros.

  Variables: L1, L2, L3, L4
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist L1
  H2 : islist L2
  H3 : {combine L1 L2 L3}@
  H4 : subset L1 L4
  H5 : subset L2 L4
  ============================
   subset L3 L4

subset_combine < case H3.
Subgoal 1:

  Variables: L1, L2, L3, L4
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist tl_nil
  H2 : islist L3
  H4 : subset tl_nil L4
  H5 : subset L3 L4
  ============================
   subset L3 L4

Subgoal 2 is:
 subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < search.
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < case H1.
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < case H4.
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  H9 : {tl_member X L4}
  H10 : subset Fvs1 L4
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < apply IH to H8 H2 H7 H10 H5.
Subgoal 2:

  Variables: L1, L2, L3, L4, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {tl_member X L2}*
  H7 : {combine Fvs1 L2 L3}*
  H8 : islist Fvs1
  H9 : {tl_member X L4}
  H10 : subset Fvs1 L4
  H11 : subset L3 L4
  ============================
   subset L3 L4

Subgoal 3 is:
 subset (tl_cons X Fvs) L4

subset_combine < search.
Subgoal 3:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H4 : subset (tl_cons X Fvs1) L4
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  ============================
   subset (tl_cons X Fvs) L4

subset_combine < case H4.
Subgoal 3:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   subset (tl_cons X Fvs) L4

subset_combine < unfold.
Subgoal 3.1:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   {tl_member X L4}

Subgoal 3.2 is:
 subset Fvs L4

subset_combine < search.
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H1 : islist (tl_cons X Fvs1)
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  ============================
   subset Fvs L4

subset_combine < case H1.
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  H9 : islist Fvs1
  ============================
   subset Fvs L4

subset_combine < apply IH to H9 H2 H6 H8 H5.
Subgoal 3.2:

  Variables: L1, L2, L3, L4, Fvs, Fvs1, X
  IH : forall L1 L2 L3 L4, islist L1 -> islist L2 -> {combine L1 L2 L3}* ->
         subset L1 L4 -> subset L2 L4 -> subset L3 L4
  H2 : islist L2
  H5 : subset L2 L4
  H6 : {combine Fvs1 L2 Fvs}*
  H7 : {tl_member X L4}
  H8 : subset Fvs1 L4
  H9 : islist Fvs1
  H10 : subset Fvs L4
  ============================
   subset Fvs L4

subset_combine < search.
Proof completed.

Abella < Theorem fvars_islist : 
forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> islist Vs'.


  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> islist Vs'

fvars_islist < induction on 2.


  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}@ -> islist Vs'

fvars_islist < intros.

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   islist Vs'

fvars_islist < case H2.
Subgoal 1:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   islist tl_nil

Subgoal 2 is:
 islist tl_nil

Subgoal 3 is:
 islist (tl_cons M tl_nil)

Subgoal 4 is:
 islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < search.
Subgoal 2:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  ============================
   islist tl_nil

Subgoal 3 is:
 islist (tl_cons M tl_nil)

Subgoal 4 is:
 islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < search.
Subgoal 3:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   islist (tl_cons M tl_nil)

Subgoal 4 is:
 islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < search.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < apply IH to H1 H3.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  ============================
   islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < apply IH to H1 H4.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  ============================
   islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < apply combine_bvar to H1 H5.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  H8 : {combine Fvs1 Fvs2 Vs'}
  ============================
   islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < apply combine_islist to H6 H7 H8.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : islist Fvs1
  H7 : islist Fvs2
  H8 : {combine Fvs1 Fvs2 Vs'}
  H9 : islist Vs'
  ============================
   islist Vs'

Subgoal 5 is:
 islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < search.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < assert bvars (notfree n1 :: Ps).
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < apply IH to H4 H3.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : islist Vs'
  ============================
   islist Vs'

Subgoal 6 is:
 islist Vs'

fvars_islist < search.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, F
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   islist Vs'

fvars_islist < apply bvars_mem to H1 H4.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, F, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* -> islist Vs'
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- fvars M Vs Vs'}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   islist Vs'

fvars_islist < case H3.
Proof completed.

Abella < Theorem fvars_subset : 
forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> subset Vs' Vs.


  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'} -> subset Vs' Vs

fvars_subset < induction on 2.


  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  ============================
   forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}@ -> subset Vs' Vs

fvars_subset < intros.

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   subset Vs' Vs

fvars_subset < case H2.
Subgoal 1:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   subset tl_nil Vs

Subgoal 2 is:
 subset tl_nil Vs

Subgoal 3 is:
 subset (tl_cons M tl_nil) Vs

Subgoal 4 is:
 subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < search.
Subgoal 2:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  ============================
   subset tl_nil Vs

Subgoal 3 is:
 subset (tl_cons M tl_nil) Vs

Subgoal 4 is:
 subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < search.
Subgoal 3:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   subset (tl_cons M tl_nil) Vs

Subgoal 4 is:
 subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < apply tl_mem_bvar to H1 H3.
Subgoal 3:

  Variables: M, Vs, Vs', Ps
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  H4 : {tl_member M Vs}
  ============================
   subset (tl_cons M tl_nil) Vs

Subgoal 4 is:
 subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < search.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < apply IH to H1 H3.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < apply IH to H1 H4.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < apply fvars_islist to H1 H3.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < apply fvars_islist to H1 H4.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < apply combine_bvar to H1 H5.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  H10 : {combine Fvs1 Fvs2 Vs'}
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < apply subset_combine to H8 H9 H10 H6 H7.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : subset Fvs1 Vs
  H7 : subset Fvs2 Vs
  H8 : islist Fvs1
  H9 : islist Fvs2
  H10 : {combine Fvs1 Fvs2 Vs'}
  H11 : subset Vs' Vs
  ============================
   subset Vs' Vs

Subgoal 5 is:
 subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < search.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < assert bvars (notfree n1 :: Ps).
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < apply IH to H4 H3.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, M1
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : subset Vs' Vs
  ============================
   subset Vs' Vs

Subgoal 6 is:
 subset Vs' Vs

fvars_subset < search.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, F
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   subset Vs' Vs

fvars_subset < apply bvars_mem to H1 H4.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, F, X
  IH : forall M Vs Vs' Ps, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         subset Vs' Vs
  H1 : bvars Ps
  H3 : {Ps, [notfree X] |- fvars M Vs Vs'}*
  H4 : member (notfree X) Ps
  H5 : tname X
  ============================
   subset Vs' Vs

fvars_subset < case H3.
Proof completed.

Abella < Theorem fvars_extend : 
forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'} ->
  {Ps |- fvars M (tl_cons X Vs) Vs'}.


  ============================
   forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'} ->
     {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < induction on 2.


  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  ============================
   forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}@ ->
     {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < intros.

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H2 : {Ps |- fvars M Vs Vs'}@
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < case H2.
Subgoal 1:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- notfree M}*
  ============================
   {Ps |- fvars M (tl_cons X Vs) tl_nil}

Subgoal 2 is:
 {Ps |- fvars (lnat X2) (tl_cons X Vs) tl_nil}

Subgoal 3 is:
 {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < search.
Subgoal 2:

  Variables: M, Vs, Vs', Ps, X, X2
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  ============================
   {Ps |- fvars (lnat X2) (tl_cons X Vs) tl_nil}

Subgoal 3 is:
 {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < search.
Subgoal 3:

  Variables: M, Vs, Vs', Ps, X
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- tl_member M Vs}*
  ============================
   {Ps |- fvars M (tl_cons X Vs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < search.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < apply IH to H1 H3 with X = X.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : {Ps |- fvars M1 (tl_cons X Vs) Fvs1}
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < apply IH to H1 H4 with X = X.
Subgoal 4:

  Variables: M, Vs, Vs', Ps, X, Fvs2, Fvs1, M2, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps |- fvars M1 Vs Fvs1}*
  H4 : {Ps |- fvars M2 Vs Fvs2}*
  H5 : {Ps |- combine Fvs1 Fvs2 Vs'}*
  H6 : {Ps |- fvars M1 (tl_cons X Vs) Fvs1}
  H7 : {Ps |- fvars M2 (tl_cons X Vs) Fvs2}
  ============================
   {Ps |- fvars (app M1 M2) (tl_cons X Vs) Vs'}

Subgoal 5 is:
 {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < search.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < assert bvars (notfree n1 :: Ps).
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < apply IH to H4 H3 with X = X.
Subgoal 5:

  Variables: M, Vs, Vs', Ps, X, M1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, notfree n1 |- fvars (M1 n1) Vs Vs'}*
  H4 : bvars (notfree n1 :: Ps)
  H5 : {Ps, notfree n1 |- fvars (M1 n1) (tl_cons X Vs) Vs'}
  ============================
   {Ps |- fvars (abs M1) (tl_cons X Vs) Vs'}

Subgoal 6 is:
 {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < search.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, X, F
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, [F] |- fvars M Vs Vs'}*
  H4 : member F Ps
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < apply bvars_mem to H1 H4.
Subgoal 6:

  Variables: M, Vs, Vs', Ps, X, F, X1
  IH : forall M Vs Vs' Ps X, bvars Ps -> {Ps |- fvars M Vs Vs'}* ->
         {Ps |- fvars M (tl_cons X Vs) Vs'}
  H1 : bvars Ps
  H3 : {Ps, [notfree X1] |- fvars M Vs Vs'}*
  H4 : member (notfree X1) Ps
  H5 : tname X1
  ============================
   {Ps |- fvars M (tl_cons X Vs) Vs'}

fvars_extend < case H3.
Proof completed.

Abella < Define pruned_env : olist -> tm_list -> olist -> olist -> prop by 
pruned_env nil tl_nil SL nil;
pruned_env nil (tl_cons X FVs) SL (of X T :: SL') := member (of X T) SL /\ pruned_env nil FVs SL SL';
nabla x, pruned_env (notfree x :: BVs) FVs (of x T :: SL) (of x T :: SL') := pruned_env BVs FVs SL SL'.

Abella < Theorem pruned_env_vars : 
forall FVs SL SL', pruned_env nil FVs SL SL' -> vars_of_sctx SL' FVs.


  ============================
   forall FVs SL SL', pruned_env nil FVs SL SL' -> vars_of_sctx SL' FVs

pruned_env_vars < induction on 1.


  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  ============================
   forall FVs SL SL', pruned_env nil FVs SL SL' @ -> vars_of_sctx SL' FVs

pruned_env_vars < intros.

  Variables: FVs, SL, SL'
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H1 : pruned_env nil FVs SL SL' @
  ============================
   vars_of_sctx SL' FVs

pruned_env_vars < case H1.
Subgoal 1:

  Variables: FVs, SL, SL'
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  ============================
   vars_of_sctx nil tl_nil

Subgoal 2 is:
 vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < search.
Subgoal 2:

  Variables: FVs, SL, SL', SL'1, T, X, FVs1
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H2 : member (of X T) SL
  H3 : pruned_env nil FVs1 SL SL'1 *
  ============================
   vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < apply IH to H3.
Subgoal 2:

  Variables: FVs, SL, SL', SL'1, T, X, FVs1
  IH : forall FVs SL SL', pruned_env nil FVs SL SL' * -> vars_of_sctx SL' FVs
  H2 : member (of X T) SL
  H3 : pruned_env nil FVs1 SL SL'1 *
  H4 : vars_of_sctx SL'1 FVs1
  ============================
   vars_of_sctx (of X T :: SL'1) (tl_cons X FVs1)

pruned_env_vars < search.
Proof completed.

Abella < Theorem pruned_env_sctx_source : 
forall FV SL SL' X T, pruned_env nil FV SL SL' -> member (of X T) SL' ->
  member (of X T) SL.


  ============================
   forall FV SL SL' X T, pruned_env nil FV SL SL' -> member (of X T) SL' ->
     member (of X T) SL

pruned_env_sctx_source < induction on 1.


  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  ============================
   forall FV SL SL' X T, pruned_env nil FV SL SL' @ -> member (of X T) SL' ->
     member (of X T) SL

pruned_env_sctx_source < intros.

  Variables: FV, SL, SL', X, T
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H1 : pruned_env nil FV SL SL' @
  H2 : member (of X T) SL'
  ============================
   member (of X T) SL

pruned_env_sctx_source < case H1.
Subgoal 1:

  Variables: FV, SL, SL', X, T
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H2 : member (of X T) nil
  ============================
   member (of X T) SL

Subgoal 2 is:
 member (of X T) SL

pruned_env_sctx_source < case H2.
Subgoal 2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H2 : member (of X T) (of X1 T1 :: SL'1)
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  ============================
   member (of X T) SL

pruned_env_sctx_source < case H2.
Subgoal 2.1:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  ============================
   member (of X1 T1) SL

Subgoal 2.2 is:
 member (of X T) SL

pruned_env_sctx_source < search.
Subgoal 2.2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  H5 : member (of X T) SL'1
  ============================
   member (of X T) SL

pruned_env_sctx_source < apply IH to H4 H5.
Subgoal 2.2:

  Variables: FV, SL, SL', X, T, SL'1, T1, X1, FVs
  IH : forall FV SL SL' X T, pruned_env nil FV SL SL' * ->
         member (of X T) SL' -> member (of X T) SL
  H3 : member (of X1 T1) SL
  H4 : pruned_env nil FVs SL SL'1 *
  H5 : member (of X T) SL'1
  H6 : member (of X T) SL
  ============================
   member (of X T) SL

pruned_env_sctx_source < search.
Proof completed.

Abella < Theorem pruned_env_sctx : 
forall SL BVL FVs SL', sctx' SL -> bvars BVL -> pruned_env BVL FVs SL SL' ->
  sctx' SL'.


  ============================
   forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
     pruned_env BVL FVs SL SL' -> sctx' SL'

pruned_env_sctx < induction on 3.


  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  ============================
   forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
     pruned_env BVL FVs SL SL' @ -> sctx' SL'

pruned_env_sctx < intros.

  Variables: SL, BVL, FVs, SL'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars BVL
  H3 : pruned_env BVL FVs SL SL' @
  ============================
   sctx' SL'

pruned_env_sctx < case H3.
Subgoal 1:

  Variables: SL, BVL, FVs, SL'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  ============================
   sctx' nil

Subgoal 2 is:
 sctx' (of X T :: SL'1)

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < search.
Subgoal 2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   sctx' (of X T :: SL'1)

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < unfold.
Subgoal 2.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   sctx' SL'1

Subgoal 2.2 is:
 tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < apply IH to H1 H2 H5.
Subgoal 2.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : sctx' SL'1
  ============================
   sctx' SL'1

Subgoal 2.2 is:
 tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < search.
Subgoal 2.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < apply sctx'_name to H1 H4.
Subgoal 2.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : tname X
  ============================
   tname X

Subgoal 2.3 is:
 forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < search.
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   forall T', member (of X T') SL'1 -> T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < intros.
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  ============================
   T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < apply pruned_env_sctx_source to H5 H6.
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  H7 : member (of X T') SL
  ============================
   T = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < apply sctx'_equal to H1 H4 H7.
Subgoal 2.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, X, FVs1, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' SL
  H2 : bvars nil
  H4 : member (of X T') SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  H6 : member (of X T') SL'1
  H7 : member (of X T') SL
  ============================
   T' = T'

Subgoal 3 is:
 sctx' (of n1 T :: SL'1)

pruned_env_sctx < search.
Subgoal 3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   sctx' (of n1 T :: SL'1)

pruned_env_sctx < unfold.
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < case H1.
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < case H2.
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  H8 : bvars BVs
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < apply IH to H5 H8 H4.
Subgoal 3.1:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : sctx' SL1
  H6 : tname n1
  H7 : forall T', member (of n1 T') SL1 -> T = T'
  H8 : bvars BVs
  H9 : sctx' SL'1
  ============================
   sctx' SL'1

Subgoal 3.2 is:
 tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < search.
Subgoal 3.2:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   tname n1

Subgoal 3.3 is:
 forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < search.
Subgoal 3.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   forall T', member (of n1 T') SL'1 -> T = T'

pruned_env_sctx < intros.
Subgoal 3.3:

  Variables: SL, BVL, FVs, SL', SL'1, T, SL1, FVs1, BVs, T'
  IH : forall SL BVL FVs SL', sctx' SL -> bvars BVL ->
         pruned_env BVL FVs SL SL' * -> sctx' SL'
  H1 : sctx' (of n1 T :: SL1)
  H2 : bvars (notfree n1 :: BVs)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (of n1 T') SL'1
  ============================
   T = T'

pruned_env_sctx < apply mem_of_absurd to H5.
Proof completed.

Abella < Theorem pruned_env_bound : 
forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' ->
  member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'.


  ============================
   forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' ->
     member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'

pruned_env_bound < induction on 1.


  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  ============================
   forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' @ ->
     member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'

pruned_env_bound < intros.

  Variables: BVL, FVs, SL, SL', X, T
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H1 : pruned_env BVL FVs SL SL' @
  H2 : member (notfree X) BVL
  H3 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_bound < case H1.
Subgoal 1:

  Variables: BVL, FVs, SL, SL', X, T
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree X) nil
  H3 : member (of X T) SL
  ============================
   member (of X T) nil

Subgoal 2 is:
 member (of X T) (of X1 T1 :: SL'1)

Subgoal 3 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < case H2.
Subgoal 2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, X1, FVs1
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree X) nil
  H3 : member (of X T) SL
  H4 : member (of X1 T1) SL
  H5 : pruned_env nil FVs1 SL SL'1 *
  ============================
   member (of X T) (of X1 T1 :: SL'1)

Subgoal 3 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < case H2.
Subgoal 3:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H2 : member (notfree (X n1)) (notfree n1 :: BVs)
  H3 : member (of (X n1) T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < case H2.
Subgoal 3.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H3 : member (of n1 T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < case H3.
Subgoal 3.1.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 3.1.2 is:
 member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < search.
Subgoal 3.1.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (of n1 T) SL1
  ============================
   member (of n1 T) (of n1 T1 :: SL'1)

Subgoal 3.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < apply mem_of_absurd to H5.
Subgoal 3.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H3 : member (of (X n1) T) (of n1 T1 :: SL1)
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < case H3.
Subgoal 3.2.1:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree n1) BVs
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 3.2.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < search.
Subgoal 3.2.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  H6 : member (of (X n1) T) SL1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < apply IH to H4 H5 H6.
Subgoal 3.2.2:

  Variables: BVL, FVs, SL, SL', X, T, SL'1, T1, SL1, FVs1, BVs
  IH : forall BVL FVs SL SL' X T, pruned_env BVL FVs SL SL' * ->
         member (notfree X) BVL -> member (of X T) SL -> member (of X T) SL'
  H4 : pruned_env BVs FVs1 SL1 SL'1 *
  H5 : member (notfree (X n1)) BVs
  H6 : member (of (X n1) T) SL1
  H7 : member (of (X n1) T) SL'1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_bound < search.
Proof completed.

Abella < Theorem pruned_env_free_aux : 
forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
  {tl_member X FVs} -> member (of X T) SL -> member (of X T) SL'.


  ============================
   forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
     {tl_member X FVs} -> member (of X T) SL -> member (of X T) SL'

pruned_env_free_aux < induction on 3.


  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  ============================
   forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
     {tl_member X FVs}@ -> member (of X T) SL -> member (of X T) SL'

pruned_env_free_aux < intros.

  Variables: FVs, SL, SL', X, T
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil FVs SL SL'
  H3 : {tl_member X FVs}@
  H4 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_free_aux < case H3.
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil (tl_cons X L) SL SL'
  H4 : member (of X T) SL
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < case H2.
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : member (of X T1) SL
  H6 : pruned_env nil L SL SL'1
  ============================
   member (of X T) (of X T1 :: SL'1)

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < apply sctx'_equal to H1 H4 H5.
Subgoal 1:

  Variables: FVs, SL, SL', X, T, L, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T1) SL
  H5 : member (of X T1) SL
  H6 : pruned_env nil L SL SL'1
  ============================
   member (of X T1) (of X T1 :: SL'1)

Subgoal 2 is:
 member (of X T) SL'

pruned_env_free_aux < search.
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : pruned_env nil (tl_cons Y L) SL SL'
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  ============================
   member (of X T) SL'

pruned_env_free_aux < case H2.
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  H6 : member (of Y T1) SL
  H7 : pruned_env nil L SL SL'1
  ============================
   member (of X T) (of Y T1 :: SL'1)

pruned_env_free_aux < apply IH to H1 H7 H5 H4.
Subgoal 2:

  Variables: FVs, SL, SL', X, T, L, Y, SL'1, T1
  IH : forall FVs SL SL' X T, sctx' SL -> pruned_env nil FVs SL SL' ->
         {tl_member X FVs}* -> member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H4 : member (of X T) SL
  H5 : {tl_member X L}*
  H6 : member (of Y T1) SL
  H7 : pruned_env nil L SL SL'1
  H8 : member (of X T) SL'1
  ============================
   member (of X T) (of Y T1 :: SL'1)

pruned_env_free_aux < search.
Proof completed.

Abella < Theorem pruned_env_free : 
forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
  pruned_env BVLs FVs SL SL' -> {tl_member X FVs} -> member (of X T) SL ->
  member (of X T) SL'.


  ============================
   forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
     pruned_env BVLs FVs SL SL' -> {tl_member X FVs} -> member (of X T) SL ->
     member (of X T) SL'

pruned_env_free < induction on 3.


  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  ============================
   forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
     pruned_env BVLs FVs SL SL' @ -> {tl_member X FVs} ->
     member (of X T) SL -> member (of X T) SL'

pruned_env_free < intros.

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H2 : bvars BVLs
  H3 : pruned_env BVLs FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  ============================
   member (of X T) SL'

pruned_env_free < case H2.
Subgoal 1:

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H3 : pruned_env nil FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of (X n1) T) (SL' n1)

pruned_env_free < apply pruned_env_free_aux to H1 H3 H4 H5.
Subgoal 1:

  Variables: BVLs, FVs, SL, SL', X, T
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' SL
  H3 : pruned_env nil FVs SL SL' @
  H4 : {tl_member X FVs}
  H5 : member (of X T) SL
  H6 : member (of X T) SL'
  ============================
   member (of X T) SL'

Subgoal 2 is:
 member (of (X n1) T) (SL' n1)

pruned_env_free < search.
Subgoal 2:

  Variables: BVLs, FVs, SL, SL', X, T, L
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (SL n1)
  H3 : pruned_env (notfree n1 :: L) (FVs n1) (SL n1) (SL' n1) @
  H4 : {tl_member (X n1) (FVs n1)}
  H5 : member (of (X n1) T) (SL n1)
  H6 : bvars L
  ============================
   member (of (X n1) T) (SL' n1)

pruned_env_free < case H3.
Subgoal 2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H5 : member (of (X n1) T) (of n1 T1 :: SL1)
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < case H5.
Subgoal 2.1:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member n1 FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  ============================
   member (of n1 T1) (of n1 T1 :: SL'1)

Subgoal 2.2 is:
 member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < search.
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < assert bvars (notfree n1 :: L).
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H1 : sctx' (of n1 T1 :: SL1)
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < case H1.
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  H10 : sctx' SL1
  H11 : tname n1
  H12 : forall T', member (of n1 T') SL1 -> T1 = T'
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < apply IH to H10 H6 H7 H4 H8.
Subgoal 2.2:

  Variables: BVLs, FVs, SL, SL', X, T, L, SL'1, T1, SL1, FVs1
  IH : forall BVLs FVs SL SL' X T, sctx' SL -> bvars BVLs ->
         pruned_env BVLs FVs SL SL' * -> {tl_member X FVs} ->
         member (of X T) SL -> member (of X T) SL'
  H4 : {tl_member (X n1) FVs1}
  H6 : bvars L
  H7 : pruned_env L FVs1 SL1 SL'1 *
  H8 : member (of (X n1) T) SL1
  H9 : bvars (notfree n1 :: L)
  H10 : sctx' SL1
  H11 : tname n1
  H12 : forall T', member (of n1 T') SL1 -> T1 = T'
  H13 : member (of (X n1) T) SL'1
  ============================
   member (of (X n1) T) (of n1 T1 :: SL'1)

pruned_env_free < search.
Proof completed.

Abella < Theorem pruned_env_typing : 
forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T} ->
  vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
  subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}.


  ============================
   forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T} ->
     vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
     subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}

pruned_env_typing < induction on 2.


  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  ============================
   forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}@ ->
     vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
     subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}

pruned_env_typing < intros.

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs''
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H2 : {SL |- of M T}@
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  ============================
   {SL' |- of M T}

pruned_env_typing < case H2.
Subgoal 1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (lnat X) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  ============================
   {SL' |- of (lnat X) nat_t}

Subgoal 2 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < search.
Subgoal 2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (app M1 N) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < case H5.
Subgoal 2.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- notfree (app M1 N)}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.2 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply bvars_notfree to H4 H10.
Subgoal 2.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- notfree (app M1 N)}
  H11 : tname (app M1 N)
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.2 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < case H11.
Subgoal 2.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply tl_mem_bvar to H4 H10.
Subgoal 2.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  H11 : {tl_member (app M1 N) FVs}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply vars_of_sctx_mem_name to H1 H3 H11.
Subgoal 2.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (app M1 N) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- tl_member (app M1 N) FVs}
  H11 : {tl_member (app M1 N) FVs}
  H12 : tname (app M1 N)
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.3 is:
 {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < case H12.
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply fvars_islist to H4 H10.
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply fvars_islist to H4 H11.
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply combine_bvar to H4 H12.
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply combine_islist to H13 H14 H15.
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply combine_subset2 to H13 H14 H15.
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply subset_trans to H17 H6.
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply IH to H1 H8 H3 H4 H10 H18 H7.
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply combine_subset1 to H14 H15.
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply subset_trans to H20 H6.
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  H21 : subset Fvs2 FVs''
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply IH to H1 H9 H3 H4 H11 H21 H7.
Subgoal 2.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, Fvs2, Fvs1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL |- fvars M1 FVs Fvs1}
  H11 : {BVL |- fvars N FVs Fvs2}
  H12 : {BVL |- combine Fvs1 Fvs2 FVs'}
  H13 : islist Fvs1
  H14 : islist Fvs2
  H15 : {combine Fvs1 Fvs2 FVs'}
  H16 : islist FVs'
  H17 : subset Fvs1 FVs'
  H18 : subset Fvs1 FVs''
  H19 : {SL' |- of M1 (arr T1 T)}
  H20 : subset Fvs2 FVs'
  H21 : subset Fvs2 FVs''
  H22 : {SL' |- of N T1}
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 2.4 is:
 {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < search.
Subgoal 2.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL, [F] |- fvars (app M1 N) FVs FVs'}
  H11 : member F BVL
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply bvars_mem to H4 H11.
Subgoal 2.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T1, N, M1, F, X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL |- of M1 (arr T1 T)}*
  H9 : {SL |- of N T1}*
  H10 : {BVL, [notfree X] |- fvars (app M1 N) FVs FVs'}
  H11 : member (notfree X) BVL
  H12 : tname X
  ============================
   {SL' |- of (app M1 N) T}

Subgoal 3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < case H10.
Subgoal 3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars (abs M1) FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < case H5.
Subgoal 3.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- notfree (abs M1)}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.2 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply bvars_notfree to H4 H9.
Subgoal 3.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset tl_nil FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- notfree (abs M1)}
  H10 : tname (abs M1)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.2 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < case H10.
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply tl_mem_bvar to H4 H9.
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  H10 : {tl_member (abs M1) FVs}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply vars_of_sctx_mem_name to H1 H3 H10.
Subgoal 3.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset (tl_cons (abs M1) tl_nil) FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL |- tl_member (abs M1) FVs}
  H10 : {tl_member (abs M1) FVs}
  H11 : tname (abs M1)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.3 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < case H11.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < assert pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL').
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < assert bvars (notfree n1 :: BVL).
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < assert vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs).
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply sctx'_extend to H1 with T = T1.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply fvars_extend to H11 H9 with X = n1.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  H14 : {BVL, notfree n1 |- fvars (M1 n1) (tl_cons n1 FVs) FVs'}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply IH to H13 H8 H12 H11 H14 H6 H10.
Subgoal 3.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, notfree n1 |- fvars (M1 n1) FVs FVs'}
  H10 : pruned_env (notfree n1 :: BVL) FVs'' (of n1 T1 :: SL) (of n1 T1 :: SL')
  H11 : bvars (notfree n1 :: BVL)
  H12 : vars_of_sctx (of n1 T1 :: SL) (tl_cons n1 FVs)
  H13 : sctx' (of n1 T1 :: SL)
  H14 : {BVL, notfree n1 |- fvars (M1 n1) (tl_cons n1 FVs) FVs'}
  H15 : {SL', of n1 T1 |- of (M1 n1) T2}
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 3.4 is:
 {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < search.
Subgoal 3.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1, F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, [F] |- fvars (abs M1) FVs FVs'}
  H10 : member F BVL
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < apply bvars_mem to H4 H10.
Subgoal 3.4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', T2, M1, T1, F, X
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, of n1 T1 |- of (M1 n1) T2}*
  H9 : {BVL, [notfree X] |- fvars (abs M1) FVs FVs'}
  H10 : member (notfree X) BVL
  H11 : tname X
  ============================
   {SL' |- of (abs M1) (arr T1 T2)}

Subgoal 4 is:
 {SL' |- of M T}

pruned_env_typing < case H9.
Subgoal 4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, [F] |- of M T}*
  H9 : member F SL
  ============================
   {SL' |- of M T}

pruned_env_typing < apply sctx'_mem to H1 H9.
Subgoal 4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H8 : {SL, [of X T1] |- of M T}*
  H9 : member (of X T1) SL
  H10 : tname X
  ============================
   {SL' |- of M T}

pruned_env_typing < case H8.
Subgoal 4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' SL
  H3 : vars_of_sctx SL FVs
  H4 : bvars BVL
  H5 : {BVL |- fvars M FVs FVs'}
  H6 : subset FVs' FVs''
  H7 : pruned_env BVL FVs'' SL SL'
  H9 : member (of M T) SL
  H10 : tname M
  ============================
   {SL' |- of M T}

pruned_env_typing < case H10.
Subgoal 4:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H5 : {BVL n1 |- fvars n1 (FVs n1) (FVs' n1)}
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < case H5.
Subgoal 4.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- notfree n1}
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < case H11.
Subgoal 4.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [F1 n1] |- notfree n1}
  H13 : member (F1 n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < apply bvars_mem to H4 H13.
Subgoal 4.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree (X1 n1)] |- notfree n1}
  H13 : member (notfree (X1 n1)) (BVL n1)
  H14 : tname (X1 n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < case H14.
Subgoal 4.1.1:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n2 n1)
  H3 : vars_of_sctx (SL n2 n1) (FVs n2 n1)
  H4 : bvars (BVL n2 n1)
  H6 : subset tl_nil (FVs'' n2 n1)
  H7 : pruned_env (BVL n2 n1) (FVs'' n2 n1) (SL n2 n1) (SL' n2 n1)
  H9 : member (of n1 T) (SL n2 n1)
  H12 : {BVL n2 n1, [notfree n2] |- notfree n1}
  H13 : member (notfree n2) (BVL n2 n1)
  ============================
   {SL' n2 n1 |- of n1 T}

Subgoal 4.1.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < case H12.
Subgoal 4.1.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree n1] |- notfree n1}
  H13 : member (notfree n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < apply pruned_env_bound to H7 H13 H9.
Subgoal 4.1.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset tl_nil (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H12 : {BVL n1, [notfree n1] |- notfree n1}
  H13 : member (notfree n1) (BVL n1)
  H15 : member (of n1 T) (SL' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.2 is:
 {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < search.
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (tl_cons n1 tl_nil) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < case H6.
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  H12 : {tl_member n1 (FVs'' n1)}
  H13 : subset tl_nil (FVs'' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < apply pruned_env_free to H1 H4 H7 H12 H9.
Subgoal 4.2:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1 |- tl_member n1 (FVs n1)}
  H12 : {tl_member n1 (FVs'' n1)}
  H13 : subset tl_nil (FVs'' n1)
  H14 : member (of n1 T) (SL' n1)
  ============================
   {SL' n1 |- of n1 T}

Subgoal 4.3 is:
 {SL' n1 |- of n1 T}

pruned_env_typing < search.
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1, [F1 n1] |- fvars n1 (FVs n1) (FVs' n1)}
  H12 : member (F1 n1) (BVL n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < apply bvars_mem to H4 H12.
Subgoal 4.3:

  Variables: SL, M, T, FVs, BVL, FVs', SL', FVs'', F, X, T1, F1, X1
  IH : forall SL M T FVs BVL FVs' SL' FVs'', sctx' SL -> {SL |- of M T}* ->
         vars_of_sctx SL FVs -> bvars BVL -> {BVL |- fvars M FVs FVs'} ->
         subset FVs' FVs'' -> pruned_env BVL FVs'' SL SL' -> {SL' |- of M T}
  H1 : sctx' (SL n1)
  H3 : vars_of_sctx (SL n1) (FVs n1)
  H4 : bvars (BVL n1)
  H6 : subset (FVs' n1) (FVs'' n1)
  H7 : pruned_env (BVL n1) (FVs'' n1) (SL n1) (SL' n1)
  H9 : member (of n1 T) (SL n1)
  H11 : {BVL n1, [notfree (X1 n1)] |- fvars n1 (FVs n1) (FVs' n1)}
  H12 : member (notfree (X1 n1)) (BVL n1)
  H13 : tname (X1 n1)
  ============================
   {SL' n1 |- of n1 T}

pruned_env_typing < case H11.
Proof completed.

Abella < Theorem mapvar_named_map : 
forall L FVs Map X, sctx' L -> vars_of_sctx L FVs -> {mapvar FVs Map} ->
  name_map (Map X).


  ============================
   forall L FVs Map X, sctx' L -> vars_of_sctx L FVs -> {mapvar FVs Map} ->
     name_map (Map X)

mapvar_named_map < induction on 1.


  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  ============================
   forall L FVs Map X, sctx' L @ -> vars_of_sctx L FVs -> {mapvar FVs Map} ->
     name_map (Map X)

mapvar_named_map < intros.

  Variables: L, FVs, Map, X
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H1 : sctx' L @
  H2 : vars_of_sctx L FVs
  H3 : {mapvar FVs Map}
  ============================
   name_map (Map X)

mapvar_named_map < case H1.
Subgoal 1:

  Variables: L, FVs, Map, X
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H2 : vars_of_sctx nil FVs
  H3 : {mapvar FVs Map}
  ============================
   name_map (Map X)

Subgoal 2 is:
 name_map (Map X)

mapvar_named_map < case H2.
Subgoal 1:

  Variables: L, FVs, Map, X
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H3 : {mapvar tl_nil Map}
  ============================
   name_map (Map X)

Subgoal 2 is:
 name_map (Map X)

mapvar_named_map < case H3.
Subgoal 1:

  Variables: L, FVs, Map, X
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  ============================
   name_map ml_nil

Subgoal 2 is:
 name_map (Map X)

mapvar_named_map < search.
Subgoal 2:

  Variables: L, FVs, Map, X, L1, T, X1
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H2 : vars_of_sctx (of X1 T :: L1) FVs
  H3 : {mapvar FVs Map}
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  ============================
   name_map (Map X)

mapvar_named_map < case H2.
Subgoal 2:

  Variables: L, FVs, Map, X, L1, T, X1, Vs
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H3 : {mapvar (tl_cons X1 Vs) Map}
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  H7 : vars_of_sctx L1 Vs
  ============================
   name_map (Map X)

mapvar_named_map < case H3.
Subgoal 2:

  Variables: L, FVs, Map, X, L1, T, X1, Vs, Map1
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  H7 : vars_of_sctx L1 Vs
  H8 : {mapvar Vs Map1}
  ============================
   name_map (ml_cons (map X1 (fst X)) (Map1 (rst X)))

mapvar_named_map < apply IH to H4 H7 H8 with X = rst X.
Subgoal 2:

  Variables: L, FVs, Map, X, L1, T, X1, Vs, Map1
  IH : forall L FVs Map X, sctx' L * -> vars_of_sctx L FVs ->
         {mapvar FVs Map} -> name_map (Map X)
  H4 : sctx' L1 *
  H5 : tname X1
  H6 : forall T', member (of X1 T') L1 -> T = T'
  H7 : vars_of_sctx L1 Vs
  H8 : {mapvar Vs Map1}
  H9 : name_map (Map1 (rst X))
  ============================
   name_map (ml_cons (map X1 (fst X)) (Map1 (rst X)))

mapvar_named_map < search.
Proof completed.

Abella < Define sim : ty -> tm -> ctm -> prop,	
equiv : ty -> tm -> ctm -> prop by 
sim T M N := exists V V', {eval M V} /\ {evalcc N V'} /\ equiv T V V';
equiv nat_t (lnat N) (clnat N);
equiv (arr T1 T2) M N := {tm M} /\ {ctm N} /\ {val M} /\ {cval N} /\ (forall V1 V1',
  equiv T1 V1 V1' ->
  sim T2 (app M V1) (cunpair N (f\env\capp f (cross V1' env)))).
Warning: Definition might not be stratified

Abella < Theorem equiv_val : 
forall T V V', equiv T V V' -> {val V}.


  ============================
   forall T V V', equiv T V V' -> {val V}

equiv_val < intros.

  Variables: T, V, V'
  H1 : equiv T V V'
  ============================
   {val V}

equiv_val < case H1.
Subgoal 1:

  Variables: T, V, V', N
  ============================
   {val (lnat N)}

Subgoal 2 is:
 {val V}

equiv_val < search.
Subgoal 2:

  Variables: T, V, V', T2, T1
  H2 : {tm V}
  H3 : {ctm V'}
  H4 : {val V}
  H5 : {cval V'}
  H6 : forall V1 V1', equiv T1 V1 V1' ->
         sim T2 (app V V1) (cunpair V' (f\env\capp f (cross V1' env)))
  ============================
   {val V}

equiv_val < search.
Proof completed.

Abella < Theorem equiv_cval : 
forall T V V', equiv T V V' -> {cval V'}.


  ============================
   forall T V V', equiv T V V' -> {cval V'}

equiv_cval < intros.

  Variables: T, V, V'
  H1 : equiv T V V'
  ============================
   {cval V'}

equiv_cval < case H1.
Subgoal 1:

  Variables: T, V, V', N
  ============================
   {cval (clnat N)}

Subgoal 2 is:
 {cval V'}

equiv_cval < search.
Subgoal 2:

  Variables: T, V, V', T2, T1
  H2 : {tm V}
  H3 : {ctm V'}
  H4 : {val V}
  H5 : {cval V'}
  H6 : forall V1 V1', equiv T1 V1 V1' ->
         sim T2 (app V V1) (cunpair V' (f\env\capp f (cross V1' env)))
  ============================
   {cval V'}

equiv_cval < search.
Proof completed.

Abella < Theorem equiv_closed_tm : 
forall T V V', equiv T V V' -> {tm V}.


  ============================
   forall T V V', equiv T V V' -> {tm V}

equiv_closed_tm < intros.

  Variables: T, V, V'
  H1 : equiv T V V'
  ============================
   {tm V}

equiv_closed_tm < case H1.
Subgoal 1:

  Variables: T, V, V', N
  ============================
   {tm (lnat N)}

Subgoal 2 is:
 {tm V}

equiv_closed_tm < search.
Subgoal 2:

  Variables: T, V, V', T2, T1
  H2 : {tm V}
  H3 : {ctm V'}
  H4 : {val V}
  H5 : {cval V'}
  H6 : forall V1 V1', equiv T1 V1 V1' ->
         sim T2 (app V V1) (cunpair V' (f\env\capp f (cross V1' env)))
  ============================
   {tm V}

equiv_closed_tm < search.
Proof completed.

Abella < Theorem equiv_closed_ctm : 
forall T V V', equiv T V V' -> {ctm V'}.


  ============================
   forall T V V', equiv T V V' -> {ctm V'}

equiv_closed_ctm < intros.

  Variables: T, V, V'
  H1 : equiv T V V'
  ============================
   {ctm V'}

equiv_closed_ctm < case H1.
Subgoal 1:

  Variables: T, V, V', N
  ============================
   {ctm (clnat N)}

Subgoal 2 is:
 {ctm V'}

equiv_closed_ctm < search.
Subgoal 2:

  Variables: T, V, V', T2, T1
  H2 : {tm V}
  H3 : {ctm V'}
  H4 : {val V}
  H5 : {cval V'}
  H6 : forall V1 V1', equiv T1 V1 V1' ->
         sim T2 (app V V1) (cunpair V' (f\env\capp f (cross V1' env)))
  ============================
   {ctm V'}

equiv_closed_ctm < search.
Proof completed.

Abella < Theorem equiv_to_sim : 
forall T M N, equiv T M N -> sim T M N.


  ============================
   forall T M N, equiv T M N -> sim T M N

equiv_to_sim < intros.

  Variables: T, M, N
  H1 : equiv T M N
  ============================
   sim T M N

equiv_to_sim < apply equiv_val to H1.

  Variables: T, M, N
  H1 : equiv T M N
  H2 : {val M}
  ============================
   sim T M N

equiv_to_sim < apply equiv_cval to H1.

  Variables: T, M, N
  H1 : equiv T M N
  H2 : {val M}
  H3 : {cval N}
  ============================
   sim T M N

equiv_to_sim < apply val_eval to H2.

  Variables: T, M, N
  H1 : equiv T M N
  H2 : {val M}
  H3 : {cval N}
  H4 : {eval M M}
  ============================
   sim T M N

equiv_to_sim < apply val_evalcc to H3.

  Variables: T, M, N
  H1 : equiv T M N
  H2 : {val M}
  H3 : {cval N}
  H4 : {eval M M}
  H5 : {evalcc N N}
  ============================
   sim T M N

equiv_to_sim < search.
Proof completed.

Abella < Define subst : smap_list -> prop by 
subst sml_nil;
subst (sml_cons (smap X V) ML) := subst ML /\ tname X /\ {tm V} /\ {val V} /\ (forall V',
  {sml_member (smap X V') ML} -> V' = V).

Abella < Theorem subst_mem : 
forall ML E, subst ML -> {sml_member E ML} -> (exists X V, E = smap X V /\
  tname X /\ {val V} /\ {tm V}).


  ============================
   forall ML E, subst ML -> {sml_member E ML} -> (exists X V, E = smap X V /\
     tname X /\ {val V} /\ {tm V})

subst_mem < induction on 1.


  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  ============================
   forall ML E, subst ML @ -> {sml_member E ML} -> (exists X V,
     E = smap X V /\ tname X /\ {val V} /\ {tm V})

subst_mem < intros.

  Variables: ML, E
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H1 : subst ML @
  H2 : {sml_member E ML}
  ============================
   exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < case H1.
Subgoal 1:

  Variables: ML, E
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H2 : {sml_member E sml_nil}
  ============================
   exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

Subgoal 2 is:
 exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < case H2.
Subgoal 2:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H2 : {sml_member E (sml_cons (smap X V) ML1)}
  H3 : subst ML1 *
  H4 : tname X
  H5 : {tm V}
  H6 : {val V}
  H7 : forall V', {sml_member (smap X V') ML1} -> V' = V
  ============================
   exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < case H2.
Subgoal 2.1:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H3 : subst ML1 *
  H4 : tname X
  H5 : {tm V}
  H6 : {val V}
  H7 : forall V', {sml_member (smap X V') ML1} -> V' = V
  ============================
   exists X1 V1, smap X V = smap X1 V1 /\ tname X1 /\ {val V1} /\ {tm V1}

Subgoal 2.2 is:
 exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < search.
Subgoal 2.2:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H3 : subst ML1 *
  H4 : tname X
  H5 : {tm V}
  H6 : {val V}
  H7 : forall V', {sml_member (smap X V') ML1} -> V' = V
  H8 : {sml_member E ML1}
  ============================
   exists X V, E = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < apply IH to H3 H8.
Subgoal 2.2:

  Variables: ML, E, ML1, V, X, X1, V1
  IH : forall ML E, subst ML * -> {sml_member E ML} -> (exists X V,
         E = smap X V /\ tname X /\ {val V} /\ {tm V})
  H3 : subst ML1 *
  H4 : tname X
  H5 : {tm V}
  H6 : {val V}
  H7 : forall V', {sml_member (smap X V') ML1} -> V' = V
  H8 : {sml_member (smap X1 V1) ML1}
  H9 : tname X1
  H10 : {val V1}
  H11 : {tm V1}
  ============================
   exists X V, smap X1 V1 = smap X V /\ tname X /\ {val V} /\ {tm V}

subst_mem < search.
Proof completed.

Abella < Theorem subst_extend : 
forall ML V, nabla x, subst ML -> {tm V} -> {val V} ->
  subst (sml_cons (smap x V) ML).


  ============================
   forall ML V, nabla x, subst ML -> {tm V} -> {val V} ->
     subst (sml_cons (smap x V) ML)

subst_extend < intros.

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   subst (sml_cons (smap n1 V) ML)

subst_extend < unfold.
Subgoal 1:

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   subst ML

Subgoal 2 is:
 tname n1

Subgoal 3 is:
 {tm V}

Subgoal 4 is:
 {val V}

Subgoal 5 is:
 forall V', {sml_member (smap n1 V') ML} -> V' = V

subst_extend < search.
Subgoal 2:

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   tname n1

Subgoal 3 is:
 {tm V}

Subgoal 4 is:
 {val V}

Subgoal 5 is:
 forall V', {sml_member (smap n1 V') ML} -> V' = V

subst_extend < search.
Subgoal 3:

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   {tm V}

Subgoal 4 is:
 {val V}

Subgoal 5 is:
 forall V', {sml_member (smap n1 V') ML} -> V' = V

subst_extend < search.
Subgoal 4:

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   {val V}

Subgoal 5 is:
 forall V', {sml_member (smap n1 V') ML} -> V' = V

subst_extend < search.
Subgoal 5:

  Variables: ML, V
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  ============================
   forall V', {sml_member (smap n1 V') ML} -> V' = V

subst_extend < intros.
Subgoal 5:

  Variables: ML, V, V'
  H1 : subst ML
  H2 : {tm V}
  H3 : {val V}
  H4 : {sml_member (smap n1 (V' n1)) ML}
  ============================
   V' n1 = V

subst_extend < apply sml_mem_absurd to H4.
Proof completed.

Abella < Define csubst : cmap_list -> prop by 
csubst cml_nil;
csubst (cml_cons (cmap X V) ML) := csubst ML /\ ctname X /\ {ctm V} /\ {cval V} /\ (forall V',
  {cml_member (cmap X V') ML} -> V' = V).

Abella < Theorem csubst_mem : 
forall ML E, csubst ML -> {cml_member E ML} -> (exists X V, E = cmap X V /\
  ctname X /\ {cval V} /\ {ctm V}).


  ============================
   forall ML E, csubst ML -> {cml_member E ML} -> (exists X V,
     E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})

csubst_mem < induction on 1.


  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  ============================
   forall ML E, csubst ML @ -> {cml_member E ML} -> (exists X V,
     E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})

csubst_mem < intros.

  Variables: ML, E
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H1 : csubst ML @
  H2 : {cml_member E ML}
  ============================
   exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < case H1.
Subgoal 1:

  Variables: ML, E
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H2 : {cml_member E cml_nil}
  ============================
   exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

Subgoal 2 is:
 exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < case H2.
Subgoal 2:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H2 : {cml_member E (cml_cons (cmap X V) ML1)}
  H3 : csubst ML1 *
  H4 : ctname X
  H5 : {ctm V}
  H6 : {cval V}
  H7 : forall V', {cml_member (cmap X V') ML1} -> V' = V
  ============================
   exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < case H2.
Subgoal 2.1:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H3 : csubst ML1 *
  H4 : ctname X
  H5 : {ctm V}
  H6 : {cval V}
  H7 : forall V', {cml_member (cmap X V') ML1} -> V' = V
  ============================
   exists X1 V1, cmap X V = cmap X1 V1 /\ ctname X1 /\ {cval V1} /\ {ctm V1}

Subgoal 2.2 is:
 exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < search.
Subgoal 2.2:

  Variables: ML, E, ML1, V, X
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H3 : csubst ML1 *
  H4 : ctname X
  H5 : {ctm V}
  H6 : {cval V}
  H7 : forall V', {cml_member (cmap X V') ML1} -> V' = V
  H8 : {cml_member E ML1}
  ============================
   exists X V, E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < apply IH to H3 H8.
Subgoal 2.2:

  Variables: ML, E, ML1, V, X, X1, V1
  IH : forall ML E, csubst ML * -> {cml_member E ML} -> (exists X V,
         E = cmap X V /\ ctname X /\ {cval V} /\ {ctm V})
  H3 : csubst ML1 *
  H4 : ctname X
  H5 : {ctm V}
  H6 : {cval V}
  H7 : forall V', {cml_member (cmap X V') ML1} -> V' = V
  H8 : {cml_member (cmap X1 V1) ML1}
  H9 : ctname X1
  H10 : {cval V1}
  H11 : {ctm V1}
  ============================
   exists X V, cmap X1 V1 = cmap X V /\ ctname X /\ {cval V} /\ {ctm V}

csubst_mem < search.
Proof completed.

Abella < Theorem csubst_extend : 
forall ML V, nabla x, csubst ML -> {ctm V} -> {cval V} ->
  csubst (cml_cons (cmap x V) ML).


  ============================
   forall ML V, nabla x, csubst ML -> {ctm V} -> {cval V} ->
     csubst (cml_cons (cmap x V) ML)

csubst_extend < intros.

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   csubst (cml_cons (cmap n1 V) ML)

csubst_extend < unfold.
Subgoal 1:

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   csubst ML

Subgoal 2 is:
 ctname n1

Subgoal 3 is:
 {ctm V}

Subgoal 4 is:
 {cval V}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') ML} -> V' = V

csubst_extend < search.
Subgoal 2:

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   ctname n1

Subgoal 3 is:
 {ctm V}

Subgoal 4 is:
 {cval V}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') ML} -> V' = V

csubst_extend < search.
Subgoal 3:

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   {ctm V}

Subgoal 4 is:
 {cval V}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') ML} -> V' = V

csubst_extend < search.
Subgoal 4:

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   {cval V}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') ML} -> V' = V

csubst_extend < search.
Subgoal 5:

  Variables: ML, V
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  ============================
   forall V', {cml_member (cmap n1 V') ML} -> V' = V

csubst_extend < intros.
Subgoal 5:

  Variables: ML, V, V'
  H1 : csubst ML
  H2 : {ctm V}
  H3 : {cval V}
  H4 : {cml_member (cmap n1 (V' n1)) ML}
  ============================
   V' n1 = V

csubst_extend < apply cml_mem_absurd to H4.
Proof completed.

Abella < Theorem csubst_single_inv : 
forall V VL, nabla x, csubst (cml_cons (cmap x (cross V VL)) cml_nil) ->
  csubst (cml_cons (cmap x VL) cml_nil).


  ============================
   forall V VL, nabla x, csubst (cml_cons (cmap x (cross V VL)) cml_nil) ->
     csubst (cml_cons (cmap x VL) cml_nil)

csubst_single_inv < intros.

  Variables: V, VL
  H1 : csubst (cml_cons (cmap n1 (cross V VL)) cml_nil)
  ============================
   csubst (cml_cons (cmap n1 VL) cml_nil)

csubst_single_inv < case H1.

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   csubst (cml_cons (cmap n1 VL) cml_nil)

csubst_single_inv < unfold.
Subgoal 1:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   csubst cml_nil

Subgoal 2 is:
 ctname n1

Subgoal 3 is:
 {ctm VL}

Subgoal 4 is:
 {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < search.
Subgoal 2:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   ctname n1

Subgoal 3 is:
 {ctm VL}

Subgoal 4 is:
 {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < search.
Subgoal 3:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   {ctm VL}

Subgoal 4 is:
 {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < case H4.
Subgoal 3:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  H7 : {ctm V}
  H8 : {ctm VL}
  ============================
   {ctm VL}

Subgoal 4 is:
 {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < search.
Subgoal 4:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < case H5.
Subgoal 4:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  H7 : {cval V}
  H8 : {cval VL}
  ============================
   {cval VL}

Subgoal 5 is:
 forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < search.
Subgoal 5:

  Variables: V, VL
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  ============================
   forall V', {cml_member (cmap n1 V') cml_nil} -> V' = VL

csubst_single_inv < intros.
Subgoal 5:

  Variables: V, VL, V'
  H2 : csubst cml_nil
  H3 : ctname n1
  H4 : {ctm (cross V VL)}
  H5 : {cval (cross V VL)}
  H6 : forall V', {cml_member (cmap n1 V') cml_nil} -> V' = cross V VL
  H7 : {cml_member (cmap n1 (V' n1)) cml_nil}
  ============================
   V' n1 = VL

csubst_single_inv < case H7.
Proof completed.

Abella < Define app_subst : smap_list -> tm -> tm -> prop by 
app_subst sml_nil M M;
nabla x, app_subst (sml_cons (smap x V) (ML x)) (R x) M := nabla x, app_subst (ML x) (R V) M.

Abella < Theorem subst_closed_tm' : 
forall M ML, {tm M} -> subst ML -> app_subst ML M M.


  ============================
   forall M ML, {tm M} -> subst ML -> app_subst ML M M

subst_closed_tm' < induction on 2.


  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  ============================
   forall M ML, {tm M} -> subst ML @ -> app_subst ML M M

subst_closed_tm' < intros.

  Variables: M, ML
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M}
  H2 : subst ML @
  ============================
   app_subst ML M M

subst_closed_tm' < case H2.
Subgoal 1:

  Variables: M, ML
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M}
  ============================
   app_subst sml_nil M M

Subgoal 2 is:
 app_subst (sml_cons (smap X V) ML1) M M

subst_closed_tm' < search.
Subgoal 2:

  Variables: M, ML, ML1, V, X
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M}
  H3 : subst ML1 *
  H4 : tname X
  H5 : {tm V}
  H6 : {val V}
  H7 : forall V', {sml_member (smap X V') ML1} -> V' = V
  ============================
   app_subst (sml_cons (smap X V) ML1) M M

subst_closed_tm' < case H4.
Subgoal 2:

  Variables: M, ML, ML1, V, X
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm (M n1)}
  H3 : subst (ML1 n1) *
  H5 : {tm (V n1)}
  H6 : {val (V n1)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V n1
  ============================
   app_subst (sml_cons (smap n1 (V n1)) (ML1 n1)) (M n1) (M n1)

subst_closed_tm' < apply closed_tm_prune to H1.
Subgoal 2:

  Variables: M, ML, ML1, V, X, M'
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M'}
  H3 : subst (ML1 n1) *
  H5 : {tm (V n1)}
  H6 : {val (V n1)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V n1
  ============================
   app_subst (sml_cons (smap n1 (V n1)) (ML1 n1)) M' M'

subst_closed_tm' < apply closed_tm_prune to H5.
Subgoal 2:

  Variables: M, ML, ML1, V, X, M', M'1
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M'}
  H3 : subst (ML1 n1) *
  H5 : {tm M'1}
  H6 : {val M'1}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'1
  ============================
   app_subst (sml_cons (smap n1 M'1) (ML1 n1)) M' M'

subst_closed_tm' < apply IH to H1 H3.
Subgoal 2:

  Variables: M, ML, ML1, V, X, M', M'1
  IH : forall M ML, {tm M} -> subst ML * -> app_subst ML M M
  H1 : {tm M'}
  H3 : subst (ML1 n1) *
  H5 : {tm M'1}
  H6 : {val M'1}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'1
  H8 : app_subst (ML1 n1) M' M'
  ============================
   app_subst (sml_cons (smap n1 M'1) (ML1 n1)) M' M'

subst_closed_tm' < search.
Proof completed.

Abella < Theorem subst_closed_tm : 
forall M ML M', {tm M} -> app_subst ML M M' -> M = M'.


  ============================
   forall M ML M', {tm M} -> app_subst ML M M' -> M = M'

subst_closed_tm < induction on 2.


  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  ============================
   forall M ML M', {tm M} -> app_subst ML M M' @ -> M = M'

subst_closed_tm < intros.

  Variables: M, ML, M'
  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  H1 : {tm M}
  H2 : app_subst ML M M' @
  ============================
   M = M'

subst_closed_tm < case H2.
Subgoal 1:

  Variables: M, ML, M'
  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  H1 : {tm M'}
  ============================
   M' = M'

Subgoal 2 is:
 M n1 = M1

subst_closed_tm < search.
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V
  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  H1 : {tm (M n1)}
  H3 : app_subst (ML1 n1) (M V) M1 *
  ============================
   M n1 = M1

subst_closed_tm < apply closed_tm_prune to H1.
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V, M'1
  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  H1 : {tm M'1}
  H3 : app_subst (ML1 n1) M'1 M1 *
  ============================
   M'1 = M1

subst_closed_tm < apply IH to H1 H3.
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V, M'1
  IH : forall M ML M', {tm M} -> app_subst ML M M' * -> M = M'
  H1 : {tm M1}
  H3 : app_subst (ML1 n1) M1 M1 *
  ============================
   M1 = M1

subst_closed_tm < search.
Proof completed.

Abella < Theorem subst_var' : 
forall V ML X, subst ML -> {sml_member (smap X V) ML} -> app_subst ML X V.


  ============================
   forall V ML X, subst ML -> {sml_member (smap X V) ML} -> app_subst ML X V

subst_var' < induction on 1.


  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  ============================
   forall V ML X, subst ML @ -> {sml_member (smap X V) ML} ->
     app_subst ML X V

subst_var' < intros.

  Variables: V, ML, X
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H1 : subst ML @
  H2 : {sml_member (smap X V) ML}
  ============================
   app_subst ML X V

subst_var' < case H1.
Subgoal 1:

  Variables: V, ML, X
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H2 : {sml_member (smap X V) sml_nil}
  ============================
   app_subst sml_nil X V

Subgoal 2 is:
 app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < case H2.
Subgoal 2:

  Variables: V, ML, X, ML1, V1, X1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H2 : {sml_member (smap X V) (sml_cons (smap X1 V1) ML1)}
  H3 : subst ML1 *
  H4 : tname X1
  H5 : {tm V1}
  H6 : {val V1}
  H7 : forall V', {sml_member (smap X1 V') ML1} -> V' = V1
  ============================
   app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < case H2.
Subgoal 2.1:

  Variables: V, ML, X, ML1, V1, X1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst ML1 *
  H4 : tname X1
  H5 : {tm V1}
  H6 : {val V1}
  H7 : forall V', {sml_member (smap X1 V') ML1} -> V' = V1
  ============================
   app_subst (sml_cons (smap X1 V1) ML1) X1 V1

Subgoal 2.2 is:
 app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < case H4.
Subgoal 2.1:

  Variables: V, ML, X, ML1, V1, X1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm (V1 n1)}
  H6 : {val (V1 n1)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1 n1
  ============================
   app_subst (sml_cons (smap n1 (V1 n1)) (ML1 n1)) n1 (V1 n1)

Subgoal 2.2 is:
 app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < apply subst_closed_tm' to H5 H3.
Subgoal 2.1:

  Variables: V, ML, X, ML1, V1, X1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm (V1 n1)}
  H6 : {val (V1 n1)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1 n1
  H8 : app_subst (ML1 n1) (V1 n1) (V1 n1)
  ============================
   app_subst (sml_cons (smap n1 (V1 n1)) (ML1 n1)) n1 (V1 n1)

Subgoal 2.2 is:
 app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < apply closed_tm_prune to H5.
Subgoal 2.1:

  Variables: V, ML, X, ML1, V1, X1, M'
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : app_subst (ML1 n1) M' M'
  ============================
   app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'

Subgoal 2.2 is:
 app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < search.
Subgoal 2.2:

  Variables: V, ML, X, ML1, V1, X1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst ML1 *
  H4 : tname X1
  H5 : {tm V1}
  H6 : {val V1}
  H7 : forall V', {sml_member (smap X1 V') ML1} -> V' = V1
  H8 : {sml_member (smap X V) ML1}
  ============================
   app_subst (sml_cons (smap X1 V1) ML1) X V

subst_var' < apply subst_mem to H3 H8.
Subgoal 2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst ML1 *
  H4 : tname X1
  H5 : {tm V1}
  H6 : {val V1}
  H7 : forall V', {sml_member (smap X1 V') ML1} -> V' = V1
  H8 : {sml_member (smap X2 V2) ML1}
  H9 : tname X2
  H10 : {val V2}
  H11 : {tm V2}
  ============================
   app_subst (sml_cons (smap X1 V1) ML1) X2 V2

subst_var' < case H4.
Subgoal 2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm (V1 n1)}
  H6 : {val (V1 n1)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1 n1
  H8 : {sml_member (smap (X2 n1) (V2 n1)) (ML1 n1)}
  H9 : tname (X2 n1)
  H10 : {val (V2 n1)}
  H11 : {tm (V2 n1)}
  ============================
   app_subst (sml_cons (smap n1 (V1 n1)) (ML1 n1)) (X2 n1) (V2 n1)

subst_var' < apply closed_tm_prune to H5.
Subgoal 2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M'
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap (X2 n1) (V2 n1)) (ML1 n1)}
  H9 : tname (X2 n1)
  H10 : {val (V2 n1)}
  H11 : {tm (V2 n1)}
  ============================
   app_subst (sml_cons (smap n1 M') (ML1 n1)) (X2 n1) (V2 n1)

subst_var' < apply closed_tm_prune to H11.
Subgoal 2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap (X2 n1) M'1) (ML1 n1)}
  H9 : tname (X2 n1)
  H10 : {val M'1}
  H11 : {tm M'1}
  ============================
   app_subst (sml_cons (smap n1 M') (ML1 n1)) (X2 n1) M'1

subst_var' < case H9.
Subgoal 2.2.1:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n2 n1) *
  H5 : {tm (M' n2)}
  H6 : {val (M' n2)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n2 n1)} -> V' = M' n2
  H8 : {sml_member (smap n2 (M'1 n2)) (ML1 n2 n1)}
  H10 : {val (M'1 n2)}
  H11 : {tm (M'1 n2)}
  ============================
   app_subst (sml_cons (smap n1 (M' n2)) (ML1 n2 n1)) n2 (M'1 n2)

Subgoal 2.2.2 is:
 app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'1

subst_var' < apply closed_tm_prune to H11.
Subgoal 2.2.1:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1, M'2
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n2 n1) *
  H5 : {tm (M' n2)}
  H6 : {val (M' n2)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n2 n1)} -> V' = M' n2
  H8 : {sml_member (smap n2 M'2) (ML1 n2 n1)}
  H10 : {val M'2}
  H11 : {tm M'2}
  ============================
   app_subst (sml_cons (smap n1 (M' n2)) (ML1 n2 n1)) n2 M'2

Subgoal 2.2.2 is:
 app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'1

subst_var' < apply IH to H3 H8.
Subgoal 2.2.1:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1, M'2
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n2 n1) *
  H5 : {tm (M' n2)}
  H6 : {val (M' n2)}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n2 n1)} -> V' = M' n2
  H8 : {sml_member (smap n2 M'2) (ML1 n2 n1)}
  H10 : {val M'2}
  H11 : {tm M'2}
  H12 : app_subst (ML1 n2 n1) n2 M'2
  ============================
   app_subst (sml_cons (smap n1 (M' n2)) (ML1 n2 n1)) n2 M'2

Subgoal 2.2.2 is:
 app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'1

subst_var' < search.
Subgoal 2.2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap n1 M'1) (ML1 n1)}
  H10 : {val M'1}
  H11 : {tm M'1}
  ============================
   app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'1

subst_var' < apply H7 to H8.
Subgoal 2.2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap n1 M') (ML1 n1)}
  H10 : {val M'}
  H11 : {tm M'}
  ============================
   app_subst (sml_cons (smap n1 M') (ML1 n1)) n1 M'

subst_var' < unfold.
Subgoal 2.2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap n1 M') (ML1 n1)}
  H10 : {val M'}
  H11 : {tm M'}
  ============================
   nabla x, app_subst (ML1 x) M' M'

subst_var' < intros.
Subgoal 2.2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap n1 M') (ML1 n1)}
  H10 : {val M'}
  H11 : {tm M'}
  ============================
   app_subst (ML1 n1) M' M'

subst_var' < apply subst_closed_tm' to H5 H3.
Subgoal 2.2.2:

  Variables: V, ML, X, ML1, V1, X1, X2, V2, M', M'1
  IH : forall V ML X, subst ML * -> {sml_member (smap X V) ML} ->
         app_subst ML X V
  H3 : subst (ML1 n1) *
  H5 : {tm M'}
  H6 : {val M'}
  H7 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = M'
  H8 : {sml_member (smap n1 M') (ML1 n1)}
  H10 : {val M'}
  H11 : {tm M'}
  H12 : app_subst (ML1 n1) M' M'
  ============================
   app_subst (ML1 n1) M' M'

subst_var' < search.
Proof completed.

Abella < Theorem subst_det : 
forall ML M M' M'', subst ML -> app_subst ML M M' -> app_subst ML M M'' ->
  M' = M''.


  ============================
   forall ML M M' M'', subst ML -> app_subst ML M M' -> app_subst ML M M'' ->
     M' = M''

subst_det < induction on 1.


  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  ============================
   forall ML M M' M'', subst ML @ -> app_subst ML M M' ->
     app_subst ML M M'' -> M' = M''

subst_det < intros.

  Variables: ML, M, M', M''
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H1 : subst ML @
  H2 : app_subst ML M M'
  H3 : app_subst ML M M''
  ============================
   M' = M''

subst_det < case H1.
Subgoal 1:

  Variables: ML, M, M', M''
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H2 : app_subst sml_nil M M'
  H3 : app_subst sml_nil M M''
  ============================
   M' = M''

Subgoal 2 is:
 M' = M''

subst_det < case H2.
Subgoal 1:

  Variables: ML, M, M', M''
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H3 : app_subst sml_nil M' M''
  ============================
   M' = M''

Subgoal 2 is:
 M' = M''

subst_det < case H3.
Subgoal 1:

  Variables: ML, M, M', M''
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  ============================
   M'' = M''

Subgoal 2 is:
 M' = M''

subst_det < search.
Subgoal 2:

  Variables: ML, M, M', M'', ML1, V, X
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H2 : app_subst (sml_cons (smap X V) ML1) M M'
  H3 : app_subst (sml_cons (smap X V) ML1) M M''
  H4 : subst ML1 *
  H5 : tname X
  H6 : {tm V}
  H7 : {val V}
  H8 : forall V', {sml_member (smap X V') ML1} -> V' = V
  ============================
   M' = M''

subst_det < case H2.
Subgoal 2:

  Variables: ML, M, M', M'', ML1, V, X, M1, V1
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H3 : app_subst (sml_cons (smap n1 V1) (ML1 n1)) (M n1) (M'' n1)
  H4 : subst (ML1 n1) *
  H5 : tname n1
  H6 : {tm V1}
  H7 : {val V1}
  H8 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1
  H9 : app_subst (ML1 n1) (M V1) M1
  ============================
   M1 = M'' n1

subst_det < case H3.
Subgoal 2:

  Variables: ML, M, M', M'', ML1, V, X, M1, V1, M2
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H4 : subst (ML1 n1) *
  H5 : tname n1
  H6 : {tm V1}
  H7 : {val V1}
  H8 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1
  H9 : app_subst (ML1 n1) (M V1) M1
  H10 : app_subst (ML1 n1) (M V1) M2
  ============================
   M1 = M2

subst_det < apply IH to H4 H9 H10.
Subgoal 2:

  Variables: ML, M, M', M'', ML1, V, X, M1, V1, M2
  IH : forall ML M M' M'', subst ML * -> app_subst ML M M' ->
         app_subst ML M M'' -> M' = M''
  H4 : subst (ML1 n1) *
  H5 : tname n1
  H6 : {tm V1}
  H7 : {val V1}
  H8 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V1
  H9 : app_subst (ML1 n1) (M V1) M2
  H10 : app_subst (ML1 n1) (M V1) M2
  ============================
   M2 = M2

subst_det < search.
Proof completed.

Abella < Theorem subst_var : 
forall V ML E X, subst ML -> {sml_member (smap X V) ML} ->
  app_subst ML X E -> E = V.


  ============================
   forall V ML E X, subst ML -> {sml_member (smap X V) ML} ->
     app_subst ML X E -> E = V

subst_var < intros.

  Variables: V, ML, E, X
  H1 : subst ML
  H2 : {sml_member (smap X V) ML}
  H3 : app_subst ML X E
  ============================
   E = V

subst_var < apply subst_var' to H1 H2.

  Variables: V, ML, E, X
  H1 : subst ML
  H2 : {sml_member (smap X V) ML}
  H3 : app_subst ML X E
  H4 : app_subst ML X V
  ============================
   E = V

subst_var < apply subst_det to H1 H3 H4.

  Variables: V, ML, E, X
  H1 : subst ML
  H2 : {sml_member (smap X V) ML}
  H3 : app_subst ML X V
  H4 : app_subst ML X V
  ============================
   V = V

subst_var < search.
Proof completed.

Abella < Theorem subst_abs : 
forall ML M E, app_subst ML (abs M) E -> (exists M', E = abs M' /\ (nabla x,
  app_subst ML (M x) (M' x))).


  ============================
   forall ML M E, app_subst ML (abs M) E -> (exists M', E = abs M' /\
     (nabla x, app_subst ML (M x) (M' x)))

subst_abs < induction on 1.


  IH : forall ML M E, app_subst ML (abs M) E * -> (exists M', E = abs M' /\
         (nabla x, app_subst ML (M x) (M' x)))
  ============================
   forall ML M E, app_subst ML (abs M) E @ -> (exists M', E = abs M' /\
     (nabla x, app_subst ML (M x) (M' x)))

subst_abs < intros.

  Variables: ML, M, E
  IH : forall ML M E, app_subst ML (abs M) E * -> (exists M', E = abs M' /\
         (nabla x, app_subst ML (M x) (M' x)))
  H1 : app_subst ML (abs M) E @
  ============================
   exists M', E = abs M' /\ (nabla x, app_subst ML (M x) (M' x))

subst_abs < case H1.
Subgoal 1:

  Variables: ML, M, E
  IH : forall ML M E, app_subst ML (abs M) E * -> (exists M', E = abs M' /\
         (nabla x, app_subst ML (M x) (M' x)))
  ============================
   exists M', abs M = abs M' /\ (nabla x, app_subst sml_nil (M x) (M' x))

Subgoal 2 is:
 exists M', M1 = abs M' /\ (nabla x,
   app_subst (sml_cons (smap n1 V) (ML1 n1)) (M n1 x) (M' x))

subst_abs < search.
Subgoal 2:

  Variables: ML, M, E, M1, ML1, V
  IH : forall ML M E, app_subst ML (abs M) E * -> (exists M', E = abs M' /\
         (nabla x, app_subst ML (M x) (M' x)))
  H2 : app_subst (ML1 n1) (abs (M V)) M1 *
  ============================
   exists M', M1 = abs M' /\ (nabla x,
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M n1 x) (M' x))

subst_abs < apply IH to H2.
Subgoal 2:

  Variables: ML, M, E, M1, ML1, V, M', M2
  IH : forall ML M E, app_subst ML (abs M) E * -> (exists M', E = abs M' /\
         (nabla x, app_subst ML (M x) (M' x)))
  H2 : app_subst (ML1 n1) (abs (M V)) (abs M2) *
  H3 : app_subst (ML1 n1) (M V n2) (M2 n2)
  ============================
   exists M', abs M2 = abs M' /\ (nabla x,
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M n1 x) (M' x))

subst_abs < search.
Proof completed.

Abella < Theorem subst_app : 
forall ML M1 M2 E, app_subst ML (app M1 M2) E -> (exists M1' M2',
  E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2').


  ============================
   forall ML M1 M2 E, app_subst ML (app M1 M2) E -> (exists M1' M2',
     E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')

subst_app < induction on 1.


  IH : forall ML M1 M2 E, app_subst ML (app M1 M2) E * -> (exists M1' M2',
         E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')
  ============================
   forall ML M1 M2 E, app_subst ML (app M1 M2) E @ -> (exists M1' M2',
     E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')

subst_app < intros.

  Variables: ML, M1, M2, E
  IH : forall ML M1 M2 E, app_subst ML (app M1 M2) E * -> (exists M1' M2',
         E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')
  H1 : app_subst ML (app M1 M2) E @
  ============================
   exists M1' M2', E = app M1' M2' /\ app_subst ML M1 M1' /\
     app_subst ML M2 M2'

subst_app < case H1.
Subgoal 1:

  Variables: ML, M1, M2, E
  IH : forall ML M1 M2 E, app_subst ML (app M1 M2) E * -> (exists M1' M2',
         E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')
  ============================
   exists M1' M2', app M1 M2 = app M1' M2' /\ app_subst sml_nil M1 M1' /\
     app_subst sml_nil M2 M2'

Subgoal 2 is:
 exists M1' M2', M = app M1' M2' /\
   app_subst (sml_cons (smap n1 V) (ML1 n1)) (M1 n1) M1' /\
   app_subst (sml_cons (smap n1 V) (ML1 n1)) (M2 n1) M2'

subst_app < search.
Subgoal 2:

  Variables: ML, M1, M2, E, M, ML1, V
  IH : forall ML M1 M2 E, app_subst ML (app M1 M2) E * -> (exists M1' M2',
         E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')
  H2 : app_subst (ML1 n1) (app (M1 V) (M2 V)) M *
  ============================
   exists M1' M2', M = app M1' M2' /\
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M1 n1) M1' /\
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M2 n1) M2'

subst_app < apply IH to H2.
Subgoal 2:

  Variables: ML, M1, M2, E, M, ML1, V, M1', M2', M4, M3
  IH : forall ML M1 M2 E, app_subst ML (app M1 M2) E * -> (exists M1' M2',
         E = app M1' M2' /\ app_subst ML M1 M1' /\ app_subst ML M2 M2')
  H2 : app_subst (ML1 n1) (app (M1 V) (M2 V)) (app M3 M4) *
  H3 : app_subst (ML1 n1) (M1 V) M3
  H4 : app_subst (ML1 n1) (M2 V) M4
  ============================
   exists M1' M2', app M3 M4 = app M1' M2' /\
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M1 n1) M1' /\
     app_subst (sml_cons (smap n1 V) (ML1 n1)) (M2 n1) M2'

subst_app < search.
Proof completed.

Abella < Theorem subst_result_closed_tm : 
forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
  member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
  app_subst ML M M' -> {tm M'}.


  ============================
   forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
     member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
     app_subst ML M M' -> {tm M'}

subst_result_closed_tm < induction on 5.


  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  ============================
   forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
     member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
     app_subst ML M M' @ -> {tm M'}

subst_result_closed_tm < intros.

  Variables: ML, L, M, M'
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst ML
  H2 : tmctx L
  H3 : {L |- tm M}
  H4 : forall X, member (tm X) L -> (exists V'1,
         {sml_member (smap X V'1) ML})
  H5 : app_subst ML M M' @
  ============================
   {tm M'}

subst_result_closed_tm < case H5.
Subgoal 1:

  Variables: ML, L, M, M'
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst sml_nil
  H2 : tmctx L
  H3 : {L |- tm M'}
  H4 : forall X, member (tm X) L -> (exists V'1,
         {sml_member (smap X V'1) sml_nil})
  ============================
   {tm M'}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < case H2.
Subgoal 1.1:

  Variables: ML, L, M, M'
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst sml_nil
  H3 : {tm M'}
  H4 : forall X, member (tm X) nil -> (exists V'1,
         {sml_member (smap X V'1) sml_nil})
  ============================
   {tm M'}

Subgoal 1.2 is:
 {tm (M' n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < search.
Subgoal 1.2:

  Variables: ML, L, M, M', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst sml_nil
  H3 : {L1 n1, tm n1 |- tm (M' n1)}
  H4 : forall X, member (tm X) (tm n1 :: L1 n1) -> (exists V'1,
         {sml_member (smap X V'1) sml_nil})
  H6 : tmctx (L1 n1)
  ============================
   {tm (M' n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < assert member (tm n1) (tm n1 :: L1 n1).
Subgoal 1.2:

  Variables: ML, L, M, M', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst sml_nil
  H3 : {L1 n1, tm n1 |- tm (M' n1)}
  H4 : forall X, member (tm X) (tm n1 :: L1 n1) -> (exists V'1,
         {sml_member (smap X V'1) sml_nil})
  H6 : tmctx (L1 n1)
  H7 : member (tm n1) (tm n1 :: L1 n1)
  ============================
   {tm (M' n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < apply H4 to H7.
Subgoal 1.2:

  Variables: ML, L, M, M', L1, V'1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst sml_nil
  H3 : {L1 n1, tm n1 |- tm (M' n1)}
  H4 : forall X, member (tm X) (tm n1 :: L1 n1) -> (exists V'1,
         {sml_member (smap X V'1) sml_nil})
  H6 : tmctx (L1 n1)
  H7 : member (tm n1) (tm n1 :: L1 n1)
  H8 : {sml_member (smap n1 (V'1 n1)) sml_nil}
  ============================
   {tm (M' n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < case H8.
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H1 : subst (sml_cons (smap n1 V) (ML1 n1))
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  ============================
   {tm M1}

subst_result_closed_tm < case H1.
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  ============================
   {tm M1}

subst_result_closed_tm < apply tmctx_rst_exists to H2 with x = n1.
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L'
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) (L' n1)
  H13 : fresh_tmctx n1 (L' n1)
  ============================
   {tm M1}

subst_result_closed_tm < case H13.
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  ============================
   {tm M1}

subst_result_closed_tm < apply tm_cut to H2 H3 H12 H9.
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  ============================
   {tm M1}

subst_result_closed_tm < assert forall X, member (tm X) L1 -> (exists V, {sml_member (smap X V) (ML1 n1)}).
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  ============================
   forall X, member (tm X) L1 -> (exists V1,
     {sml_member (smap X V1) (ML1 n1)})

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < intros.
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1, X
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : member (tm (X n1)) L1
  ============================
   exists V1, {sml_member (smap (X n1) V1) (ML1 n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < apply tmctx_rst_mem_inv to H12 H15.
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1, X
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : member (tm (X n1)) L1
  H16 : member (tm (X n1)) (L n1)
  ============================
   exists V1, {sml_member (smap (X n1) V1) (ML1 n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < apply member_prune_tm to H15.
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1, X, M'1, M'2
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : member (tm M'2) L1
  H16 : member (tm M'2) (L n1)
  ============================
   exists V1, {sml_member (smap M'2 V1) (ML1 n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < apply H4 to H16.
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1, X, M'1, M'2, V'1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : member (tm M'2) L1
  H16 : member (tm M'2) (L n1)
  H17 : {sml_member (smap M'2 (V'1 n1)) (sml_cons (smap n1 V) (ML1 n1))}
  ============================
   exists V1, {sml_member (smap M'2 V1) (ML1 n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < case H17.
Subgoal 2.1:

  Variables: ML, L, M, M', M1, ML1, V, L', L1, X, M'1, M'2, V'1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : member (tm M'2) L1
  H16 : member (tm M'2) (L n1)
  H18 : {sml_member (smap M'2 (V'1 n1)) (ML1 n1)}
  ============================
   exists V1, {sml_member (smap M'2 V1) (ML1 n1)}

Subgoal 2 is:
 {tm M1}

subst_result_closed_tm < search.
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : forall X, member (tm X) L1 -> (exists V1,
          {sml_member (smap X V1) (ML1 n1)})
  ============================
   {tm M1}

subst_result_closed_tm < apply tmctx_rst_pres to H2 H12.
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : forall X, member (tm X) L1 -> (exists V1,
          {sml_member (smap X V1) (ML1 n1)})
  H16 : tmctx L1
  ============================
   {tm M1}

subst_result_closed_tm < apply IH to H7 H16 H14 H15 H6.
Subgoal 2:

  Variables: ML, L, M, M', M1, ML1, V, L', L1
  IH : forall ML L M M', subst ML -> tmctx L -> {L |- tm M} -> (forall X,
         member (tm X) L -> (exists V'1, {sml_member (smap X V'1) ML})) ->
         app_subst ML M M' * -> {tm M'}
  H2 : tmctx (L n1)
  H3 : {L n1 |- tm (M n1)}
  H4 : forall X, member (tm X) (L n1) -> (exists V'1,
         {sml_member (smap X V'1) (sml_cons (smap n1 V) (ML1 n1))})
  H6 : app_subst (ML1 n1) (M V) M1 *
  H7 : subst (ML1 n1)
  H8 : tname n1
  H9 : {tm V}
  H10 : {val V}
  H11 : forall V', {sml_member (smap n1 V') (ML1 n1)} -> V' = V
  H12 : tmctx_rst (tm n1) (L n1) L1
  H14 : {L1 |- tm (M V)}
  H15 : forall X, member (tm X) L1 -> (exists V1,
          {sml_member (smap X V1) (ML1 n1)})
  H16 : tmctx L1
  H17 : {tm M1}
  ============================
   {tm M1}

subst_result_closed_tm < search.
Proof completed.

Abella < Theorem subst_inst : 
forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) ->
  app_subst ML (M V) (M' V).


  ============================
   forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) ->
     app_subst ML (M V) (M' V)

subst_inst < induction on 2.


  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  ============================
   forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) @ ->
     app_subst ML (M V) (M' V)

subst_inst < intros.

  Variables: ML, M, M', V
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm V}
  H2 : app_subst ML (M n1) (M' n1) @
  ============================
   app_subst ML (M V) (M' V)

subst_inst < case H2.
Subgoal 1:

  Variables: ML, M, M', V
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm V}
  ============================
   app_subst sml_nil (M' V) (M' V)

Subgoal 2 is:
 app_subst (sml_cons (smap n2 ML2) (ML3 n2)) (M n2 (V n2)) (M2 (V n2))

subst_inst < search.
Subgoal 2:

  Variables: ML, M, M', V, M2, ML3, ML2
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm (V n2)}
  H3 : app_subst (ML3 n2) (M ML2 n1) (M2 n1) *
  ============================
   app_subst (sml_cons (smap n2 ML2) (ML3 n2)) (M n2 (V n2)) (M2 (V n2))

subst_inst < apply closed_tm_prune to H1.
Subgoal 2:

  Variables: ML, M, M', V, M2, ML3, ML2, M'1
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm M'1}
  H3 : app_subst (ML3 n2) (M ML2 n1) (M2 n1) *
  ============================
   app_subst (sml_cons (smap n2 ML2) (ML3 n2)) (M n2 M'1) (M2 M'1)

subst_inst < unfold.
Subgoal 2:

  Variables: ML, M, M', V, M2, ML3, ML2, M'1
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm M'1}
  H3 : app_subst (ML3 n2) (M ML2 n1) (M2 n1) *
  ============================
   nabla x, app_subst (ML3 x) (M ML2 M'1) (M2 M'1)

subst_inst < intros.
Subgoal 2:

  Variables: ML, M, M', V, M2, ML3, ML2, M'1
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm M'1}
  H3 : app_subst (ML3 n2) (M ML2 n1) (M2 n1) *
  ============================
   app_subst (ML3 n1) (M ML2 M'1) (M2 M'1)

subst_inst < apply IH to H1 H3.
Subgoal 2:

  Variables: ML, M, M', V, M2, ML3, ML2, M'1
  IH : forall ML M M' V, nabla x, {tm V} -> app_subst ML (M x) (M' x) * ->
         app_subst ML (M V) (M' V)
  H1 : {tm M'1}
  H3 : app_subst (ML3 n2) (M ML2 n1) (M2 n1) *
  H4 : app_subst (ML3 n2) (M ML2 M'1) (M2 M'1)
  ============================
   app_subst (ML3 n1) (M ML2 M'1) (M2 M'1)

subst_inst < search.
Proof completed.

Abella < Define app_csubst : cmap_list -> ctm -> ctm -> prop by 
app_csubst cml_nil M M;
nabla x, app_csubst (cml_cons (cmap x V) (ML x)) (R x) M := nabla x, app_csubst (ML x) (R V) M.

Abella < Theorem csubst_closed_ctm : 
forall M ML M', {ctm M} -> app_csubst ML M M' -> M = M'.


  ============================
   forall M ML M', {ctm M} -> app_csubst ML M M' -> M = M'

csubst_closed_ctm < induction on 2.


  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  ============================
   forall M ML M', {ctm M} -> app_csubst ML M M' @ -> M = M'

csubst_closed_ctm < intros.

  Variables: M, ML, M'
  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  H1 : {ctm M}
  H2 : app_csubst ML M M' @
  ============================
   M = M'

csubst_closed_ctm < case H2.
Subgoal 1:

  Variables: M, ML, M'
  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  H1 : {ctm M'}
  ============================
   M' = M'

Subgoal 2 is:
 M n1 = M1

csubst_closed_ctm < search.
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V
  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  H1 : {ctm (M n1)}
  H3 : app_csubst (ML1 n1) (M V) M1 *
  ============================
   M n1 = M1

csubst_closed_ctm < apply closed_ctm_prune to H1.
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V, M'1
  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  H1 : {ctm M'1}
  H3 : app_csubst (ML1 n1) M'1 M1 *
  ============================
   M'1 = M1

csubst_closed_ctm < apply IH to H1 H3.
Subgoal 2:

  Variables: M, ML, M', M1, ML1, V, M'1
  IH : forall M ML M', {ctm M} -> app_csubst ML M M' * -> M = M'
  H1 : {ctm M1}
  H3 : app_csubst (ML1 n1) M1 M1 *
  ============================
   M1 = M1

csubst_closed_ctm < search.
Proof completed.

Abella < Theorem csubst_var : 
forall V ML E X, csubst ML -> {cml_member (cmap X V) ML} ->
  app_csubst ML X E -> E = V.


  ============================
   forall V ML E X, csubst ML -> {cml_member (cmap X V) ML} ->
     app_csubst ML X E -> E = V

csubst_var < induction on 1.


  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  ============================
   forall V ML E X, csubst ML @ -> {cml_member (cmap X V) ML} ->
     app_csubst ML X E -> E = V

csubst_var < intros.

  Variables: V, ML, E, X
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H1 : csubst ML @
  H2 : {cml_member (cmap X V) ML}
  H3 : app_csubst ML X E
  ============================
   E = V

csubst_var < case H1.
Subgoal 1:

  Variables: V, ML, E, X
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H2 : {cml_member (cmap X V) cml_nil}
  H3 : app_csubst cml_nil X E
  ============================
   E = V

Subgoal 2 is:
 E = V

csubst_var < case H2.
Subgoal 2:

  Variables: V, ML, E, X, ML1, V1, X1
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H2 : {cml_member (cmap X V) (cml_cons (cmap X1 V1) ML1)}
  H3 : app_csubst (cml_cons (cmap X1 V1) ML1) X E
  H4 : csubst ML1 *
  H5 : ctname X1
  H6 : {ctm V1}
  H7 : {cval V1}
  H8 : forall V', {cml_member (cmap X1 V') ML1} -> V' = V1
  ============================
   E = V

csubst_var < case H2.
Subgoal 2.1:

  Variables: V, ML, E, X, ML1, V1, X1
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H3 : app_csubst (cml_cons (cmap X1 V1) ML1) X1 E
  H4 : csubst ML1 *
  H5 : ctname X1
  H6 : {ctm V1}
  H7 : {cval V1}
  H8 : forall V', {cml_member (cmap X1 V') ML1} -> V' = V1
  ============================
   E = V1

Subgoal 2.2 is:
 E = V

csubst_var < case H3.
Subgoal 2.1:

  Variables: V, ML, E, X, ML1, V1, X1, M, V2
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm V2}
  H7 : {cval V2}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = V2
  H9 : app_csubst (ML1 n1) V2 M
  ============================
   M = V2

Subgoal 2.2 is:
 E = V

csubst_var < apply csubst_closed_ctm to H6 H9.
Subgoal 2.1:

  Variables: V, ML, E, X, ML1, V1, X1, M, V2
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm M}
  H7 : {cval M}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = M
  H9 : app_csubst (ML1 n1) M M
  ============================
   M = M

Subgoal 2.2 is:
 E = V

csubst_var < search.
Subgoal 2.2:

  Variables: V, ML, E, X, ML1, V1, X1
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H3 : app_csubst (cml_cons (cmap X1 V1) ML1) X E
  H4 : csubst ML1 *
  H5 : ctname X1
  H6 : {ctm V1}
  H7 : {cval V1}
  H8 : forall V', {cml_member (cmap X1 V') ML1} -> V' = V1
  H9 : {cml_member (cmap X V) ML1}
  ============================
   E = V

csubst_var < apply csubst_mem to H4 H9.
Subgoal 2.2:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H3 : app_csubst (cml_cons (cmap X1 V1) ML1) X2 E
  H4 : csubst ML1 *
  H5 : ctname X1
  H6 : {ctm V1}
  H7 : {cval V1}
  H8 : forall V', {cml_member (cmap X1 V') ML1} -> V' = V1
  H9 : {cml_member (cmap X2 V2) ML1}
  H10 : ctname X2
  H11 : {cval V2}
  H12 : {ctm V2}
  ============================
   E = V2

csubst_var < case H3.
Subgoal 2.2:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm V3}
  H7 : {cval V3}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = V3
  H9 : {cml_member (cmap (X2 n1) (V2 n1)) (ML1 n1)}
  H10 : ctname (X2 n1)
  H11 : {cval (V2 n1)}
  H12 : {ctm (V2 n1)}
  H13 : app_csubst (ML1 n1) (X2 V3) M
  ============================
   M = V2 n1

csubst_var < case H10.
Subgoal 2.2.1:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n2 n1) *
  H5 : ctname n1
  H6 : {ctm (V3 n2)}
  H7 : {cval (V3 n2)}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n2 n1)} -> V' = V3 n2
  H9 : {cml_member (cmap n2 (V2 n2 n1)) (ML1 n2 n1)}
  H11 : {cval (V2 n2 n1)}
  H12 : {ctm (V2 n2 n1)}
  H13 : app_csubst (ML1 n2 n1) n2 (M n2)
  ============================
   M n2 = V2 n2 n1

Subgoal 2.2.2 is:
 M = V2 n1

csubst_var < apply IH to H4 H9 H13.
Subgoal 2.2.1:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3, M1
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n2 n1) *
  H5 : ctname n1
  H6 : {ctm (V3 n2)}
  H7 : {cval (V3 n2)}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n2 n1)} -> V' = V3 n2
  H9 : {cml_member (cmap n2 (M1 n2)) (ML1 n2 n1)}
  H11 : {cval (M1 n2)}
  H12 : {ctm (M1 n2)}
  H13 : app_csubst (ML1 n2 n1) n2 (M1 n2)
  ============================
   M1 n2 = M1 n2

Subgoal 2.2.2 is:
 M = V2 n1

csubst_var < search.
Subgoal 2.2.2:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm V3}
  H7 : {cval V3}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = V3
  H9 : {cml_member (cmap n1 (V2 n1)) (ML1 n1)}
  H11 : {cval (V2 n1)}
  H12 : {ctm (V2 n1)}
  H13 : app_csubst (ML1 n1) V3 M
  ============================
   M = V2 n1

csubst_var < apply csubst_closed_ctm to H6 H13.
Subgoal 2.2.2:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm M}
  H7 : {cval M}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = M
  H9 : {cml_member (cmap n1 (V2 n1)) (ML1 n1)}
  H11 : {cval (V2 n1)}
  H12 : {ctm (V2 n1)}
  H13 : app_csubst (ML1 n1) M M
  ============================
   M = V2 n1

csubst_var < apply H8 to H9.
Subgoal 2.2.2:

  Variables: V, ML, E, X, ML1, V1, X1, X2, V2, M, V3
  IH : forall V ML E X, csubst ML * -> {cml_member (cmap X V) ML} ->
         app_csubst ML X E -> E = V
  H4 : csubst (ML1 n1) *
  H5 : ctname n1
  H6 : {ctm M}
  H7 : {cval M}
  H8 : forall V', {cml_member (cmap n1 V') (ML1 n1)} -> V' = M
  H9 : {cml_member (cmap n1 M) (ML1 n1)}
  H11 : {cval M}
  H12 : {ctm M}
  H13 : app_csubst (ML1 n1) M M
  ============================
   M = M

csubst_var < search.
Proof completed.

Abella < Theorem csubst_cpair : 
forall F ML M E, app_csubst ML (cpair F M) E -> (exists M' F',
  E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M').


  ============================
   forall F ML M E, app_csubst ML (cpair F M) E -> (exists M' F',
     E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')

csubst_cpair < induction on 1.


  IH : forall F ML M E, app_csubst ML (cpair F M) E * -> (exists M' F',
         E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')
  ============================
   forall F ML M E, app_csubst ML (cpair F M) E @ -> (exists M' F',
     E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')

csubst_cpair < intros.

  Variables: F, ML, M, E
  IH : forall F ML M E, app_csubst ML (cpair F M) E * -> (exists M' F',
         E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')
  H1 : app_csubst ML (cpair F M) E @
  ============================
   exists M' F', E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M'

csubst_cpair < case H1.
Subgoal 1:

  Variables: F, ML, M, E
  IH : forall F ML M E, app_csubst ML (cpair F M) E * -> (exists M' F',
         E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')
  ============================
   exists M' F', cpair F M = cpair F' M' /\ app_csubst cml_nil F F' /\
     app_csubst cml_nil M M'

Subgoal 2 is:
 exists M' F', M1 = cpair F' M' /\
   app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (F n1) F' /\
   app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (M n1) M'

csubst_cpair < search.
Subgoal 2:

  Variables: F, ML, M, E, M1, ML1, V
  IH : forall F ML M E, app_csubst ML (cpair F M) E * -> (exists M' F',
         E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')
  H2 : app_csubst (ML1 n1) (cpair (F V) (M V)) M1 *
  ============================
   exists M' F', M1 = cpair F' M' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (F n1) F' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (M n1) M'

csubst_cpair < apply IH to H2.
Subgoal 2:

  Variables: F, ML, M, E, M1, ML1, V, M', F', M3, M2
  IH : forall F ML M E, app_csubst ML (cpair F M) E * -> (exists M' F',
         E = cpair F' M' /\ app_csubst ML F F' /\ app_csubst ML M M')
  H2 : app_csubst (ML1 n1) (cpair (F V) (M V)) (cpair M2 M3) *
  H3 : app_csubst (ML1 n1) (F V) M2
  H4 : app_csubst (ML1 n1) (M V) M3
  ============================
   exists M' F', cpair M2 M3 = cpair F' M' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (F n1) F' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (M n1) M'

csubst_cpair < search.
Proof completed.

Abella < Theorem csubst_cunpair : 
forall ML CM1 CM2 E,
  app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E ->
  (exists CM1' CM2', E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
  app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2').


  ============================
   forall ML CM1 CM2 E,
     app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E ->
     (exists CM1' CM2', E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')

csubst_cunpair < induction on 1.


  IH : forall ML CM1 CM2 E,
         app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E * ->
         (exists CM1' CM2',
         E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
         app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')
  ============================
   forall ML CM1 CM2 E,
     app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E @ ->
     (exists CM1' CM2', E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')

csubst_cunpair < intros.

  Variables: ML, CM1, CM2, E
  IH : forall ML CM1 CM2 E,
         app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E * ->
         (exists CM1' CM2',
         E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
         app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')
  H1 : app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E @
  ============================
   exists CM1' CM2', E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2'

csubst_cunpair < case H1.
Subgoal 1:

  Variables: ML, CM1, CM2, E
  IH : forall ML CM1 CM2 E,
         app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E * ->
         (exists CM1' CM2',
         E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
         app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')
  ============================
   exists CM1' CM2',
     cunpair CM1 (f\env\capp f (cross CM2 env)) = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst cml_nil CM1 CM1' /\ app_csubst cml_nil CM2 CM2'

Subgoal 2 is:
 exists CM1' CM2', M = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
   app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM1 n1) CM1' /\
   app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM2 n1) CM2'

csubst_cunpair < search.
Subgoal 2:

  Variables: ML, CM1, CM2, E, M, ML1, V
  IH : forall ML CM1 CM2 E,
         app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E * ->
         (exists CM1' CM2',
         E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
         app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')
  H2 : app_csubst (ML1 n1) (cunpair (CM1 V) (f\env\capp f (cross (CM2 V) env))) M *
  ============================
   exists CM1' CM2', M = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM1 n1) CM1' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM2 n1) CM2'

csubst_cunpair < apply IH to H2.
Subgoal 2:

  Variables: ML, CM1, CM2, E, M, ML1, V, CM1', CM2', M2, M1
  IH : forall ML CM1 CM2 E,
         app_csubst ML (cunpair CM1 (f\env\capp f (cross CM2 env))) E * ->
         (exists CM1' CM2',
         E = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
         app_csubst ML CM1 CM1' /\ app_csubst ML CM2 CM2')
  H2 : app_csubst (ML1 n1) (cunpair (CM1 V) (f\env\capp f (cross (CM2 V) env))) (cunpair M1 (f\env\capp f (cross M2 env))) *
  H3 : app_csubst (ML1 n1) (CM1 V) M1
  H4 : app_csubst (ML1 n1) (CM2 V) M2
  ============================
   exists CM1' CM2',
     cunpair M1 (f\env\capp f (cross M2 env)) = cunpair CM1' (f\env\capp f (cross CM2' env)) /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM1 n1) CM1' /\
     app_csubst (cml_cons (cmap n1 V) (ML1 n1)) (CM2 n1) CM2'

csubst_cunpair < search.
Proof completed.

Abella < Define subst_equiv : olist -> smap_list -> ctm -> prop by 
subst_equiv nil ML unit;
subst_equiv (of X T :: L) ML (cross V' VL') := exists V, subst_equiv L ML VL' /\ {sml_member (smap X V) ML} /\ equiv T V V'.

Abella < Define subst_equiv' : olist -> smap_list -> cmap_list -> prop by 
nabla x y xenv, subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) := equiv T V V' /\ subst_equiv L ML Venv.

Abella < Theorem subst_equiv_cval : 
forall T ML VE, subst_equiv T ML VE -> {cval VE}.


  ============================
   forall T ML VE, subst_equiv T ML VE -> {cval VE}

subst_equiv_cval < induction on 1.


  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  ============================
   forall T ML VE, subst_equiv T ML VE @ -> {cval VE}

subst_equiv_cval < intros.

  Variables: T, ML, VE
  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  H1 : subst_equiv T ML VE @
  ============================
   {cval VE}

subst_equiv_cval < case H1.
Subgoal 1:

  Variables: T, ML, VE
  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  ============================
   {cval unit}

Subgoal 2 is:
 {cval (cross V' VL')}

subst_equiv_cval < search.
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  ============================
   {cval (cross V' VL')}

subst_equiv_cval < apply equiv_cval to H4.
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  H5 : {cval V'}
  ============================
   {cval (cross V' VL')}

subst_equiv_cval < apply IH to H2.
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {cval VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  H5 : {cval V'}
  H6 : {cval VL'}
  ============================
   {cval (cross V' VL')}

subst_equiv_cval < search.
Proof completed.

Abella < Theorem subst_equiv_closed_ctm : 
forall T ML VE, subst_equiv T ML VE -> {ctm VE}.


  ============================
   forall T ML VE, subst_equiv T ML VE -> {ctm VE}

subst_equiv_closed_ctm < induction on 1.


  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  ============================
   forall T ML VE, subst_equiv T ML VE @ -> {ctm VE}

subst_equiv_closed_ctm < intros.

  Variables: T, ML, VE
  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  H1 : subst_equiv T ML VE @
  ============================
   {ctm VE}

subst_equiv_closed_ctm < case H1.
Subgoal 1:

  Variables: T, ML, VE
  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  ============================
   {ctm unit}

Subgoal 2 is:
 {ctm (cross V' VL')}

subst_equiv_closed_ctm < search.
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  ============================
   {ctm (cross V' VL')}

subst_equiv_closed_ctm < apply equiv_closed_ctm to H4.
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  H5 : {ctm V'}
  ============================
   {ctm (cross V' VL')}

subst_equiv_closed_ctm < apply IH to H2.
Subgoal 2:

  Variables: T, ML, VE, V, VL', V', L, T1, X
  IH : forall T ML VE, subst_equiv T ML VE * -> {ctm VE}
  H2 : subst_equiv L ML VL' *
  H3 : {sml_member (smap X V) ML}
  H4 : equiv T1 V V'
  H5 : {ctm V'}
  H6 : {ctm VL'}
  ============================
   {ctm (cross V' VL')}

subst_equiv_closed_ctm < search.
Proof completed.

Abella < Theorem subst_equiv_mem : 
forall ML X L VE T, subst_equiv L ML VE -> member (of X T) L -> (exists V,
  {sml_member (smap X V) ML}).


  ============================
   forall ML X L VE T, subst_equiv L ML VE -> member (of X T) L -> (exists V,
     {sml_member (smap X V) ML})

subst_equiv_mem < induction on 1.


  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  ============================
   forall ML X L VE T, subst_equiv L ML VE @ -> member (of X T) L ->
     (exists V, {sml_member (smap X V) ML})

subst_equiv_mem < intros.

  Variables: ML, X, L, VE, T
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H1 : subst_equiv L ML VE @
  H2 : member (of X T) L
  ============================
   exists V, {sml_member (smap X V) ML}

subst_equiv_mem < case H1.
Subgoal 1:

  Variables: ML, X, L, VE, T
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H2 : member (of X T) nil
  ============================
   exists V, {sml_member (smap X V) ML}

Subgoal 2 is:
 exists V, {sml_member (smap X V) ML}

subst_equiv_mem < case H2.
Subgoal 2:

  Variables: ML, X, L, VE, T, V, VL', V', L1, T1, X1
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H2 : member (of X T) (of X1 T1 :: L1)
  H3 : subst_equiv L1 ML VL' *
  H4 : {sml_member (smap X1 V) ML}
  H5 : equiv T1 V V'
  ============================
   exists V, {sml_member (smap X V) ML}

subst_equiv_mem < case H2.
Subgoal 2.1:

  Variables: ML, X, L, VE, T, V, VL', V', L1, T1, X1
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H3 : subst_equiv L1 ML VL' *
  H4 : {sml_member (smap X1 V) ML}
  H5 : equiv T1 V V'
  ============================
   exists V, {sml_member (smap X1 V) ML}

Subgoal 2.2 is:
 exists V, {sml_member (smap X V) ML}

subst_equiv_mem < search.
Subgoal 2.2:

  Variables: ML, X, L, VE, T, V, VL', V', L1, T1, X1
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H3 : subst_equiv L1 ML VL' *
  H4 : {sml_member (smap X1 V) ML}
  H5 : equiv T1 V V'
  H6 : member (of X T) L1
  ============================
   exists V, {sml_member (smap X V) ML}

subst_equiv_mem < apply IH to H3 H6.
Subgoal 2.2:

  Variables: ML, X, L, VE, T, V, VL', V', L1, T1, X1, V1
  IH : forall ML X L VE T, subst_equiv L ML VE * -> member (of X T) L ->
         (exists V, {sml_member (smap X V) ML})
  H3 : subst_equiv L1 ML VL' *
  H4 : {sml_member (smap X1 V) ML}
  H5 : equiv T1 V V'
  H6 : member (of X T) L1
  H7 : {sml_member (smap X V1) ML}
  ============================
   exists V, {sml_member (smap X V) ML}

subst_equiv_mem < search.
Proof completed.

Abella < Theorem subst_equiv'_mem : 
forall ML X L VE T, subst_equiv' L ML VE -> member (of X T) L -> (exists V,
  {sml_member (smap X V) ML}).


  ============================
   forall ML X L VE T, subst_equiv' L ML VE -> member (of X T) L ->
     (exists V, {sml_member (smap X V) ML})

subst_equiv'_mem < intros.

  Variables: ML, X, L, VE, T
  H1 : subst_equiv' L ML VE
  H2 : member (of X T) L
  ============================
   exists V, {sml_member (smap X V) ML}

subst_equiv'_mem < case H1.

  Variables: ML, X, L, VE, T, Venv, V', ML1, V, L1, T1
  H2 : member (of (X n1) T) (of n1 T1 :: L1)
  H3 : equiv T1 V V'
  H4 : subst_equiv L1 ML1 Venv
  ============================
   exists V1, {sml_member (smap (X n1) V1) (sml_cons (smap n1 V) ML1)}

subst_equiv'_mem < case H2.
Subgoal 1:

  Variables: ML, X, L, VE, T, Venv, V', ML1, V, L1, T1
  H3 : equiv T1 V V'
  H4 : subst_equiv L1 ML1 Venv
  ============================
   exists V1, {sml_member (smap n1 V1) (sml_cons (smap n1 V) ML1)}

Subgoal 2 is:
 exists V1, {sml_member (smap (X n1) V1) (sml_cons (smap n1 V) ML1)}

subst_equiv'_mem < search.
Subgoal 2:

  Variables: ML, X, L, VE, T, Venv, V', ML1, V, L1, T1
  H3 : equiv T1 V V'
  H4 : subst_equiv L1 ML1 Venv
  H5 : member (of (X n1) T) L1
  ============================
   exists V1, {sml_member (smap (X n1) V1) (sml_cons (smap n1 V) ML1)}

subst_equiv'_mem < apply subst_equiv_mem to H4 H5.
Subgoal 2:

  Variables: ML, X, L, VE, T, Venv, V', ML1, V, L1, T1, V1
  H3 : equiv T1 V V'
  H4 : subst_equiv L1 ML1 Venv
  H5 : member (of (X n1) T) L1
  H6 : {sml_member (smap (X n1) (V1 n1)) ML1}
  ============================
   exists V1, {sml_member (smap (X n1) V1) (sml_cons (smap n1 V) ML1)}

subst_equiv'_mem < search.
Proof completed.

Abella < Theorem env_eval_pres : 
forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
  csubst (cml_cons (cmap xenv Venv) cml_nil) -> subst_equiv L ML Venv ->
  vars_of_sctx L FVs -> {mapvar FVs Map} -> {L |- of E T} ->
  {ml_member (map E (E' xenv)) (Map xenv)} -> app_subst ML E V -> (exists V',
  {evalcc (E' Venv) V'} /\ equiv T V V').


  ============================
   forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
     csubst (cml_cons (cmap xenv Venv) cml_nil) -> subst_equiv L ML Venv ->
     vars_of_sctx L FVs -> {mapvar FVs Map} -> {L |- of E T} ->
     {ml_member (map E (E' xenv)) (Map xenv)} -> app_subst ML E V ->
     (exists V', {evalcc (E' Venv) V'} /\ equiv T V V')

env_eval_pres < induction on 5.


  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  ============================
   forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
     csubst (cml_cons (cmap xenv Venv) cml_nil) -> subst_equiv L ML Venv ->
     vars_of_sctx L FVs @ -> {mapvar FVs Map} -> {L |- of E T} ->
     {ml_member (map E (E' xenv)) (Map xenv)} -> app_subst ML E V ->
     (exists V', {evalcc (E' Venv) V'} /\ equiv T V V')

env_eval_pres < intros.

  Variables: T, L, ML, Venv, Map, FVs, E, E', V
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' L
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv L ML Venv
  H5 : vars_of_sctx L FVs @
  H6 : {mapvar FVs Map}
  H7 : {L |- of E T}
  H8 : {ml_member (map E (E' n1)) (Map n1)}
  H9 : app_subst ML E V
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < case H5.
Subgoal 1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' nil
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv nil ML Venv
  H6 : {mapvar tl_nil Map}
  H7 : {of E T}
  H8 : {ml_member (map E (E' n1)) (Map n1)}
  H9 : app_subst ML E V
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

Subgoal 2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < case H6.
Subgoal 1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' nil
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv nil ML Venv
  H7 : {of E T}
  H8 : {ml_member (map E (E' n1)) ml_nil}
  H9 : app_subst ML E V
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

Subgoal 2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < case H8.
Subgoal 2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H6 : {mapvar (tl_cons X Vs) Map}
  H7 : {L1, of X T1 |- of E T}
  H8 : {ml_member (map E (E' n1)) (Map n1)}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < case H6.
Subgoal 2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H8 : {ml_member (map E (E' n1)) (ml_cons (map X (fst n1)) (Map1 (rst n1)))}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < case H8.
Subgoal 2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of X T}
  H9 : app_subst ML X V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  ============================
   exists V', {evalcc (fst Venv) V'} /\ equiv T V V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < apply of_var_inv to H1 H7.
Subgoal 2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T :: L1) ML Venv
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  ============================
   exists V', {evalcc (fst Venv) V'} /\ equiv T V V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < case H4.
Subgoal 2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  ============================
   exists V'1, {evalcc (fst (cross V' VL')) V'1} /\ equiv T V V'1

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < apply subst_var to H2 H14 H9.
Subgoal 2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  ============================
   exists V'1, {evalcc (fst (cross V' VL')) V'1} /\ equiv T V1 V'1

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < exists V'.
Subgoal 2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  ============================
   {evalcc (fst (cross V' VL')) V'} /\ equiv T V1 V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < split.
Subgoal 2.1.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  ============================
   {evalcc (fst (cross V' VL')) V'}

Subgoal 2.1.2 is:
 equiv T V1 V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < apply csubst_mem to H3 _.
Subgoal 2.1.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V', X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  H16 : ctname n1
  H17 : {cval (cross V' VL')}
  H18 : {ctm (cross V' VL')}
  ============================
   {evalcc (fst (cross V' VL')) V'}

Subgoal 2.1.2 is:
 equiv T V1 V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < apply val_evalcc to H17.
Subgoal 2.1.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V', X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  H16 : ctname n1
  H17 : {cval (cross V' VL')}
  H18 : {ctm (cross V' VL')}
  H19 : {evalcc (cross V' VL') (cross V' VL')}
  ============================
   {evalcc (fst (cross V' VL')) V'}

Subgoal 2.1.2 is:
 equiv T V1 V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < search.
Subgoal 2.1.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, V1,
             VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T |- of X T}
  H9 : app_subst ML X V1
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : subst_equiv L1 ML VL'
  H14 : {sml_member (smap X V1) ML}
  H15 : equiv T V1 V'
  ============================
   equiv T V1 V'

Subgoal 2.2 is:
 exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < search.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < apply eq_ml_member to H12 H13.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < apply mapvar_mem to H11 H14.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2, E'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'1 n1 n2 (rst n1)
  H16 : env_elem (E'1 n1 n2)
  H17 : {ml_member (map E (E'1 n1 n2 n2)) (Map1 n2)}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < apply env_elem_closed to H16.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'2 n2 (rst n1)
  H16 : env_elem (E'2 n2)
  H17 : {ml_member (map E (E'2 n2 n2)) (Map1 n2)}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < apply env_elem_closed to H16.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < case H1 (keep).
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H19 : tname X
  H20 : forall T', member (of X T') L1 -> T1 = T'
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < clear H19.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H20 : forall T', member (of X T') L1 -> T1 = T'
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < clear H20.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 Venv) cml_nil)
  H4 : subst_equiv (of X T1 :: L1) ML Venv
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  ============================
   exists V', {evalcc (E' Venv) V'} /\ equiv T V V'

env_eval_pres < case H4.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H22 : {sml_member (smap X V1) ML}
  H23 : equiv T1 V1 V'
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < clear H22.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H23 : equiv T1 V1 V'
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < clear H23.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < clear H24.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < apply csubst_single_inv to H3.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < assert csubst (cml_cons (cmap n2 VL') cml_nil).
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < assert {L1 |- of E T}.
Subgoal 2.2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  ============================
   {L1 |- of E T}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < apply sctx_env_sync to H18 H10 H11 H17.
Subgoal 2.2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', T2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : member (of E T2) L1
  H27 : tname E
  ============================
   {L1 |- of E T}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < apply of_var_strenghten to H1 H7 H27 H26.
Subgoal 2.2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', T2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : member (of E T2) L1
  H27 : tname E
  H28 : {L1 |- of E T}
  ============================
   {L1 |- of E T}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < search.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V'
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < apply IH to H18 H2 H25 H21 H10 H11 H26 H17 H9.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < assert {evalcc (E'3 (rst (cross V' VL'))) V'1}.
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < apply csubst_mem to H3 _.
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < case H30 (keep).
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < apply val_evalcc to H33.
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  H34 : {evalcc VL' VL'}
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < assert {evalcc (rst (cross V' VL')) VL'}.
Subgoal 2.2.2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  H34 : {evalcc VL' VL'}
  ============================
   {evalcc (rst (cross V' VL')) VL'}

Subgoal 2.2.2 is:
 {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < apply val_evalcc to H30.
Subgoal 2.2.2.1:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  H34 : {evalcc VL' VL'}
  H35 : {evalcc (cross V' VL') (cross V' VL')}
  ============================
   {evalcc (rst (cross V' VL')) VL'}

Subgoal 2.2.2 is:
 {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < search.
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  H34 : {evalcc VL' VL'}
  H35 : {evalcc (rst (cross V' VL')) VL'}
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < apply env_elem_eval_cong to H16 H34 H35 H27.
Subgoal 2.2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1, X1, V2
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : ctname n1
  H30 : {cval (cross V' VL')}
  H31 : {ctm (cross V' VL')}
  H32 : {cval V'}
  H33 : {cval VL'}
  H34 : {evalcc VL' VL'}
  H35 : {evalcc (rst (cross V' VL')) VL'}
  H36 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  ============================
   {evalcc (E'3 (rst (cross V' VL'))) V'1}

Subgoal 2.2 is:
 exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < search.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  ============================
   exists V'1, {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < exists V'1.
Subgoal 2.2:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  ============================
   {evalcc (E' (cross V' VL')) V'1} /\ equiv T V V'1

env_eval_pres < split.
Subgoal 2.2.3:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  ============================
   {evalcc (E' (cross V' VL')) V'1}

Subgoal 2.2.4 is:
 equiv T V V'1

env_eval_pres < apply eq_inst_eval to H15 H29 with C = cross V' VL'.
Subgoal 2.2.3:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  H30 : {evalcc (E' (cross V' VL')) V'1}
  ============================
   {evalcc (E' (cross V' VL')) V'1}

Subgoal 2.2.4 is:
 equiv T V V'1

env_eval_pres < search.
Subgoal 2.2.4:

  Variables: T, L, ML, Venv, Map, FVs, E, E', V, Vs, X, L1, T1, Map1, L2,
             E'1, E'2, E'3, V1, VL', V', V'1
  IH : forall T L ML Venv Map FVs E E' V, nabla xenv, sctx' L -> subst ML ->
         csubst (cml_cons (cmap xenv Venv) cml_nil) ->
         subst_equiv L ML Venv -> vars_of_sctx L FVs * -> {mapvar FVs Map} ->
         {L |- of E T} -> {ml_member (map E (E' xenv)) (Map xenv)} ->
         app_subst ML E V -> (exists V', {evalcc (E' Venv) V'} /\
         equiv T V V')
  H1 : sctx' (of X T1 :: L1)
  H2 : subst ML
  H3 : csubst (cml_cons (cmap n1 (cross V' VL')) cml_nil)
  H7 : {L1, of X T1 |- of E T}
  H9 : app_subst ML E V
  H10 : vars_of_sctx L1 Vs *
  H11 : {mapvar Vs Map1}
  H12 : L2 n1 = Map1 (rst n1)
  H13 : {ml_member (map E (E' n1)) (L2 n1)}
  H14 : {ml_member (map E (E' n1)) (Map1 (rst n1))}
  H15 : E' n1 = E'3 (rst n1)
  H16 : env_elem E'3
  H17 : {ml_member (map E (E'3 n2)) (Map1 n2)}
  H18 : sctx' L1
  H21 : subst_equiv L1 ML VL'
  H24 : csubst (cml_cons (cmap n1 VL') cml_nil)
  H25 : csubst (cml_cons (cmap n2 VL') cml_nil)
  H26 : {L1 |- of E T}
  H27 : {evalcc (E'3 VL') V'1}
  H28 : equiv T V V'1
  H29 : {evalcc (E'3 (rst (cross V' VL'))) V'1}
  ============================
   equiv T V V'1

env_eval_pres < search.
Proof completed.

Abella < Theorem var_eval_pres : 
forall T L V ML V' Venv FVs Map E E' T' VS ES', nabla x y xenv,
  sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
  csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  vars_of_sctx L FVs -> {mapvar FVs Map} -> {L, of x T |- of (E x) T'} ->
  {ml_member (map (E x) (E' xenv y)) (ml_cons (map x y) (Map xenv))} ->
  app_subst (sml_cons (smap x V) ML) (E x) VS ->
  app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
  (exists VS', {evalcc ES' VS'} /\ equiv T' VS VS').


  ============================
   forall T L V ML V' Venv FVs Map E E' T' VS ES', nabla x y xenv,
     sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
     csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     vars_of_sctx L FVs -> {mapvar FVs Map} -> {L, of x T |- of (E x) T'} ->
     {ml_member (map (E x) (E' xenv y)) (ml_cons (map x y) (Map xenv))} ->
     app_subst (sml_cons (smap x V) ML) (E x) VS ->
     app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
     (exists VS', {evalcc ES' VS'} /\ equiv T' VS VS')

var_eval_pres < intros.

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H8.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 ES'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < assert {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 ES'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < apply subst_var to H2 H11 H9.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 ES'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < assert {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 ES'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < apply csubst_var to H3 H12 H10.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  ============================
   exists VS', {evalcc V' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H4.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  ============================
   exists VS', {evalcc V' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H3.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   exists VS', {evalcc V' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < apply val_evalcc to H18.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  ============================
   exists VS', {evalcc V' VS'} /\ equiv T' V VS'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < exists V'.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  ============================
   {evalcc V' V'} /\ equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < split.
Subgoal 1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  ============================
   {evalcc V' V'}

Subgoal 1.2 is:
 equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < search.
Subgoal 1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of n1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H7.
Subgoal 1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H21 : {L, of n1 T, [F n1] |- of n1 T'}
  H22 : member (F n1) (of n1 T :: L)
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H22.
Subgoal 1.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H21 : {L, of n1 T, [of n1 T] |- of n1 T'}
  ============================
   equiv T' V V'

Subgoal 1.2.2 is:
 equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H21.
Subgoal 1.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F
  H1 : sctx' (of n1 T' :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T' V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  ============================
   equiv T' V V'

Subgoal 1.2.2 is:
 equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < search.
Subgoal 1.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H21 : {L, of n1 T, [F n1] |- of n1 T'}
  H23 : member (F n1) L
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H1.
Subgoal 1.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H21 : {L, of n1 T, [F n1] |- of n1 T'}
  H23 : member (F n1) L
  H24 : sctx' L
  H25 : tname n1
  H26 : forall T', member (of n1 T') L -> T = T'
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < apply sctx'_mem to H24 H23.
Subgoal 1.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F, X, T1
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H21 : {L, of n1 T, [of (X n1) T1] |- of n1 T'}
  H23 : member (of (X n1) T1) L
  H24 : sctx' L
  H25 : tname n1
  H26 : forall T', member (of n1 T') L -> T = T'
  H27 : tname (X n1)
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H21.
Subgoal 1.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', F, X, T1
  H2 : subst (sml_cons (smap n1 V) ML)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : app_subst (sml_cons (smap n1 V) ML) n1 V
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) n2 V'
  H11 : {sml_member (smap n1 V) (sml_cons (smap n1 V) ML)}
  H12 : {cml_member (cmap n2 V') (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))}
  H13 : equiv T V V'
  H14 : subst_equiv L ML Venv
  H15 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H16 : ctname n2
  H17 : {ctm V'}
  H18 : {cval V'}
  H19 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H20 : {evalcc V' V'}
  H23 : member (of n1 T') L
  H24 : sctx' L
  H25 : tname n1
  H26 : forall T', member (of n1 T') L -> T = T'
  H27 : tname n1
  ============================
   equiv T' V V'

Subgoal 2 is:
 exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < apply mem_of_absurd to H23.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (Map n3)}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < apply ml_member_prune1 to H11.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map E1 (E' n3 n2)) (Map n3)}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < apply ml_member_prune2 to H11.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H2.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H13 : tname n1
  H14 : {tm V}
  H15 : {val V}
  H16 : forall V', {sml_member (smap n1 V') ML} -> V' = V
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < clear H13.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H14 : {tm V}
  H15 : {val V}
  H16 : forall V', {sml_member (smap n1 V') ML} -> V' = V
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < clear H14.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H15 : {val V}
  H16 : forall V', {sml_member (smap n1 V') ML} -> V' = V
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < clear H15.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H16 : forall V', {sml_member (smap n1 V') ML} -> V' = V
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < clear H16.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H3.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H18 : ctname n2
  H19 : {ctm V'}
  H20 : {cval V'}
  H21 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < clear H18.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H19 : {ctm V'}
  H20 : {cval V'}
  H21 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < clear H19.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H20 : {cval V'}
  H21 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < clear H20.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H21 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < clear H21.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H9 : app_subst (sml_cons (smap n1 V) ML) E1 VS
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H9.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E1' n3) ES'
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H10.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H23 : app_csubst (cml_cons (cmap n3 Venv) cml_nil) (E1' n3) ES'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H23.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H24 : app_csubst cml_nil (E1' Venv) ES'
  ============================
   exists VS', {evalcc ES' VS'} /\ equiv T' VS VS'

var_eval_pres < case H24.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  ============================
   exists VS', {evalcc (E1' Venv) VS'} /\ equiv T' VS VS'

var_eval_pres < case H4.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H1 : sctx' (of n1 T :: L)
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H25 : equiv T V V'
  H26 : subst_equiv L ML Venv
  ============================
   exists VS', {evalcc (E1' Venv) VS'} /\ equiv T' VS VS'

var_eval_pres < case H1.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H25 : equiv T V V'
  H26 : subst_equiv L ML Venv
  H27 : sctx' L
  H28 : tname n1
  H29 : forall T', member (of n1 T') L -> T = T'
  ============================
   exists VS', {evalcc (E1' Venv) VS'} /\ equiv T' VS VS'

var_eval_pres < apply of_strenghten' to H27 H7.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1'
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H25 : equiv T V V'
  H26 : subst_equiv L ML Venv
  H27 : sctx' L
  H28 : tname n1
  H29 : forall T', member (of n1 T') L -> T = T'
  H30 : {L |- of E1 T'}
  ============================
   exists VS', {evalcc (E1' Venv) VS'} /\ equiv T' VS VS'

var_eval_pres < apply env_eval_pres to H27 H12 H17 H26 H5 H6 H30 H11 H22.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', VS, ES', E1, E1',
             V'1
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of E1 T'}
  H11 : {ml_member (map E1 (E1' n3)) (Map n3)}
  H12 : subst ML
  H17 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H22 : app_subst ML E1 VS
  H25 : equiv T V V'
  H26 : subst_equiv L ML Venv
  H27 : sctx' L
  H28 : tname n1
  H29 : forall T', member (of n1 T') L -> T = T'
  H30 : {L |- of E1 T'}
  H31 : {evalcc (E1' Venv) V'1}
  H32 : equiv T' VS V'1
  ============================
   exists VS', {evalcc (E1' Venv) VS'} /\ equiv T' VS VS'

var_eval_pres < search.
Proof completed.

Abella < Theorem mapenv_eval_pres : 
forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
  sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
  csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  vars_of_sctx L FVs -> {mapvar FVs Map} ->
  subset (NFVs x) (tl_cons x FVs) ->
  {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)} ->
  (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
  {evalcc (PE Venv V') VE'} /\ subst_equiv L' (sml_cons (smap x V) ML) VE').


  ============================
   forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
     sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
     csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     vars_of_sctx L FVs -> {mapvar FVs Map} ->
     subset (NFVs x) (tl_cons x FVs) ->
     {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)} ->
     (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
     {evalcc (PE Venv V') VE'} /\
     subst_equiv L' (sml_cons (smap x V) ML) VE')

mapenv_eval_pres < induction on 8.


  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  ============================
   forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
     sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
     csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     vars_of_sctx L FVs -> {mapvar FVs Map} ->
     subset (NFVs x) (tl_cons x FVs) ->
     {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}@ ->
     (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
     {evalcc (PE Venv V') VE'} /\
     subst_equiv L' (sml_cons (smap x V) ML) VE')

mapenv_eval_pres < intros.

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset (NFVs n1) (tl_cons n1 FVs)
  H8 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}@
  ============================
   exists VE' L', pruned_env nil (NFVs n1) (of n1 T :: L) L' /\
     {evalcc (PE Venv V') VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < case H8.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   exists VE' L', pruned_env nil tl_nil (of n1 T :: L) L' /\
     {evalcc unit VE'} /\ subst_equiv L' (sml_cons (smap n1 V) ML) VE'

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < exists unit.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   exists L', pruned_env nil tl_nil (of n1 T :: L) L' /\
     {evalcc unit unit} /\ subst_equiv L' (sml_cons (smap n1 V) ML) unit

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < exists nil.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   pruned_env nil tl_nil (of n1 T :: L) nil /\ {evalcc unit unit} /\
     subst_equiv nil (sml_cons (smap n1 V) ML) unit

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < split.
Subgoal 1.1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   pruned_env nil tl_nil (of n1 T :: L) nil

Subgoal 1.2 is:
 {evalcc unit unit}

Subgoal 1.3 is:
 subst_equiv nil (sml_cons (smap n1 V) ML) unit

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < search.
Subgoal 1.2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   {evalcc unit unit}

Subgoal 1.3 is:
 subst_equiv nil (sml_cons (smap n1 V) ML) unit

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < search.
Subgoal 1.3:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset tl_nil (tl_cons n1 FVs)
  ============================
   subst_equiv nil (sml_cons (smap n1 V) ML) unit

Subgoal 2 is:
 exists VE' L', pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
   subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < search.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : subset (tl_cons (X n1) (L1 n1)) (tl_cons n1 FVs)
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < case H7.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < apply vars_of_sctx_mem_exists to H1 _ H11.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X n1) T1) (of n1 T :: L)
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < apply of_mem to H13.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X n1) T1}
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < assert app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv).
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < apply subst_equiv'_mem to H4 H13.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1, V1
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X n1) (V1 n1)) (sml_cons (smap n1 V) ML)}
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < apply subst_var' to H2 H16.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1, V1
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X n1) (V1 n1)) (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X n1) (V1 n1)
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < apply subst_mem to H2 H16.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) (V2 n1)) (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) (V2 n1)
  H18 : tname (X1 n1)
  H19 : {val (V2 n1)}
  H20 : {tm (V2 n1)}
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < apply closed_tm_prune to H20.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < apply var_eval_pres to H1 H2 H3 H4 H5 H6 H14 H9 H17 H15.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < apply IH to H1 H2 H3 H4 H5 H6 H12 H10.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists VE' L',
     pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) VE'} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) VE'

mapenv_eval_pres < exists cross VS' VE'.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists L', pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) L' /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) (cross VS' VE')} /\
     subst_equiv L' (sml_cons (smap n1 V) ML) (cross VS' VE')

mapenv_eval_pres < exists of (X n1) T1 :: L' n1.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) (of (X1 n1) T1 :: L' n1) /\
     {evalcc (cross (M V' Venv) (ML1 V' Venv)) (cross VS' VE')} /\
     subst_equiv (of (X1 n1) T1 :: L' n1) (sml_cons (smap n1 V) ML) (cross VS' VE')

mapenv_eval_pres < split.
Subgoal 2.1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   pruned_env nil (tl_cons (X1 n1) (L1 n1)) (of n1 T :: L) (of (X1 n1) T1 :: L' n1)

Subgoal 2.2 is:
 {evalcc (cross (M V' Venv) (ML1 V' Venv)) (cross VS' VE')}

Subgoal 2.3 is:
 subst_equiv (of (X1 n1) T1 :: L' n1) (sml_cons (smap n1 V) ML) (cross VS' VE')

mapenv_eval_pres < search.
Subgoal 2.2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {evalcc (cross (M V' Venv) (ML1 V' Venv)) (cross VS' VE')}

Subgoal 2.3 is:
 subst_equiv (of (X1 n1) T1 :: L' n1) (sml_cons (smap n1 V) ML) (cross VS' VE')

mapenv_eval_pres < search.
Subgoal 2.3:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   subst_equiv (of (X1 n1) T1 :: L' n1) (sml_cons (smap n1 V) ML) (cross VS' VE')

mapenv_eval_pres < unfold.
Subgoal 2.3:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists V1, subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE' /\
     {sml_member (smap (X1 n1) V1) (sml_cons (smap n1 V) ML)} /\
     equiv T1 V1 VS'

mapenv_eval_pres < exists M'.
Subgoal 2.3:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE' /\
     {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)} /\
     equiv T1 M' VS'

mapenv_eval_pres < split.
Subgoal 2.3.1:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'

Subgoal 2.3.2 is:
 {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}

Subgoal 2.3.3 is:
 equiv T1 M' VS'

mapenv_eval_pres < search.
Subgoal 2.3.2:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}

Subgoal 2.3.3 is:
 equiv T1 M' VS'

mapenv_eval_pres < search.
Subgoal 2.3.3:

  Variables: T, L, V, ML, V', Venv, FVs, NFVs, Map, PE, ML1, L1, M, X, T1,
             V1, X1, V2, M', VS', VE', L'
  IH : forall T L V ML V' Venv FVs NFVs Map PE, nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         subset (NFVs x) (tl_cons x FVs) ->
         {mapenv (NFVs x) (ml_cons (map x y) (Map xenv)) (PE xenv y)}* ->
         (exists VE' L', pruned_env nil (NFVs x) (of x T :: L) L' /\
         {evalcc (PE Venv V') VE'} /\
         subst_equiv L' (sml_cons (smap x V) ML) VE')
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H9 : {ml_member (map (X1 n1) (M n2 n3)) (ml_cons (map n1 n2) (Map n3))}*
  H10 : {mapenv (L1 n1) (ml_cons (map n1 n2) (Map n3)) (ML1 n2 n3)}*
  H11 : {tl_member (X1 n1) (tl_cons n1 FVs)}
  H12 : subset (L1 n1) (tl_cons n1 FVs)
  H13 : member (of (X1 n1) T1) (of n1 T :: L)
  H14 : {L, of n1 T |- of (X1 n1) T1}
  H15 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (M n2 n3) (M V' Venv)
  H16 : {sml_member (smap (X1 n1) M') (sml_cons (smap n1 V) ML)}
  H17 : app_subst (sml_cons (smap n1 V) ML) (X1 n1) M'
  H18 : tname (X1 n1)
  H19 : {val M'}
  H20 : {tm M'}
  H21 : {evalcc (M V' Venv) VS'}
  H22 : equiv T1 M' VS'
  H23 : pruned_env nil (L1 n1) (of n1 T :: L) (L' n1)
  H24 : {evalcc (ML1 V' Venv) VE'}
  H25 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   equiv T1 M' VS'

mapenv_eval_pres < search.
Proof completed.

Abella < Theorem eval_pres : 
forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
  sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
  csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
  vars_of_sctx L FVs -> {mapvar FVs Map} -> {L, of x T |- of (E x) T'} ->
  {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
  app_subst (sml_cons (smap x V) ML) (E x) ES ->
  app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
  sim T' ES ES'.


  ============================
   forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
     sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
     csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     vars_of_sctx L FVs -> {mapvar FVs Map} -> {L, of x T |- of (E x) T'} ->
     {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)} ->
     app_subst (sml_cons (smap x V) ML) (E x) ES ->
     app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
     sim T' ES ES'

eval_pres < induction on 8.


  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  ============================
   forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
     sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
     csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
     vars_of_sctx L FVs -> {mapvar FVs Map} -> {L, of x T |- of (E x) T'} ->
     {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}@ ->
     app_subst (sml_cons (smap x V) ML) (E x) ES ->
     app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
     sim T' ES ES'

eval_pres < intros.

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  ============================
   sim T' ES ES'

eval_pres < case H8 (keep).
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  ============================
   sim T' ES ES'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply var_eval_pres to H1 H2 H3 H4 H5 H6 H7 H11 H9 H10.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   sim T' ES ES'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < unfold.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   exists V V', {eval ES V} /\ {evalcc ES' V'} /\ equiv T' V V'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < exists ES.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   exists V', {eval ES ES} /\ {evalcc ES' V'} /\ equiv T' ES V'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < exists VS'.
Subgoal 1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   {eval ES ES} /\ {evalcc ES' VS'} /\ equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < split.
Subgoal 1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   {eval ES ES}

Subgoal 1.2 is:
 {evalcc ES' VS'}

Subgoal 1.3 is:
 equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply equiv_val to H13.
Subgoal 1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  H14 : {val ES}
  ============================
   {eval ES ES}

Subgoal 1.2 is:
 {evalcc ES' VS'}

Subgoal 1.3 is:
 equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply val_eval to H14.
Subgoal 1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  H14 : {val ES}
  H15 : {eval ES ES}
  ============================
   {eval ES ES}

Subgoal 1.2 is:
 {evalcc ES' VS'}

Subgoal 1.3 is:
 equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   {evalcc ES' VS'}

Subgoal 1.3 is:
 equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 1.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', VS'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (E n1) T'}
  H8 : {cc (E n1) (E' n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (E n1) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (E' n3 n2) ES'
  H11 : {ml_member (map (E n1) (E' n3 n2)) (ml_cons (map n1 n2) (Map n3))}*
  H12 : {evalcc ES' VS'}
  H13 : equiv T' ES VS'
  ============================
   equiv T' ES VS'

Subgoal 2 is:
 sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) T'}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) ES'
  ============================
   sim T' ES ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply subst_closed_tm to _ H9.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) T'}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) (lnat N)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) ES'
  ============================
   sim T' (lnat N) ES'

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply csubst_closed_ctm to _ H10.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) T'}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) (lnat N)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) (clnat N)
  ============================
   sim T' (lnat N) (clnat N)

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert equiv nat_t (lnat N) (clnat N).
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) T'}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) (lnat N)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) (clnat N)
  H11 : equiv nat_t (lnat N) (clnat N)
  ============================
   sim T' (lnat N) (clnat N)

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply equiv_to_sim to H11.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) T'}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) (lnat N)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) (clnat N)
  H11 : equiv nat_t (lnat N) (clnat N)
  H12 : sim nat_t (lnat N) (clnat N)
  ============================
   sim T' (lnat N) (clnat N)

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply of_nat to H1 H7.
Subgoal 2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', N
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (lnat N) nat_t}
  H8 : {cc (lnat N) (clnat N) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (lnat N) (lnat N)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (clnat N) (clnat N)
  H11 : equiv nat_t (lnat N) (clnat N)
  H12 : sim nat_t (lnat N) (clnat N)
  ============================
   sim nat_t (lnat N) (clnat N)

Subgoal 3 is:
 sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) T'}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) ES'
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  ============================
   sim T' ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply of_abs_arrow_typ to H1 H7.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) ES'
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  ============================
   sim (arr T1 T2) ES ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply subst_abs to H9.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) ES'
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  ============================
   sim (arr T1 T2) (abs ES1) ES'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply csubst_cpair to H10.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  ============================
   sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert name_map (Map n3).
Subgoal 3.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  ============================
   name_map (Map n3)

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H1.
Subgoal 3.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : sctx' L
  H19 : tname n1
  H20 : forall T', member (of n1 T') L -> T = T'
  ============================
   name_map (Map n3)

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply mapvar_named_map to H18 H5 H6 with X = n3.
Subgoal 3.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : sctx' L
  H19 : tname n1
  H20 : forall T', member (of n1 T') L -> T = T'
  H21 : name_map (Map n3)
  ============================
   name_map (Map n3)

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  ============================
   sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}.
Subgoal 3.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply mapvar_env_map to H6.
Subgoal 3.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : env_map Map
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply clos_closed to H18 H19 H8.
Subgoal 3.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : env_map Map
  H20 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}
  ============================
   {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}

Subgoal 3 is:
 sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) (PE n3 n2)) (cpair ES'1 ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (P n3 n2 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y)))) ES'1
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P n3 n2 xenv y))))}
  ============================
   sim (arr T1 T2) (abs ES1) (cpair ES'1 ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply csubst_closed_ctm to H19 H16.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply closed_ctm_prune to H19.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply closed_ctm_prune to H19.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H16 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < clear H16.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  H19 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < clear H19.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H18 : name_map (Map n3)
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < clear H18.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply fvars_subset to _ H11.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply mapenv_eval_pres to H1 H2 H3 H4 H5 H6 H20 H12.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   sim (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)

Subgoal 4 is:
 sim T' ES ES'

eval_pres < unfold.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists V V', {eval (abs ES1) V} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2) V'} /\
     equiv (arr T1 T2) V V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < exists abs ES1.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (PE n3 n2) ES'2
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists V', {eval (abs ES1) (abs ES1)} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2) V'} /\
     equiv (arr T1 T2) (abs ES1) V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H17.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H24 : app_csubst (cml_cons (cmap n3 Venv) cml_nil) (PE n3 V') ES'2
  ============================
   exists V', {eval (abs ES1) (abs ES1)} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2) V'} /\
     equiv (arr T1 T2) (abs ES1) V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H24.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2)
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H25 : app_csubst cml_nil (PE Venv V') ES'2
  ============================
   exists V', {eval (abs ES1) (abs ES1)} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) ES'2) V'} /\
     equiv (arr T1 T2) (abs ES1) V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H25.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   exists V'1, {eval (abs ES1) (abs ES1)} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V')) V'1} /\
     equiv (arr T1 T2) (abs ES1) V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < exists cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE'.
Subgoal 3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {eval (abs ES1) (abs ES1)} /\
     {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V')) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')} /\
     equiv (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')

Subgoal 4 is:
 sim T' ES ES'

eval_pres < split.
Subgoal 3.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {eval (abs ES1) (abs ES1)}

Subgoal 3.4 is:
 {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V')) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5 is:
 equiv (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V')) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5 is:
 equiv (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   equiv (arr T1 T2) (abs ES1) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')

Subgoal 4 is:
 sim T' ES ES'

eval_pres < unfold.
Subgoal 3.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply sctx'_tmctx_exists to H1.
Subgoal 3.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  ============================
   {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply of_tm to H26 H7.
Subgoal 3.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  ============================
   {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert forall X, member (tm X) (L'1 n1) -> (exists V',
  {sml_member (smap X V') (sml_cons (smap n1 V) ML)}).
Subgoal 3.5.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  ============================
   forall X, member (tm X) (L'1 n1) -> (exists V'1,
     {sml_member (smap X V'1) (sml_cons (smap n1 V) ML)})

Subgoal 3.5.1 is:
 {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < intros.
Subgoal 3.5.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1, X
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  H29 : member (tm (X n1)) (L'1 n1)
  ============================
   exists V'1, {sml_member (smap (X n1) V'1) (sml_cons (smap n1 V) ML)}

Subgoal 3.5.1 is:
 {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply sctx'_tmctx_sync2 to H26 H29.
Subgoal 3.5.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1, X, T3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  H29 : member (tm (X n1)) (L'1 n1)
  H30 : member (of (X n1) T3) (of n1 T :: L)
  ============================
   exists V'1, {sml_member (smap (X n1) V'1) (sml_cons (smap n1 V) ML)}

Subgoal 3.5.1 is:
 {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply subst_equiv'_mem to H4 H30.
Subgoal 3.5.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1, X, T3, V1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  H29 : member (tm (X n1)) (L'1 n1)
  H30 : member (of (X n1) T3) (of n1 T :: L)
  H31 : {sml_member (smap (X n1) (V1 n1)) (sml_cons (smap n1 V) ML)}
  ============================
   exists V'1, {sml_member (smap (X n1) V'1) (sml_cons (smap n1 V) ML)}

Subgoal 3.5.1 is:
 {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  H29 : forall X, member (tm X) (L'1 n1) -> (exists V'1,
          {sml_member (smap X V'1) (sml_cons (smap n1 V) ML)})
  ============================
   {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply subst_result_closed_tm to H2 H27 H28 H29 H9.
Subgoal 3.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', L'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : sctx'_tmctx (of n1 T :: L) (L'1 n1)
  H27 : tmctx (L'1 n1)
  H28 : {L'1 n1 |- tm (abs (M n1))}
  H29 : forall X, member (tm X) (L'1 n1) -> (exists V'1,
          {sml_member (smap X V'1) (sml_cons (smap n1 V) ML)})
  H30 : {tm (abs ES1)}
  ============================
   {tm (abs ES1)}

Subgoal 3.5.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply mapvar_env_map to H6.
Subgoal 3.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply cc_ctm to H26 H8.
Subgoal 3.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H27 : {ctm n3, ctm n2 |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H27.
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H3.
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H30 : csubst (cml_cons (cmap n3 Venv) cml_nil)
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H30.
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < inst H29 with n3 = Venv, n2 = V'.
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < cut H40 with H32.
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < cut H41 with H37.
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  H42 : {ctm (PE Venv V')}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply evalcc_ctm_pres to H22 H42.
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  H42 : {ctm (PE Venv V')}
  H43 : {ctm VE'}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H1.
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  H42 : {ctm (PE Venv V')}
  H43 : {ctm VE'}
  H44 : sctx' L
  H45 : tname n1
  H46 : forall T', member (of n1 T') L -> T = T'
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply mapvar_named_map to H44 H5 H6 with X = n3.
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  H42 : {ctm (PE Venv V')}
  H43 : {ctm VE'}
  H44 : sctx' L
  H45 : tname n1
  H46 : forall T', member (of n1 T') L -> T = T'
  H47 : name_map (Map n3)
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply clos_closed to H47 H26 H8.
Subgoal 3.5.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H2 : subst (sml_cons (smap n1 V) ML)
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2 |- ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  H29 : {ctm n3, ctm n2 |- ctm (PE n3 n2)}
  H31 : ctname n2
  H32 : {ctm V'}
  H33 : {cval V'}
  H34 : forall V'1,
          {cml_member (cmap n2 V'1) (cml_cons (cmap n3 Venv) cml_nil)} ->
          V'1 = V'
  H35 : csubst cml_nil
  H36 : ctname n3
  H37 : {ctm Venv}
  H38 : {cval Venv}
  H39 : forall V', {cml_member (cmap n3 V') cml_nil} -> V' = Venv
  H40 : {ctm Venv, ctm V' |- ctm (PE Venv V')}
  H41 : {ctm Venv |- ctm (PE Venv V')}
  H42 : {ctm (PE Venv V')}
  H43 : {ctm VE'}
  H44 : sctx' L
  H45 : tname n1
  H46 : forall T', member (of n1 T') L -> T = T'
  H47 : name_map (Map n3)
  H48 : {ctm (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y))))}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2, [F n2 n3] |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  H29 : member (F n2 n3) (ctm n2 :: ctm n3 :: nil)
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H29.
Subgoal 3.5.2.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2, [ctm n2] |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H28.
Subgoal 3.5.2.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2, [F n2 n3] |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  H30 : member (F n2 n3) (ctm n3 :: nil)
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H30.
Subgoal 3.5.2.2.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2, [ctm n3] |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.2.2.2.2 is:
 {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H28.
Subgoal 3.5.2.2.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : env_map Map
  H28 : {ctm n3, ctm n2, [F n2 n3] |- ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2))}
  H31 : member (F n2 n3) nil
  ============================
   {ctm (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.3 is:
 {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H31.
Subgoal 3.5.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {val (abs ES1)}

Subgoal 3.5.4 is:
 {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply evalcc_val to H22.
Subgoal 3.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : {cval VE'}
  ============================
   {cval (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}

Subgoal 3.5.5 is:
 forall V1 V1', equiv T1 V1 V1' ->
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  ============================
   forall V1 V1', equiv T1 V1 V1' ->
     sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < intros.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert {L' n1 |- of (abs (M n1)) (arr T1 T2)}.
Subgoal 3.5.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  ============================
   {L' n1 |- of (abs (M n1)) (arr T1 T2)}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert vars_of_sctx (of n1 T :: L) (tl_cons n1 FVs).
Subgoal 3.5.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : vars_of_sctx (of n1 T :: L) (tl_cons n1 FVs)
  ============================
   {L' n1 |- of (abs (M n1)) (arr T1 T2)}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply fvars_islist to _ H11.
Subgoal 3.5.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : vars_of_sctx (of n1 T :: L) (tl_cons n1 FVs)
  H28 : islist (NFVs n1)
  ============================
   {L' n1 |- of (abs (M n1)) (arr T1 T2)}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply subset_refl to H28.
Subgoal 3.5.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : vars_of_sctx (of n1 T :: L) (tl_cons n1 FVs)
  H28 : islist (NFVs n1)
  H29 : subset (NFVs n1) (NFVs n1)
  ============================
   {L' n1 |- of (abs (M n1)) (arr T1 T2)}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply pruned_env_typing to H1 H7 H27 _ H11 H29 H21.
Subgoal 3.5.5.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : vars_of_sctx (of n1 T :: L) (tl_cons n1 FVs)
  H28 : islist (NFVs n1)
  H29 : subset (NFVs n1) (NFVs n1)
  H30 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  ============================
   {L' n1 |- of (abs (M n1)) (arr T1 T2)}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)).
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert sctx' (of n4 T1 :: L' n1).
Subgoal 3.5.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   sctx' (of n4 T1 :: L' n1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply pruned_env_sctx to H1 _ H21.
Subgoal 3.5.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (L' n1)
  ============================
   sctx' (of n4 T1 :: L' n1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply sctx'_extend to H29 with x = n4, T = T1.
Subgoal 3.5.5.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (L' n1)
  H30 : sctx' (of n4 T1 :: L' n1)
  ============================
   sctx' (of n4 T1 :: L' n1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)).
Subgoal 3.5.5.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  ============================
   subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply equiv_closed_tm to H26.
Subgoal 3.5.5.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : {tm V1}
  ============================
   subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply equiv_val to H26.
Subgoal 3.5.5.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : {tm V1}
  H31 : {val V1}
  ============================
   subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply subst_extend to H2 H30 H31 with x = n4.
Subgoal 3.5.5.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : {tm V1}
  H31 : {val V1}
  H32 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  ============================
   subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)).
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply subst_equiv_closed_ctm to H23.
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply subst_equiv_cval to H23.
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert csubst cml_nil.
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  H33 : csubst cml_nil
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply csubst_extend to H33 H31 H32 with x = n6.
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  H33 : csubst cml_nil
  H34 : csubst (cml_cons (cmap n6 VE') cml_nil)
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply equiv_closed_ctm to H26.
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  H33 : csubst cml_nil
  H34 : csubst (cml_cons (cmap n6 VE') cml_nil)
  H35 : {ctm V1'}
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply equiv_cval to H26.
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  H33 : csubst cml_nil
  H34 : csubst (cml_cons (cmap n6 VE') cml_nil)
  H35 : {ctm V1'}
  H36 : {cval V1'}
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply csubst_extend to H34 H35 H36 with x = n5.
Subgoal 3.5.5.4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : {ctm VE'}
  H32 : {cval VE'}
  H33 : csubst cml_nil
  H34 : csubst (cml_cons (cmap n6 VE') cml_nil)
  H35 : {ctm V1'}
  H36 : {cval V1'}
  H37 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1).
Subgoal 3.5.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < unfold.
Subgoal 3.5.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   nabla x, app_subst (sml_cons (smap n1 V) ML) (M n1 V1) (ES1 V1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < intros.
Subgoal 3.5.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  ============================
   app_subst (sml_cons (smap n1 V) ML) (M n1 V1) (ES1 V1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply equiv_closed_tm to H26.
Subgoal 3.5.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : {tm V1}
  ============================
   app_subst (sml_cons (smap n1 V) ML) (M n1 V1) (ES1 V1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply subst_inst to H32 H15.
Subgoal 3.5.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : {tm V1}
  H33 : app_subst (sml_cons (smap n1 V) ML) (M n1 V1) (ES1 V1)
  ============================
   app_subst (sml_cons (smap n1 V) ML) (M n1 V1) (ES1 V1)

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1').
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply pruned_env_vars to H21.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (NMap n1 n3 n2)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (NMap n1 n3 n2 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply mapvar_prune to H13.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML'
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML' n2 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML' n2 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply mapvar_prune to H13.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert {L' n1, of n4 T1 |- of (M n1 n4) T2}.
Subgoal 3.5.5.6:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H27.
Subgoal 3.5.5.6.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n2 T1 |- of (M n1 n2) T2}
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5.6.2 is:
 {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.5.6.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, [F n1] |- of (abs (M n1)) (arr T1 T2)}
  H36 : member (F n1) (L' n1)
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H29.
Subgoal 3.5.5.6.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, [F n1] |- of (abs (M n1)) (arr T1 T2)}
  H36 : member (F n1) (L' n1)
  H37 : sctx' (L' n1)
  H38 : tname n4
  H39 : forall T', member (of n4 T') (L' n1) -> T1 = T'
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply sctx'_mem to H37 H36.
Subgoal 3.5.5.6.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, F, X, T3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, [of (X n1) T3] |- of (abs (M n1)) (arr T1 T2)}
  H36 : member (of (X n1) T3) (L' n1)
  H37 : sctx' (L' n1)
  H38 : tname n4
  H39 : forall T', member (of n4 T') (L' n1) -> T1 = T'
  H40 : tname (X n1)
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H35.
Subgoal 3.5.5.6.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, F, X, T3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H36 : member (of (abs (M n1)) (arr T1 T2)) (L' n1)
  H37 : sctx' (L' n1)
  H38 : tname n4
  H39 : forall T', member (of n4 T') (L' n1) -> T1 = T'
  H40 : tname (abs (M n1))
  ============================
   {L' n1, of n4 T1 |- of (M n1 n4) T2}

Subgoal 3.5.5 is:
 sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H40.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply IH to H29 H30 H31 H28 H34 H13 H35 H14 H32 H33.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H36 : sim T2 (ES1 V1) (ES'3 VE' V1')
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < case H36.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   sim T2 (app (abs ES1) V1) (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env)))

Subgoal 4 is:
 sim T' ES ES'

eval_pres < unfold.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   exists V V', {eval (app (abs ES1) V1) V} /\
     {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'} /\
     equiv T2 V V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < exists V2.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   exists V', {eval (app (abs ES1) V1) V2} /\
     {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'} /\
     equiv T2 V2 V'

Subgoal 4 is:
 sim T' ES ES'

eval_pres < exists V'1.
Subgoal 3.5.5:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   {eval (app (abs ES1) V1) V2} /\
     {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1} /\
     equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < split.
Subgoal 3.5.5.7:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   {eval (app (abs ES1) V1) V2}

Subgoal 3.5.5.8 is:
 {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply equiv_val to H26.
Subgoal 3.5.5.7:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {val V1}
  ============================
   {eval (app (abs ES1) V1) V2}

Subgoal 3.5.5.8 is:
 {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply val_eval to H40.
Subgoal 3.5.5.7:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {val V1}
  H41 : {eval V1 V1}
  ============================
   {eval (app (abs ES1) V1) V2}

Subgoal 3.5.5.8 is:
 {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply evalcc_val to H22.
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply val_evalcc to H40.
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply equiv_cval to H26.
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  H42 : {cval V1'}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < apply val_evalcc to H42.
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  H42 : {cval V1'}
  H43 : {evalcc V1' V1'}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}.
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  H42 : {cval V1'}
  H43 : {evalcc V1' V1'}
  H44 : {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert {evalcc (cross V1' VE') (cross V1' VE')}.
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  H42 : {cval V1'}
  H43 : {evalcc V1' V1'}
  H44 : {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}
  H45 : {evalcc (cross V1' VE') (cross V1' VE')}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < assert {evalcc (capp (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (cross V1' VE')) V'1}.
Subgoal 3.5.5.8:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  H40 : {cval VE'}
  H41 : {evalcc VE' VE'}
  H42 : {cval V1'}
  H43 : {evalcc V1' V1'}
  H44 : {evalcc (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE')}
  H45 : {evalcc (cross V1' VE') (cross V1' VE')}
  H46 : {evalcc (capp (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (cross V1' VE')) V'1}
  ============================
   {evalcc (cunpair (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) VE') (f\env\capp f (cross V1' env))) V'1}

Subgoal 3.5.5.9 is:
 equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 3.5.5.9:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', NFVs, NMap,
             P, M, PE, T1, T2, M', ES1, M'1, F', ES'2, ES'1, ES'3, M'2, M'3,
             VE', L', V1, V1', ML', ML'1, V2, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (abs (M n1)) (arr T1 T2)}
  H8 : {cc (abs (M n1)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (abs (M n1)) (abs ES1)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE n3 n2)) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\ES'3 xenv y)))) (PE Venv V'))
  H11 : {fvars (abs (M n1)) (tl_cons n1 FVs) (NFVs n1)}*
  H12 : {mapenv (NFVs n1) (ml_cons (map n1 n2) (Map n3)) (PE n3 n2)}*
  H13 : {mapvar (NFVs n1) (ML'1 n1)}*
  H14 : {cc (M n1 n4) (ES'3 n6 n5) (ml_cons (map n4 n5) (ML'1 n1 n6)) (tl_cons n4 (NFVs n1))}*
  H15 : app_subst (sml_cons (smap n1 V) ML) (M n1 n2) (ES1 n2)
  H20 : subset (NFVs n1) (tl_cons n1 FVs)
  H21 : pruned_env nil (NFVs n1) (of n1 T :: L) (L' n1)
  H22 : {evalcc (PE Venv V') VE'}
  H23 : subst_equiv (L' n1) (sml_cons (smap n1 V) ML) VE'
  H26 : equiv T1 V1 V1'
  H27 : {L' n1 |- of (abs (M n1)) (arr T1 T2)}
  H28 : subst_equiv' (of n4 T1 :: L' n1) (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H29 : sctx' (of n4 T1 :: L' n1)
  H30 : subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML))
  H31 : csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil))
  H32 : app_subst (sml_cons (smap n4 V1) (sml_cons (smap n1 V) ML)) (M n1 n4) (ES1 V1)
  H33 : app_csubst (cml_cons (cmap n5 V1') (cml_cons (cmap n6 VE') cml_nil)) (ES'3 n6 n5) (ES'3 VE' V1')
  H34 : vars_of_sctx (L' n1) (NFVs n1)
  H35 : {L' n1, of n4 T1 |- of (M n1 n4) T2}
  H37 : {eval (ES1 V1) V2}
  H38 : {evalcc (ES'3 VE' V1') V'1}
  H39 : equiv T2 V2 V'1
  ============================
   equiv T2 V2 V'1

Subgoal 4 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 4:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H7 : {L, of n1 T |- of (app (M1 n1) (M2 n1)) T'}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  ============================
   sim T' ES ES'

eval_pres < case H7.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  ============================
   sim T' ES ES'

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < apply subst_app to H9.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  ============================
   sim T' (app ES1 ES2) ES'

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < apply csubst_cunpair to H10.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < apply IH to H1 H2 H3 H4 H5 H6 H13 H11 H15 H17.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H19 : sim (arr T1 T') ES1 ES'1
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < apply IH to H1 H2 H3 H4 H5 H6 H14 H12 H16 H18.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H19 : sim (arr T1 T') ES1 ES'1
  H20 : sim T1 ES2 ES'2
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < case H19.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1, V'1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H20 : sim T1 ES2 ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H23 : equiv (arr T1 T') V1 V'1
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < case H20.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H23 : equiv (arr T1 T') V1 V'1
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < case H23.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < apply H31 to H26.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H32 : sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V'2 env)))
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < case H32.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H34 : {evalcc (cunpair V'1 (f\env\capp f (cross V'2 env))) V'3}
  H35 : equiv T' V3 V'3
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < case H34.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   sim T' (app ES1 ES2) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < unfold.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   exists V V', {eval (app ES1 ES2) V} /\
     {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'} /\
     equiv T' V V'

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < exists V3.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   exists V', {eval (app ES1 ES2) V3} /\
     {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'} /\
     equiv T' V3 V'

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < exists V'3.
Subgoal 4.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   {eval (app ES1 ES2) V3} /\
     {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3} /\
     equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < split.
Subgoal 4.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   {eval (app ES1 ES2) V3}

Subgoal 4.1.2 is:
 {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3}

Subgoal 4.1.3 is:
 equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < apply eval_app_trans to H21 H24 H33.
Subgoal 4.1.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  H38 : {eval (app ES1 ES2) V3}
  ============================
   {eval (app ES1 ES2) V3}

Subgoal 4.1.2 is:
 {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3}

Subgoal 4.1.3 is:
 equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 4.1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3}

Subgoal 4.1.3 is:
 equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < apply evalcc_trans to H22 H36.
Subgoal 4.1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  H38 : {evalcc ES'1 (cpair F E1)}
  ============================
   {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3}

Subgoal 4.1.3 is:
 equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < apply evalcc_capp_trans to H25 H37.
Subgoal 4.1.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  H38 : {evalcc ES'1 (cpair F E1)}
  H39 : {evalcc (capp F (cross ES'2 E1)) V'3}
  ============================
   {evalcc (cunpair ES'1 (f\env\capp f (cross ES'2 env))) V'3}

Subgoal 4.1.3 is:
 equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 4.1.3:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, T1, M1', M2', ES2, ES1, CM1', CM2', ES'2, ES'1, V1,
             V'1, V2, V'2, V3, V'3, E1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) (app ES1 ES2)
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (cunpair ES'1 (f\env\capp f (cross ES'2 env)))
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T |- of (M1 n1) (arr T1 T')}
  H14 : {L, of n1 T |- of (M2 n1) T1}
  H15 : app_subst (sml_cons (smap n1 V) ML) (M1 n1) ES1
  H16 : app_subst (sml_cons (smap n1 V) ML) (M2 n1) ES2
  H17 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM1 n3 n2) ES'1
  H18 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (CM2 n3 n2) ES'2
  H21 : {eval ES1 V1}
  H22 : {evalcc ES'1 V'1}
  H24 : {eval ES2 V2}
  H25 : {evalcc ES'2 V'2}
  H26 : equiv T1 V2 V'2
  H27 : {tm V1}
  H28 : {ctm V'1}
  H29 : {val V1}
  H30 : {cval V'1}
  H31 : forall V2 V1', equiv T1 V2 V1' ->
          sim T' (app V1 V2) (cunpair V'1 (f\env\capp f (cross V1' env)))
  H33 : {eval (app V1 V2) V3}
  H35 : equiv T' V3 V'3
  H36 : {evalcc V'1 (cpair F E1)}
  H37 : {evalcc (capp F (cross V'2 E1)) V'3}
  ============================
   equiv T' V3 V'3

Subgoal 4.2 is:
 sim T' ES ES'

eval_pres < search.
Subgoal 4.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, F
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T, [F n1] |- of (app (M1 n1) (M2 n1)) T'}
  H14 : member (F n1) (of n1 T :: L)
  ============================
   sim T' ES ES'

eval_pres < apply sctx'_mem to H1 H14.
Subgoal 4.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, F, X, T1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T, [of (X n1) T1] |- of (app (M1 n1) (M2 n1)) T'}
  H14 : member (of (X n1) T1) (of n1 T :: L)
  H15 : tname (X n1)
  ============================
   sim T' ES ES'

eval_pres < case H14.
Subgoal 4.2.1:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, F, X, T1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T, [of n1 T] |- of (app (M1 n1) (M2 n1)) T'}
  H15 : tname n1
  ============================
   sim T' ES ES'

Subgoal 4.2.2 is:
 sim T' ES ES'

eval_pres < case H13.
Subgoal 4.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, F, X, T1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H13 : {L, of n1 T, [of (X n1) T1] |- of (app (M1 n1) (M2 n1)) T'}
  H15 : tname (X n1)
  H16 : member (of (X n1) T1) L
  ============================
   sim T' ES ES'

eval_pres < case H13.
Subgoal 4.2.2:

  Variables: T, L, V, ML, V', Venv, FVs, Map, E, E', T', ES, ES', CM2, M2,
             CM1, M1, F, X, T1
  IH : forall T L V ML V' Venv FVs Map E E' T' ES ES', nabla x y xenv,
         sctx' (of x T :: L) -> subst (sml_cons (smap x V) ML) ->
         csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         subst_equiv' (of x T :: L) (sml_cons (smap x V) ML) (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) ->
         vars_of_sctx L FVs -> {mapvar FVs Map} ->
         {L, of x T |- of (E x) T'} ->
         {cc (E x) (E' xenv y) (ml_cons (map x y) (Map xenv)) (tl_cons x FVs)}* ->
         app_subst (sml_cons (smap x V) ML) (E x) ES ->
         app_csubst (cml_cons (cmap y V') (cml_cons (cmap xenv Venv) cml_nil)) (E' xenv y) ES' ->
         sim T' ES ES'
  H1 : sctx' (of n1 T :: L)
  H2 : subst (sml_cons (smap n1 V) ML)
  H3 : csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H4 : subst_equiv' (of n1 T :: L) (sml_cons (smap n1 V) ML) (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil))
  H5 : vars_of_sctx L FVs
  H6 : {mapvar FVs Map}
  H8 : {cc (app (M1 n1) (M2 n1)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}@
  H9 : app_subst (sml_cons (smap n1 V) ML) (app (M1 n1) (M2 n1)) ES
  H10 : app_csubst (cml_cons (cmap n2 V') (cml_cons (cmap n3 Venv) cml_nil)) (cunpair (CM1 n3 n2) (f\env\capp f (cross (CM2 n3 n2) env))) ES'
  H11 : {cc (M1 n1) (CM1 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H12 : {cc (M2 n1) (CM2 n3 n2) (ml_cons (map n1 n2) (Map n3)) (tl_cons n1 FVs)}*
  H15 : tname (app (M1 n1) (M2 n1))
  H16 : member (of (app (M1 n1) (M2 n1)) T') L
  ============================
   sim T' ES ES'

eval_pres < case H15.
Proof completed.

Abella < Theorem fvars_extend : 
forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs} ->
  {L |- fvars M (tl_cons x FVs) NFVs}.


  ============================
   forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs} ->
     {L |- fvars M (tl_cons x FVs) NFVs}

fvars_extend < induction on 2.


  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  ============================
   forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}@ ->
     {L |- fvars M (tl_cons x FVs) NFVs}

fvars_extend < intros.

  Variables: L, M, FVs, NFVs
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H2 : {L |- fvars M FVs NFVs}@
  ============================
   {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < case H2.
Subgoal 1:

  Variables: L, M, FVs, NFVs
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L |- notfree M}*
  ============================
   {L |- fvars M (tl_cons n1 FVs) tl_nil}

Subgoal 2 is:
 {L |- fvars (lnat X) (tl_cons n1 FVs) tl_nil}

Subgoal 3 is:
 {L |- fvars M (tl_cons n1 FVs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < search.
Subgoal 2:

  Variables: L, M, FVs, NFVs, X
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  ============================
   {L |- fvars (lnat X) (tl_cons n1 FVs) tl_nil}

Subgoal 3 is:
 {L |- fvars M (tl_cons n1 FVs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < search.
Subgoal 3:

  Variables: L, M, FVs, NFVs
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L |- tl_member M FVs}*
  ============================
   {L |- fvars M (tl_cons n1 FVs) (tl_cons M tl_nil)}

Subgoal 4 is:
 {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < search.
Subgoal 4:

  Variables: L, M, FVs, NFVs, Fvs2, Fvs1, M2, M1
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L |- fvars M1 FVs Fvs1}*
  H4 : {L |- fvars M2 FVs Fvs2}*
  H5 : {L |- combine Fvs1 Fvs2 NFVs}*
  ============================
   {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < apply IH to H1 H3.
Subgoal 4:

  Variables: L, M, FVs, NFVs, Fvs2, Fvs1, M2, M1
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L |- fvars M1 FVs Fvs1}*
  H4 : {L |- fvars M2 FVs Fvs2}*
  H5 : {L |- combine Fvs1 Fvs2 NFVs}*
  H6 : {L |- fvars M1 (tl_cons n1 FVs) Fvs1}
  ============================
   {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < apply IH to H1 H4.
Subgoal 4:

  Variables: L, M, FVs, NFVs, Fvs2, Fvs1, M2, M1
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L |- fvars M1 FVs Fvs1}*
  H4 : {L |- fvars M2 FVs Fvs2}*
  H5 : {L |- combine Fvs1 Fvs2 NFVs}*
  H6 : {L |- fvars M1 (tl_cons n1 FVs) Fvs1}
  H7 : {L |- fvars M2 (tl_cons n1 FVs) Fvs2}
  ============================
   {L |- fvars (app M1 M2) (tl_cons n1 FVs) NFVs}

Subgoal 5 is:
 {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < search.
Subgoal 5:

  Variables: L, M, FVs, NFVs, M1
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L, notfree n1 |- fvars (M1 n1) FVs NFVs}*
  ============================
   {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < apply IH to _ H3.
Subgoal 5:

  Variables: L, M, FVs, NFVs, M1
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L, notfree n1 |- fvars (M1 n1) FVs NFVs}*
  H4 : {L, notfree n1 |- fvars (M1 n1) (tl_cons n2 FVs) NFVs}
  ============================
   {L |- fvars (abs M1) (tl_cons n1 FVs) NFVs}

Subgoal 6 is:
 {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < search.
Subgoal 6:

  Variables: L, M, FVs, NFVs, F
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L, [F] |- fvars M FVs NFVs}*
  H4 : member F L
  ============================
   {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < apply bvars_mem to H1 H4.
Subgoal 6:

  Variables: L, M, FVs, NFVs, F, X
  IH : forall L M FVs NFVs, nabla x, bvars L -> {L |- fvars M FVs NFVs}* ->
         {L |- fvars M (tl_cons x FVs) NFVs}
  H1 : bvars L
  H3 : {L, [notfree X] |- fvars M FVs NFVs}*
  H4 : member (notfree X) L
  H5 : tname X
  ============================
   {L |- fvars M (tl_cons n1 FVs) NFVs}

fvars_extend < case H3.
Proof completed.

Abella < Theorem mapenv_extend : 
forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE} ->
  {mapenv NFVs (ml_cons (map x y) Map) PE}.


  ============================
   forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE} ->
     {mapenv NFVs (ml_cons (map x y) Map) PE}

mapenv_extend < induction on 1.


  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  ============================
   forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}@ ->
     {mapenv NFVs (ml_cons (map x y) Map) PE}

mapenv_extend < intros.

  Variables: NFVs, Map, PE
  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  H1 : {mapenv NFVs Map PE}@
  ============================
   {mapenv NFVs (ml_cons (map n1 n2) Map) PE}

mapenv_extend < case H1.
Subgoal 1:

  Variables: NFVs, Map, PE
  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  ============================
   {mapenv tl_nil (ml_cons (map n1 n2) Map) unit}

Subgoal 2 is:
 {mapenv (tl_cons X L) (ml_cons (map n1 n2) Map) (cross M ML)}

mapenv_extend < search.
Subgoal 2:

  Variables: NFVs, Map, PE, ML, L, M, X
  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  H2 : {ml_member (map X M) Map}*
  H3 : {mapenv L Map ML}*
  ============================
   {mapenv (tl_cons X L) (ml_cons (map n1 n2) Map) (cross M ML)}

mapenv_extend < assert {ml_member (map X M) (ml_cons (map n1 n2) Map)}.
Subgoal 2:

  Variables: NFVs, Map, PE, ML, L, M, X
  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  H2 : {ml_member (map X M) Map}*
  H3 : {mapenv L Map ML}*
  H4 : {ml_member (map X M) (ml_cons (map n1 n2) Map)}
  ============================
   {mapenv (tl_cons X L) (ml_cons (map n1 n2) Map) (cross M ML)}

mapenv_extend < apply IH to H3.
Subgoal 2:

  Variables: NFVs, Map, PE, ML, L, M, X
  IH : forall NFVs Map PE, nabla x y, {mapenv NFVs Map PE}* ->
         {mapenv NFVs (ml_cons (map x y) Map) PE}
  H2 : {ml_member (map X M) Map}*
  H3 : {mapenv L Map ML}*
  H4 : {ml_member (map X M) (ml_cons (map n1 n2) Map)}
  H5 : {mapenv L (ml_cons (map n1 n2) Map) ML}
  ============================
   {mapenv (tl_cons X L) (ml_cons (map n1 n2) Map) (cross M ML)}

mapenv_extend < search.
Proof completed.

Abella < Theorem cc_extend_map : 
forall E E' Map FVs, nabla x y, {cc E E' Map FVs} ->
  {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}.


  ============================
   forall E E' Map FVs, nabla x y, {cc E E' Map FVs} ->
     {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}

cc_extend_map < induction on 1.


  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  ============================
   forall E E' Map FVs, nabla x y, {cc E E' Map FVs}@ ->
     {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}

cc_extend_map < intros.

  Variables: E, E', Map, FVs
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H1 : {cc E E' Map FVs}@
  ============================
   {cc E E' (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < case H1.
Subgoal 1:

  Variables: E, E', Map, FVs
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {ml_member (map E E') Map}*
  ============================
   {cc E E' (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 2 is:
 {cc (lnat N) (clnat N) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 3 is:
 {cc (abs M) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 4 is:
 {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < search.
Subgoal 2:

  Variables: E, E', Map, FVs, N
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  ============================
   {cc (lnat N) (clnat N) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 3 is:
 {cc (abs M) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 4 is:
 {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < search.
Subgoal 3:

  Variables: E, E', Map, FVs, NFVs, NMap, P, M, PE
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {fvars (abs M) FVs NFVs}*
  H3 : {mapenv NFVs Map PE}*
  H4 : {mapvar NFVs NMap}*
  H5 : {cc (M n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  ============================
   {cc (abs M) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 4 is:
 {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < apply fvars_extend to _ H2 with x = n1.
Subgoal 3:

  Variables: E, E', Map, FVs, NFVs, NMap, P, M, PE
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {fvars (abs M) FVs NFVs}*
  H3 : {mapenv NFVs Map PE}*
  H4 : {mapvar NFVs NMap}*
  H5 : {cc (M n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H6 : {fvars (abs M) (tl_cons n1 FVs) NFVs}
  ============================
   {cc (abs M) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 4 is:
 {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < apply mapenv_extend to H3 with x = n1, y = n2.
Subgoal 3:

  Variables: E, E', Map, FVs, NFVs, NMap, P, M, PE
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {fvars (abs M) FVs NFVs}*
  H3 : {mapenv NFVs Map PE}*
  H4 : {mapvar NFVs NMap}*
  H5 : {cc (M n1) (P n3 n2) (ml_cons (map n1 n2) (NMap n3)) (tl_cons n1 NFVs)}*
  H6 : {fvars (abs M) (tl_cons n1 FVs) NFVs}
  H7 : {mapenv NFVs (ml_cons (map n1 n2) Map) PE}
  ============================
   {cc (abs M) (cpair (cabs (x\clet (fst x) (y\clet (rst x) (xenv\P xenv y)))) PE) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

Subgoal 4 is:
 {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < search.
Subgoal 4:

  Variables: E, E', Map, FVs, CM2, M2, CM1, M1
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {cc M1 CM1 Map FVs}*
  H3 : {cc M2 CM2 Map FVs}*
  ============================
   {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < apply IH to H2.
Subgoal 4:

  Variables: E, E', Map, FVs, CM2, M2, CM1, M1
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {cc M1 CM1 Map FVs}*
  H3 : {cc M2 CM2 Map FVs}*
  H4 : {cc M1 CM1 (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}
  ============================
   {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < apply IH to H3.
Subgoal 4:

  Variables: E, E', Map, FVs, CM2, M2, CM1, M1
  IH : forall E E' Map FVs, nabla x y, {cc E E' Map FVs}* ->
         {cc E E' (ml_cons (map x y) Map) (tl_cons x FVs)}
  H2 : {cc M1 CM1 Map FVs}*
  H3 : {cc M2 CM2 Map FVs}*
  H4 : {cc M1 CM1 (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}
  H5 : {cc M2 CM2 (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}
  ============================
   {cc (app M1 M2) (cunpair CM1 (f\env\capp f (cross CM2 env))) (ml_cons (map n1 n2) Map) (tl_cons n1 FVs)}

cc_extend_map < search.
Proof completed.

Abella < Theorem base_eval_pres : 
forall E E', {of E nat_t} -> {cc E E' ml_nil tl_nil} -> (exists N,
  {eval E (lnat N)} /\ {evalcc E' (clnat N)}).


  ============================
   forall E E', {of E nat_t} -> {cc E E' ml_nil tl_nil} -> (exists N,
     {eval E (lnat N)} /\ {evalcc E' (clnat N)})

base_eval_pres < intros.

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert sctx' (of n1 nat_t :: nil).
Subgoal 1:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  ============================
   sctx' (of n1 nat_t :: nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert sctx' nil.
Subgoal 1:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' nil
  ============================
   sctx' (of n1 nat_t :: nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < apply sctx'_extend to H3 with x = n1, T = nat_t.
Subgoal 1:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' nil
  H4 : sctx' (of n1 nat_t :: nil)
  ============================
   sctx' (of n1 nat_t :: nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < search.

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert subst (sml_cons (smap n1 (lnat z)) sml_nil).
Subgoal 2:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  ============================
   subst (sml_cons (smap n1 (lnat z)) sml_nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert subst sml_nil.
Subgoal 2:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst sml_nil
  ============================
   subst (sml_cons (smap n1 (lnat z)) sml_nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert {tm (lnat z)}.
Subgoal 2:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst sml_nil
  H5 : {tm (lnat z)}
  ============================
   subst (sml_cons (smap n1 (lnat z)) sml_nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert {val (lnat z)}.
Subgoal 2:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst sml_nil
  H5 : {tm (lnat z)}
  H6 : {val (lnat z)}
  ============================
   subst (sml_cons (smap n1 (lnat z)) sml_nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < apply subst_extend to H4 H5 H6.
Subgoal 2:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst sml_nil
  H5 : {tm (lnat z)}
  H6 : {val (lnat z)}
  H7 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  ============================
   subst (sml_cons (smap n1 (lnat z)) sml_nil)

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < search.

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)).
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert csubst cml_nil.
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert {ctm unit}.
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert {cval unit}.
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  H7 : {cval unit}
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < apply csubst_extend to H5 H6 H7.
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  H7 : {cval unit}
  H8 : csubst (cml_cons (cmap n1 unit) cml_nil)
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert {ctm (clnat z)}.
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  H7 : {cval unit}
  H8 : csubst (cml_cons (cmap n1 unit) cml_nil)
  H9 : {ctm (clnat z)}
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert {cval (clnat z)}.
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  H7 : {cval unit}
  H8 : csubst (cml_cons (cmap n1 unit) cml_nil)
  H9 : {ctm (clnat z)}
  H10 : {cval (clnat z)}
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < apply csubst_extend to H8 H9 H10.
Subgoal 3:

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst cml_nil
  H6 : {ctm unit}
  H7 : {cval unit}
  H8 : csubst (cml_cons (cmap n1 unit) cml_nil)
  H9 : {ctm (clnat z)}
  H10 : {cval (clnat z)}
  H11 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n1 unit) cml_nil))
  ============================
   csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))

Subgoal is:
 exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < search.

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)).

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert vars_of_sctx nil tl_nil.

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert {mapvar tl_nil (x\ml_nil)}.

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert {of n1 nat_t |- of E nat_t}.

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < apply cc_extend_map to H2 with x = n1, y = n2.

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E.

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  H11 : app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < assert app_csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)) E' E'.

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  H11 : app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E
  H12 : app_csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)) E' E'
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < apply eval_pres to H3 H4 H5 H6 H7 H8 H9 H10 H11 H12.

  Variables: E, E'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  H11 : app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E
  H12 : app_csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)) E' E'
  H13 : sim nat_t E E'
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < case H13.

  Variables: E, E', V, V'
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  H11 : app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E
  H12 : app_csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)) E' E'
  H14 : {eval E V}
  H15 : {evalcc E' V'}
  H16 : equiv nat_t V V'
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < case H16.

  Variables: E, E', V, V', N
  H1 : {of E nat_t}
  H2 : {cc E E' ml_nil tl_nil}
  H3 : sctx' (of n1 nat_t :: nil)
  H4 : subst (sml_cons (smap n1 (lnat z)) sml_nil)
  H5 : csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H6 : subst_equiv' (of n1 nat_t :: nil) (sml_cons (smap n1 (lnat z)) sml_nil) (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil))
  H7 : vars_of_sctx nil tl_nil
  H8 : {mapvar tl_nil (x\ml_nil)}
  H9 : {of n1 nat_t |- of E nat_t}
  H10 : {cc E E' (ml_cons (map n1 n2) ml_nil) (tl_cons n1 tl_nil)}
  H11 : app_subst (sml_cons (smap n1 (lnat z)) sml_nil) E E
  H12 : app_csubst (cml_cons (cmap n2 (clnat z)) (cml_cons (cmap n3 unit) cml_nil)) E' E'
  H14 : {eval E (lnat N)}
  H15 : {evalcc E' (clnat N)}
  ============================
   exists N, {eval E (lnat N)} /\ {evalcc E' (clnat N)}

base_eval_pres < search.
Proof completed.

Abella < Goodbye.
