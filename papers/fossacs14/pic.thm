% Bisimilarity up-to techniques for pi-calculus.

% A specification of the late transition system for the pi calculus.
% This specification involves the bang constructor.

Kind name,action,proc type.

Type null         proc.
Type taup         proc -> proc.
Type plus, par    proc -> proc -> proc.
Type match, out   name -> name -> proc -> proc.
Type in           name -> (name -> proc) -> proc.
Type nu           (name -> proc) -> proc.
Type repl	  proc -> proc.

Type tau          action.
Type up, dn       name -> name -> action.

Type a, b		name.


Define one : proc -> action  -> proc  -> prop, oneb : proc -> (name -> action)  -> (name -> proc) -> prop by
% tau
  one  (taup P) tau P;

% free output
  one (out X Y P) (up X Y) P;

% sum
  one  (plus P Q) A R := one  P A R;
  one  (plus P Q) A R := one  Q A R;

% par
  one  (par P Q) A (par P1 Q) := one P A P1;
  one  (par P Q) A (par P Q1) := one Q A Q1;

% restriction
  one  (nu x\P x) A (nu x\Q x) := nabla x, one  (P x) A (Q x);

% close
  one (par P Q) tau (nu y\ par (M y) (N y)) := exists X, oneb P (dn X) M /\ oneb Q (up X) N;
  one (par P Q) tau (nu y\ par (M y) (N y)) := exists X, oneb P (up X) M /\ oneb Q (dn X) N;

% comm
  one (par P Q) tau (par (M Y) T) :=  exists X, oneb P (dn X) M /\ one Q (up X Y) T;
  one (par P Q) tau (par R (M Y)) :=  exists X, oneb Q (dn X) M /\ one P (up X Y) R;

% repl
  one (repl P) A (par (repl P) P1) := one P A P1;

% repl, further rules for auto-synchronization.
  one (repl P) tau (par (par P1 (M Y)) (repl P)) := exists X, one P (up X Y) P1 /\ oneb P (dn X) M;
  one (repl P) tau (par ((nu y\ par (N y) (M y))) (repl P)) := exists X, oneb P (up X) N /\ oneb P (dn X) M;

% bound input
  oneb (in X M) (dn X) M;

% sum
  oneb (plus P Q) A M := oneb P A M;
  oneb (plus P Q) A M := oneb Q A M;

% par
  oneb (par P Q) A (x\par (M x) Q) := oneb P A M;
  oneb (par P Q) A (x\par P (N x)) := oneb Q A N;

% restriction
  oneb (nu x\P x) A (y\ nu x\Q x y) := nabla x, oneb (P x) A (y\ Q x y);

% open
  oneb (nu x\M x) (up X) N := nabla y, one (M y) (up X y) (N y);

% repl
  oneb (repl P) A (x\ par (repl P) (M x)) := oneb P A M.


% Bisimilarity up-to techniques.
% The predicate bisim_up_to is parametrized by the up-to technique, that is the argument Upto.
% Intuitively: Upto P1 P2 Q1 Q2 means "in the co-inductive step, use P2 instead of P1 and Q2 instead of Q1."


CoDefine bisim_up_to : (proc -> proc -> proc -> proc -> prop) -> proc -> proc -> prop by
  bisim_up_to Upto P Q := (forall A P1, one P A P1 -> exists Q1, one Q A Q1 /\ exists P2 Q2, (Upto P1 P2 Q1 Q2) /\ bisim_up_to Upto P2 Q2) /\
   (forall X M, oneb P (dn X) M -> exists N, oneb Q (dn X) N /\ exists M2 N2, forall W, ((Upto (M W) (M2 W) (N W) (N2 W)) /\
     bisim_up_to Upto (M2 W) (N2 W))) /\
   (forall X M, oneb P (up X) M -> exists N, oneb Q (up X) N /\ exists M2 N2, nabla W, ((Upto (M W) (M2 W) (N W) (N2 W)) /\
     bisim_up_to Upto (M2 W) (N2 W))) /\
   (forall A Q1, one Q A Q1 -> exists P1, one P A P1 /\ exists P2 Q2, (Upto P1 P2 Q1 Q2) /\ bisim_up_to Upto P2 Q2) /\
   (forall X N, oneb Q (dn X) N -> exists M, oneb P (dn X) M /\ exists M2 N2, (forall W, (Upto (M W) (M2 W) (N W) (N2 W)) /\ 
      bisim_up_to Upto (M2 W) (N2 W))) /\ 
   (forall X N, oneb Q (up X) N -> exists M, oneb P (up X) M /\ exists M2 N2, (nabla W, (Upto (M W) (M2 W) (N W) (N2 W)) /\
     bisim_up_to Upto (M2 W) (N2 W))).


% An alternative definition of bisimilarity which is based on a "vacuous" up-to technique.

Define refl_t : proc -> proc -> proc -> proc -> prop by
  refl_t P P Q Q.

CoDefine bisimr : proc -> proc -> prop by bisimr P Q := bisim_up_to refl_t P Q.

% It is proven in:
%
% Alwen Tiu, Dale Miller. Proof search specifications of bisimulation and modal logics for the calculus. 
% ACM Transactions on Computational Logic (TOCL) 2010.
%
% that this definition corresponds to open bisimilarity.


% As Abella treats equality by means of unification, reasoning with structured equality as in:
% P = (Q R).
% would not naturally rewrite occurrences of P with the complex (Q R). (as it would if Abella permorfed syntctical rewriting)	
% We therefore need the following lemma for it.

Define equally_structured : (proc -> proc -> prop) -> prop by
  equally_structured Pred := forall X1 X2 Y1 Y2, Pred X1 X2 -> Y1 = X1 -> Y2 = X2 -> Pred Y1 Y2.

Theorem equality_for_structured_refl : equally_structured (bisim_up_to refl_t). 
unfold. intros. case H2. case H3. search.


% Here below, we rephrase the theorems about reflexivity, symmetry and transitivity of bisimilarity, in order to lift them to (bisim_up_to refl_t).

Theorem bisim_refl : forall P, bisim_up_to refl_t P P. 
coinduction. intros. unfold.
  intros. apply CH with P = P1. search.
  intros. exists M. split. search.
    exists M. exists M.							% specific of the reflexivityTechnique technique, only difference from the same proof for bisim.
    intros. apply CH with P = M W. search.
  intros. exists M. split. search.
    exists M. exists M.							% specific of the reflexivityTechnique technique, only difference from the same proof for bisim.
    intros. apply CH with P = M n1. search.
  intros. apply CH with P = Q1. search.
  intros. exists N. split. search.
    exists N. exists N.							% specific of the reflexivityTechnique technique, only difference from the same proof for bisim.
    intros. apply CH with P = N W. search.
  intros. exists N. split. search.
    exists N. exists N.							% specific of the reflexivityTechnique technique, only difference from the same proof for bisim.
    intros. apply CH with P = N n1. search.

Theorem bisim_sym : forall P Q, bisim_up_to refl_t P Q -> bisim_up_to refl_t Q P.
coinduction. intros. case H1. unfold.
  intros. apply H5 to H8. exists P2. split. search. exists P1. exists P2. split. search. case H10. backchain CH.
  intros. apply H6 to H8. exists M1. split. search. exists M. exists M1. intros. split. search. 
	apply H10 with W = W. case H11. apply equality_for_structured_refl. case H15. apply H16 to H12 H14 H13. backchain CH.
  intros. apply H7 to H8. exists M1. split. search. exists M. exists M1. intros. split. search. case H10. backchain CH.
  intros. apply H2 to H8. exists Q2. split. search. exists Q2. exists Q1. split. search. case H10. backchain CH.
  intros. apply H3 to H8. exists N1. split. search. exists N1. exists N. intros. split. search. 
	apply H10 with W = W. case H11. apply equality_for_structured_refl. case H15. apply H16 to H12 H14 H13. backchain CH.
  intros. apply H4 to H8. exists N1. split. search. exists N1. exists N. intros. split. search. case H10. backchain CH.


Theorem bisim_trans : forall P Q R, bisim_up_to refl_t P Q -> bisim_up_to refl_t Q R -> bisim_up_to refl_t P R. 
coinduction. intros. case H1. case H2. unfold. 
  intros. apply H3 to H15. apply H9 to H16. case H17. case H20. exists Q4. split. search. exists P3. exists Q4. split. search. backchain CH.
  intros. apply H4 to H15. apply H10 to H16. exists N1. split. search. exists M. exists N1. intros. split. search. 
	apply H17 with W = W. apply H19 with W = W. case H20. case H22. apply equality_for_structured_refl. case H28. apply H29 to H21 H25 H24. apply H29 to H23 H27 H26. backchain CH.
  intros. apply H5 to H15. apply H11 to H16. exists N1. split. search. exists M. exists N1. intros. split. search. case H17. case H20. backchain CH.
  intros. apply H12 to H15. apply H6 to H16. case H17. case H20. exists P4. split. search. exists P4. exists Q3. split. search. backchain CH.
  intros. apply H13 to H15. apply H7 to H16. exists M1. split. search. exists M1. exists N. intros. split. search. 
	apply H17 with W = W. apply H19 with W = W. case H20. case H22. apply equality_for_structured_refl. case H28. apply H29 to H21 H25 H24. apply H29 to H23 H27 H26. backchain CH.
  intros. apply H14 to H15. apply H8 to H16. exists M1. split. search. exists M1. exists N. intros. split. search. case H17. case H20. backchain CH.



% Bisimilarity up-to Bisimilarity.

Define bisim_t : proc -> proc -> proc -> proc -> prop by
  bisim_t P1 P2 Q1 Q2 := bisim_up_to refl_t P1 P2 /\ bisim_up_to refl_t Q1 Q2.


% Abstract definitions for soundness for the various proof techniques. 
% They are to be instantiated later at any convenience.

Define is_sound : (proc -> proc -> proc -> proc -> prop) -> prop by
  is_sound Upto := forall P Q, bisim_up_to Upto P Q -> bisim_up_to refl_t P Q.

Define is_sound_fst : (proc -> proc -> proc -> proc -> prop) -> prop by
  is_sound_fst Upto := forall P Q,
    (exists R S, bisim_up_to refl_t P R /\ bisim_up_to Upto R S /\ bisim_up_to refl_t S Q)
    -> bisim_up_to refl_t P Q.

Define is_sound_snd : (proc -> proc -> proc -> proc -> prop) -> prop by
  is_sound_snd Upto := forall P Q, bisim_up_to Upto P Q ->
    exists R S, bisim_up_to refl_t P R /\ bisim_up_to Upto R S /\ bisim_up_to refl_t S Q.

% Remark: 
%	the soundness of all the techniques that follow but up-to Context, are proved by two lemmas first and second. 
%	the up-to Context technique can be proved directly, i.e. with lemma soundness_upToTechnique.
%	only soundness_upToTechnique_first depends on the particular up-to technique and at a specific point of the proof.
%	soundness_upToTechnique_second works for all reflexive equivalences: proofs are copy/pasted.
%	soundness_upToTechnique combines the first and second lemma with no intervention from the up-to technique nor even the equivalence relation: proofs are copy/pasted.


% Soundness of Bisimilarity up-to Bisimilarity.

Theorem bisim_sound_fst : is_sound_fst bisim_t.
unfold. coinduction. intros. case H1. unfold.

% Remark:
% unfold, open the 6 cases of bisimilarity:
% - plain transitions from P.
% - dn transitions from P (bound input).
% - up transitions from P (bound output).
% - plain transitions from Q
% - dn transitions from Q (bound input).
% - up transitions from Q (bound output).

% Every case is divided in two independent subproofs. 
% - given the step from P, we need to find a suitable step from Q.
% - prove that the derivatives are again in the relation. 
%	the particular up-to technique will play a role in a specific and localized point of this sub-proof.
%	i.e. the proof can be packaged as a procedure that can be copy/pasted/adjusted in a well-defined point of the proof.

% plain transitions from P.
%   searching for the suitable step from Q. 
intros.	case H2. apply H6 to H5. case H3. apply H15 to H12. case H4. apply H24 to H21.
exists Q5. 
split. search.
exists P1. exists Q5.	
split. search. 

% applying the information from the reflexive technique refl_t.
case H13.				
case H31.

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Bisimilarity.
  apply bisim_trans to H14 H33.
  apply bisim_sym to H34.
  apply bisim_trans to H36 H32.
backchain CH.

% dn transitions from P.
%   searching for the suitable step from Q. 
intros.	case H2. apply H7 to H5. case H3. apply H15 to H12. case H4. apply H23 to H20.
exists N4.
split. search.
exists M. exists N4.
intros.					
split. search.

% This next code is a preamble adjustment because of the difference that HOAS necessarily introduces.
% from here:
apply H13 with W = W. apply H21 with W = W. apply H29 with W = W.		% to unwrap universally quantified definitions.

% applying the information from the reflexive technique refl_t, but we need structured equality. 
case H30. case H34.								
apply equality_for_structured_refl. case H40. 
apply H41 to H31 H37 H36. apply H41 to H35 H39 H38.				
% to here.

%  proving derivatives are related.
case H32. 				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Bisimilarity.
  apply bisim_trans to H42 H44.
  apply bisim_sym to H45.
  apply bisim_trans to H47 H43.
backchain CH.

% up transitions from P.
%   searching for the suitable step from Q. 
intros. case H2. apply H8 to H5. case H3. apply H17 to H12. case H4. apply H26 to H21.
exists N4.
split. search.
exists M. exists N4.
intros.
split. search.

% applying the information from the reflexive technique refl_t.
case H13.				
case H31.				

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Bisimilarity.
  apply bisim_trans to H14 H33.
  apply bisim_sym to H34.
  apply bisim_trans to H36 H32.
backchain CH.

% plain transitions from Q.
%   searching for the suitable step from P. 
intros.	 case H4. apply H9 to H5. case H3. apply H18 to H12. case H2. apply H27 to H21.
exists P5.
split. search.
exists P5. exists Q1.
split. search.

% applying the information from the reflexive technique refl_t.
case H13.
case H31.

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Bisimilarity.
% Because it is the symmetric case, we need only to switch H14/H32 in the proof code above.
  apply bisim_trans to H32 H33.
  apply bisim_sym to H34.
  apply bisim_trans to H36 H14.
backchain CH.

% dn transitions from Q.
%   searching for the suitable step from P. 
intros.	case H4. apply H10 to H5. case H3. apply H18 to H12. case H2. apply H26 to H20.
exists M4.
split. search.
exists M4. exists N.
intros.	
split. search.

% This next code is a preamble adjustment because of the difference that HOAS necessarily introduces.
% from here:
apply H13 with W = W. apply H21 with W = W. apply H29 with W = W.		% to unwrap universally quantified definitions.

% applying the information from the reflexive technique refl_t, but we need structured equality. 
case H30. case H34.								
apply equality_for_structured_refl. case H40. 
apply H41 to H31 H37 H36. apply H41 to H35 H39 H38.				
% to here.

%  proving derivatives are related.
case H32.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Bisimilarity.
  apply bisim_trans to H43 H44.
  apply bisim_sym to H45.
  apply bisim_trans to H47 H42.
backchain CH.

% up transitions from Q.
%   searching for the suitable step from P. 
intros.	case H4. apply H11 to H5. case H3. apply H20 to H12. case H2. apply H29 to H21.   
exists M4.
split. search.
exists M4. exists N.
intros.
split. search.

% applying the information from the reflexive technique refl_t.
case H13.
case H31.

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Bisimilarity.
  apply bisim_trans to H32 H33.
  apply bisim_sym to H34.
  apply bisim_trans to H36 H14.
backchain CH.


Theorem bisim_sound_snd : is_sound_snd bisim_t.
unfold.
intros.
apply bisim_refl with P = P.
apply bisim_refl with P = Q.
exists P.
exists Q.
search.

Theorem bisim_sound : is_sound bisim_t.
unfold.
intros.
apply bisim_sound_snd.
case H2.
apply H3 to H1.
apply bisim_sound_fst.
case H7.
backchain H8.


% Soundness of Bisimilarity up-to reflexivity and transitivity closure. 

Define transitivity_t : proc -> proc -> proc -> proc -> prop by
  transitivity_t P1 P3 Q1 Q3 := 
   (P1 = P3 /\ Q1 = Q3) \/
   exists P2 Q2, (bisim_up_to transitivity_t P1 P2) /\ (bisim_up_to transitivity_t  P2 P3) /\ (bisim_up_to transitivity_t Q1 Q2) /\ (bisim_up_to transitivity_t  Q2 Q3).

% Here below are the lemmas we need for the task. 

Theorem bisimUpToTrans_sym : forall P Q, bisim_up_to transitivity_t P Q -> bisim_up_to transitivity_t Q P.skip.
Theorem bisimUpToTrans_trans : forall P Q R, bisim_up_to transitivity_t P Q -> bisim_up_to transitivity_t Q R -> bisim_up_to transitivity_t P R. skip. 

Define equally_structured_1 : (proc -> proc -> prop) -> prop by
  equally_structured_1 Pred := forall X1 X2 Y, Pred X1 X2 -> X2 = Y -> Pred X1 Y.
Define equally_structured_2 : (proc -> proc -> prop) -> prop by
  equally_structured_2 Pred := forall X1 X2 Y, Pred X1 X2 -> X1 = Y -> Pred Y X2.

Theorem equally_structured_1_refl : equally_structured_1 (bisim_up_to refl_t). skip.
Theorem equally_structured_2_refl : equally_structured_2 (bisim_up_to refl_t). skip. 


Theorem transitivity_sound_fst : is_sound_fst transitivity_t.
% Remark: as we pointed out above, this proof is nearly copy/pasted until from the soundness of Bisimilarity up-to Bisimilarity.
% the specific code for Bisimilarity up-to Transitivity is needed in a precise and localized point. 

unfold. coinduction. intros. case H1. unfold.

% plain transitions from P.
%   searching for the suitable step from Q. 
intros.	case H2. apply H6 to H5. case H3. apply H15 to H12. case H4. apply H24 to H21.
exists Q5. 
split. search.
exists P1. exists Q5.	
split. search. 

% applying the information from the reflexive technique refl_t.
case H13.				
case H31.

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Transitivity.
case H33.
% reflexivity case.
backchain CH.
% transitive case.
  apply bisimUpToTrans_trans to H34 H35.
  apply bisimUpToTrans_sym to H37.
  apply bisimUpToTrans_trans to H23 H39.
  apply bisimUpToTrans_sym to H36.
  apply bisimUpToTrans_trans to H40 H41.
  apply bisimUpToTrans_trans to H38 H42.
backchain CH.

% dn transitions from P.
%   searching for the suitable step from Q. 
intros.	case H2. apply H7 to H5. case H3. apply H15 to H12. case H4. apply H23 to H20.
exists N4.
split. search.
exists M. exists N4.
intros.					
split. search.

% This next code is a preamble adjustment because of the difference that HOAS necessarily introduces.
% from here:
apply H13 with W = W. apply H21 with W = W. apply H29 with W = W.		% to unwrap universally quantified definitions.

% applying the information from the reflexive technique refl_t, but we need structured equality. 
case H30. case H34.								
apply equality_for_structured_refl. case H40. 
apply H41 to H31 H37 H36. apply H41 to H35 H39 H38.				
% to here.

%  proving derivatives are related.
case H32. 				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Transitivity.
case H44.
% reflexivity case.
apply equally_structured_1_refl. case H47. 
apply H48 to H42 H45.
apply equally_structured_2_refl. case H50. 
apply H51 to H43 H46.
backchain CH.
% transitive case.
  apply bisimUpToTrans_trans to H45 H46.
  apply bisimUpToTrans_sym to H48.
  apply bisimUpToTrans_trans to H33 H50.
  apply bisimUpToTrans_sym to H47.
  apply bisimUpToTrans_trans to H51 H52.
  apply bisimUpToTrans_trans to H49 H53.
backchain CH.

% up transitions from P.
%   searching for the suitable step from Q. 
intros. case H2. apply H8 to H5. case H3. apply H17 to H12. case H4. apply H26 to H21.
exists N4.
split. search.
exists M. exists N4.
intros.
split. search.

% applying the information from the reflexive technique refl_t.
case H13.				
case H31.				

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Transitivity.
case H33.
% reflexivity case.
backchain CH.
% transitive case.
  apply bisimUpToTrans_trans to H34 H35.
  apply bisimUpToTrans_sym to H37.
  apply bisimUpToTrans_trans to H23 H39.
  apply bisimUpToTrans_sym to H36.
  apply bisimUpToTrans_trans to H40 H41.
  apply bisimUpToTrans_trans to H38 H42.
backchain CH.


% plain transitions from Q.
%   searching for the suitable step from P. 
intros.	 case H4. apply H9 to H5. case H3. apply H18 to H12. case H2. apply H27 to H21.
exists P5.
split. search.
exists P5. exists Q1.
split. search.

% applying the information from the reflexive technique refl_t.
case H13.
case H31.

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Transitivity.
case H33.
% reflexivity case.
backchain CH.
% transitive case.
  apply bisimUpToTrans_trans to H34 H35.
  apply bisimUpToTrans_sym to H37.
  apply bisimUpToTrans_trans to H23 H39.
  apply bisimUpToTrans_sym to H36.
  apply bisimUpToTrans_trans to H40 H41.
  apply bisimUpToTrans_trans to H38 H42.
backchain CH.

% dn transitions from Q.
%   searching for the suitable step from P. 
intros.	case H4. apply H10 to H5. case H3. apply H18 to H12. case H2. apply H26 to H20.
exists M4.
split. search.
exists M4. exists N.
intros.	
split. search.

% This next code is a preamble adjustment because of the difference that HOAS necessarily introduces.
% from here:
apply H13 with W = W. apply H21 with W = W. apply H29 with W = W.		% to unwrap universally quantified definitions.

% applying the information from the reflexive technique refl_t, but we need structured equality. 
case H30. case H34.								
apply equality_for_structured_refl. case H40. 
apply H41 to H31 H37 H36. apply H41 to H35 H39 H38.				
% to here.

%  proving derivatives are related.
case H32.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Transitivity.
case H44.
% reflexivity case.
apply equally_structured_2_refl. case H47. 
apply H48 to H42 H46.
apply equally_structured_1_refl. case H50. 
apply H51 to H43 H45.
backchain CH.
% transitive case.
  apply bisimUpToTrans_trans to H45 H46.
  apply bisimUpToTrans_sym to H48.
  apply bisimUpToTrans_trans to H33 H50.
  apply bisimUpToTrans_sym to H47.
  apply bisimUpToTrans_trans to H51 H52.
  apply bisimUpToTrans_trans to H49 H53.
backchain CH.

% up transitions from Q.
%   searching for the suitable step from P. 
intros.	case H4. apply H11 to H5. case H3. apply H20 to H12. case H2. apply H29 to H21.   
exists M4.
split. search.
exists M4. exists N.
intros.
split. search.

% applying the information from the reflexive technique refl_t.
case H13.
case H31.

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Transitivity.
case H33.
% reflexivity case.
backchain CH.
% transitive case.
  apply bisimUpToTrans_trans to H34 H35.
  apply bisimUpToTrans_sym to H37.
  apply bisimUpToTrans_trans to H23 H39.
  apply bisimUpToTrans_sym to H36.
  apply bisimUpToTrans_trans to H40 H41.
  apply bisimUpToTrans_trans to H38 H42.
backchain CH.

Theorem transitivity_sound_snd : is_sound_snd transitivity_t.
unfold.
intros.
apply bisim_refl with P = P.
apply bisim_refl with P = Q.
exists P.
exists Q.
search.


Theorem transitivity_sound : is_sound transitivity_t.
unfold.
intros.
apply transitivity_sound_snd.
case H2.
apply H3 to H1.
apply transitivity_sound_fst.
case H7.
backchain H8.

% Soundness of Bisimilarity up-to Context

Define context_t : proc -> proc -> proc -> proc -> prop by
  context_t P1 P2 Q1 Q2 := (P1 = P2 /\ Q1 = Q2) \/ (exists R, P1 = (par P2 R) /\ Q1 = (par Q2 R)).

Theorem bisimUpToContext_cong : forall P Q R, bisim_up_to context_t P Q -> bisim_up_to context_t (par P R) (par Q R).skip.

Theorem equality_for_structured_cont : equally_structured (bisim_up_to context_t). 
unfold. intros. case H2. case H3. search.

Theorem context_sound : is_sound context_t.
unfold. coinduction. intros. case H1. unfold.

% plain transitions from P. 
intros. apply H2 to H8. 
exists Q2. split. search. exists P1. exists Q2. split. search. 
case H10. case H12. 
% - inside no bigger context
     backchain CH.
% - inside a bigger context
     apply bisimUpToContext_cong to H11 with R = R.
     backchain CH.

% dn transitions from P. 
intros. apply H3 to H8.
exists N. split. search. exists M. exists N. intros. split. search. 

% This next code is a preamble adjustment because of the difference that HOAS necessarily introduces.
apply H10 with W = W.
case H11. case H13. 
% - inside no bigger context
     apply equality_for_structured_cont. case H16. 
     apply H17 to H12 H14 H15. 	
     backchain CH.
% - inside a bigger context
     apply bisimUpToContext_cong to H12 with R = R.
     apply equality_for_structured_cont. case H17. 
     apply H18 to H16 H14 H15. 	
     backchain CH.

% up transitions from P. 
intros. apply H4 to H8. 
exists N. split. search. exists M. exists N. intros. split. search. 
case H10. case H12. 
% - inside no bigger context
     backchain CH.
% - inside a bigger context
     apply bisimUpToContext_cong to H11 with R = R n1.
     backchain CH.

% plain transitions from Q. 
intros. apply H5 to H8. 
exists P2. split. search. exists P2. exists Q1. split. search. 
case H10. case H12. 
% - inside no bigger context
     backchain CH.
% - inside a bigger context
     apply bisimUpToContext_cong to H11 with R = R.
     backchain CH.

% dn transitions from P. 
intros. apply H6 to H8.
exists M. split. search. exists M. exists N. intros. split. search. 

% This next code is a preamble adjustment because of the difference that HOAS necessarily introduces.
apply H10 with W = W.
case H11. case H13. 
% - inside no bigger context
     apply equality_for_structured_cont. case H16. 
     apply H17 to H12 H14 H15. 	
     backchain CH.
% - inside a bigger context
     apply bisimUpToContext_cong to H12 with R = R.
     apply equality_for_structured_cont. case H17. 
     apply H18 to H16 H14 H15. 	
     backchain CH.

% up transitions from Q. 
intros. apply H7 to H8. 
exists M. split. search. exists M. exists N. intros. split. search. 
case H10. case H12. 
% - inside no bigger context
     backchain CH.
% - inside a bigger context
     apply bisimUpToContext_cong to H11 with R = R n1.
     backchain CH.


% Soundness of Bisimilarity up-to Bisimilarity and Context.

Define bisim_context_t : proc -> proc -> proc -> proc -> prop by
        bisim_context_t P1 P3 Q1 Q3 := bisim_t P1 P3 Q1 Q3 \/ (exists P2 Q2, bisim_t P1 P2 Q1 Q2
					 /\ (exists R, P2 = (par P3 R) /\ Q2 = (par Q3 R))).

Theorem bisimUpToBisimAndContext_cong : forall P Q R, bisim_up_to bisim_context_t P Q -> bisim_up_to bisim_context_t (par P R) (par Q R).skip.
% -- SKIPPED -- problem: same problems as for bisimUpToTrans_trans.


Theorem bisim_context_sound_fst : is_sound_fst bisim_context_t.
unfold. coinduction. intros. case H1. unfold.

% plain transitions from P.
%   searching for the suitable step from Q. 
intros.	case H2. apply H6 to H5. case H3. apply H15 to H12. case H4. apply H24 to H21.
exists Q5. 
split. search.
exists P1. exists Q5.	
split. search. 

% applying the information from the reflexive technique refl_t.
case H13.				
case H31.

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
case H33.
% Next code is specific of Bisimilarity up-to Bisimilarity and Context (2 cases)
% - inside no bigger context
  case H34.				% unfold bisim_t 
  apply bisim_trans to H14 H35.		% not copy paste. but easily adjusted from the proof schema. 
  apply bisim_sym to H36.
  apply bisim_trans to H38 H32.
  backchain CH.
% - inside a bigger context
  case H34.				% unfold bisim_t 
  apply bisim_trans to H14 H35.		% not copy paste. but easily adjusted from the proof schema. 
  apply bisim_sym to H36.
  apply bisim_trans to H38 H32.
  apply bisimUpToBisimAndContext_cong to H23 with R = R1.
backchain CH.   

% dn transitions from P.
%   searching for the suitable step from Q. 
intros.	case H2. apply H7 to H5. case H3. apply H15 to H12. case H4. apply H23 to H20.
exists N4.
split. search.
exists M. exists N4.
intros.					
split. search.

% This next code is a preamble adjustment because of the difference that HOAS necessarily introduces.
% from here:
apply H13 with W = W. apply H21 with W = W. apply H29 with W = W.		% to unwrap universally quantified definitions.

% applying the information from the reflexive technique refl_t, but we need structured equality. 
case H30. case H34.								
apply equality_for_structured_refl. case H40. 
apply H41 to H31 H37 H36. apply H41 to H35 H39 H38.				
% to here.

%  proving derivatives are related.
case H32. 				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
case H44.				
% Next code is specific of Bisimilarity up-to Bisimilarity and Context (2 cases)
% - inside no bigger context
  case H45.				% unfold bisim_t 
  apply bisim_trans to H42 H46.		% not copy paste. but easily adjusted from the proof schema.
  apply bisim_sym to H47.
  apply bisim_trans to H49 H43.
  backchain CH.
% - inside a bigger context
  case H45.				% unfold bisim_t 
  apply bisim_trans to H42 H46.		% not copy paste. but easily adjusted from the proof schema.
  apply bisim_sym to H47.
  apply bisim_trans to H49 H43.
  apply bisimUpToBisimAndContext_cong to H33 with R = R1.
backchain CH.

% up transitions from P.
%   searching for the suitable step from Q. 
intros. case H2. apply H8 to H5. case H3. apply H17 to H12. case H4. apply H26 to H21.
exists N4.
split. search.
exists M. exists N4.
intros.
split. search.

% applying the information from the reflexive technique refl_t.
case H13.				
case H31.				

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
case H33.
% Next code is specific of Bisimilarity up-to Bisimilarity and Context (2 cases)
% - inside no bigger context
  case H34.				% unfold bisim_t 
  apply bisim_trans to H14 H35.		% not copy paste. but easily adjusted from the proof schema.
  apply bisim_sym to H36.
  apply bisim_trans to H38 H32.
  backchain CH.
% - inside a bigger context
  case H34.				% unfold bisim_t 
  apply bisim_trans to H14 H35.		% not copy paste. but easily adjusted from the proof schema.
  apply bisim_sym to H36.
  apply bisim_trans to H38 H32.
  apply bisimUpToBisimAndContext_cong to H23 with R = (R1 n1).
backchain CH.

% plain transitions from Q.
%   searching for the suitable step from P. 
intros.	 case H4. apply H9 to H5. case H3. apply H18 to H12. case H2. apply H27 to H21.
exists P5.
split. search.
exists P5. exists Q1.
split. search.

% applying the information from the reflexive technique refl_t.
case H13.
case H31.

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
case H33.
% Next code is specific of Bisimilarity up-to Bisimilarity and Context (2 cases)
% - inside no bigger context
  case H34.				% unfold bisim_t 
  apply bisim_trans to H32 H35.		% not copy paste. but easily adjusted from the proof schema.
  apply bisim_sym to H36.
  apply bisim_trans to H38 H14.
  backchain CH.
% - inside a bigger context
  case H34.				% unfold bisim_t 
  apply bisim_trans to H32 H35.		% not copy paste. but easily adjusted from the proof schema.
  apply bisim_sym to H36.
  apply bisim_trans to H38 H14.
  apply bisimUpToBisimAndContext_cong to H23 with R = R1.
backchain CH.

% dn transitions from Q.
%   searching for the suitable step from P. 
intros.	case H4. apply H10 to H5. case H3. apply H18 to H12. case H2. apply H26 to H20.
exists M4.
split. search.
exists M4. exists N.
intros.	
split. search.

% This next code is a preamble adjustment because of the difference that HOAS necessarily introduces.
% from here:
apply H13 with W = W. apply H21 with W = W. apply H29 with W = W.		% to unwrap universally quantified definitions.

% applying the information from the reflexive technique refl_t, but we need structured equality. 
case H30. case H34.								
apply equality_for_structured_refl. case H40. 
apply H41 to H31 H37 H36. apply H41 to H35 H39 H38.				
% to here.

%  proving derivatives are related.
case H32.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
case H44.				
% Next code is specific of Bisimilarity up-to Bisimilarity and Context (2 cases)
% - inside no bigger context
  case H45.				% unfold bisim_t 
  apply bisim_trans to H43 H46.		% not copy paste. but easily adjusted from the proof schema.
  apply bisim_sym to H47.
  apply bisim_trans to H49 H42.
  backchain CH.
% - inside a bigger context
  case H45.				% unfold bisim_t 
  apply bisim_trans to H43 H46.		% not copy paste. but easily adjusted from the proof schema.
  apply bisim_sym to H47.
  apply bisim_trans to H49 H42.
  apply bisimUpToBisimAndContext_cong to H33 with R = R1.
backchain CH.

% up transitions from Q.
%   searching for the suitable step from P. 
intros.	case H4. apply H11 to H5. case H3. apply H20 to H12. case H2. apply H29 to H21.   
exists M4.
split. search.
exists M4. exists N.
intros.
split. search.

% applying the information from the reflexive technique refl_t.
case H13.
case H31.

%  proving derivatives are related.
case H22.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
case H33.
% Next code is specific of Bisimilarity up-to Bisimilarity and Context (2 cases)
% - inside no bigger context
  case H34.				% unfold bisim_t 
  apply bisim_trans to H32 H35.		% not copy paste. but easily adjusted from the proof schema.
  apply bisim_sym to H36.
  apply bisim_trans to H38 H14.
  backchain CH.
% - inside a bigger context
  case H34.				% unfold bisim_t 
  apply bisim_trans to H32 H35.		% not copy paste. but easily adjusted from the proof schema.
  apply bisim_sym to H36.
  apply bisim_trans to H38 H14.
  apply bisimUpToBisimAndContext_cong to H23 with R = (R1 n1).
backchain CH.

Theorem bisim_context_sound_snd : is_sound_snd bisim_context_t.
unfold.
intros.                                 
apply bisim_refl with P = P.
apply bisim_refl with P = Q.
exists P.
exists Q.
search.

Theorem bisim_context_sound : is_sound bisim_context_t.
unfold.
intros.
apply bisim_context_sound_snd.
case H2.
apply H3 to H1.
apply bisim_context_sound_fst.
case H7.
backchain H8.


% Characterization theorems for the soundness of up to techniques: 
%
%	Soundness of up to bisimilarity holds iff bisimilarity up to bisimilarity is an equivalence.	
%	Soundness of up to reflexivity and transitivity holds iff bisim up to reflexivity and transitivity is an equivalence.	
%	If bisim is a substitutive, then the soundness of up to context technique holds iff bisim up to context is a substitutive.
%	If bisim is a congruence, then the soundness of up to bisimilarity and context technique holds iff bisim up to bisimilarity and context is substitutive.
%

Define upTo1ImpliesUpTo2 : (proc -> proc -> proc -> proc -> prop) -> (proc -> proc -> proc -> proc -> prop) -> prop by
   upTo1ImpliesUpTo2 Upto1 Upto2 := forall P1 P2 Q1 Q2, Upto1 P1 P2 Q1 Q2 -> Upto2 P1 P2 Q1 Q2.

Define bisim1ImpliesBisim2 : (proc -> proc -> proc -> proc -> prop) -> (proc -> proc -> proc -> proc -> prop) -> prop by
%   bisim1ImpliesBisim2 Upto1 Upto2 := upTo1ImpliesUpTo2 Upto1 Upto2 -> (forall P Q, bisim_up_to Upto1 P Q -> bisim_up_to Upto2 P Q).
    bisim1ImpliesBisim2 Upto1 Upto2 := forall P Q, upTo1ImpliesUpTo2 Upto1 Upto2 -> bisim_up_to Upto1 P Q -> bisim_up_to Upto2 P Q.

% With the first (more natural definition, we have CH : upTo1ImpliesUpTo2 refl_t context_t -> (forall P Q, bisim_up_to refl_t P Q -> bisim_up_to context_t P Q +)
% that does not unify with the goal bisim_up_to context_t P3 Q3.
% We cannot do coinduction only on the subformula that starts from (forall P Q, ...) because the first "intros" introduce everything until bisim_up_to context_t P Q.

% Remarks:
% 	For these theorems, the same proof is copy/pasted. I.e., 
% 	Therefore, it is sufficient to prove just that the up-to technique predicate implies the other, with upTo1ImpliesUpTo2.
% 	This theorem should be proved in Second Order Abella, because it works for every Upto1 Upto2.
% 	We need it only to prove that the bisim up to is a refinement of bisim. 
%	However, it can be used for instance to show that bisimBK is a refinement of bisimK. (provided that you prove upTo1ImpliesUpTo2 context_t bisim_context_t)

Theorem bisim_implies_bisimB : bisim1ImpliesBisim2 refl_t bisim_t.
unfold. coinduction. intros. unfold. 

	intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
	% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H5 to H3. exists N. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H6 to H3. exists N. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H7 to H3. exists P2. split. search. exists P3. exists Q3. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H8 to H3. exists M. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H9 to H3. exists M. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 



Theorem bisim_implies_bisimT : bisim1ImpliesBisim2 refl_t transitivity_t.
unfold. coinduction. intros. unfold. 

	intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
	% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H5 to H3. exists N. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H6 to H3. exists N. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H7 to H3. exists P2. split. search. exists P3. exists Q3. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H8 to H3. exists M. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H9 to H3. exists M. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 

Theorem bisim_implies_bisimK : bisim1ImpliesBisim2 refl_t context_t.
unfold. coinduction. intros. unfold. 

	intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
	% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H5 to H3. exists N. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H6 to H3. exists N. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H7 to H3. exists P2. split. search. exists P3. exists Q3. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H8 to H3. exists M. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H9 to H3. exists M. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 

Theorem bisim_implies_bisimBK : bisim1ImpliesBisim2 refl_t bisim_context_t.
unfold. coinduction. intros. unfold. 

	intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
	% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H5 to H3. exists N. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H6 to H3. exists N. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H7 to H3. exists P2. split. search. exists P3. exists Q3. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H8 to H3. exists M. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H9 to H3. exists M. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 

Theorem bisimB_implies_bisimBK : bisim1ImpliesBisim2 bisim_t bisim_context_t.
unfold. coinduction. intros. unfold. 

	intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
	% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H5 to H3. exists N. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H6 to H3. exists N. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H7 to H3. exists P2. split. search. exists P3. exists Q3. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H8 to H3. exists M. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H9 to H3. exists M. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 

Theorem bisimK_implies_bisimBK : bisim1ImpliesBisim2 context_t bisim_context_t.
unfold. coinduction. intros. unfold. 

	intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
	% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H5 to H3. exists N. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H6 to H3. exists N. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H7 to H3. exists P2. split. search. exists P3. exists Q3. split. 
	case H1. backchain H13. backchain CH. 

	intros. case H2. apply H8 to H3. exists M. split. search. exists M2. exists N2. intros. apply H11 with W = W. split. 
	case H1. backchain H14. backchain CH. 

	intros. case H2. apply H9 to H3. exists M. split. search. exists M2. exists N2. intros. split. 
	case H1. backchain H13. backchain CH. 


% We prove that the reflexivity technique is a special case of the techniques here considered.
% This is sufficient to show that bisimilarity is refined by the bisimilarity up to the techniques here considered. 
% The following proofs necessary depends on the peculiarities of the technique at hand.
% But at least, we can isolated and confined here the core of it.
% And the user needs not to use the coinduction side of the proof, which is handled automatic from the proof above. 

Theorem upToBisim_implie_upToBisimB : upTo1ImpliesUpTo2 refl_t bisim_t.
unfold. intros. case H1. unfold. backchain bisim_refl. backchain bisim_refl.

Theorem upToBisim_implie_upToBisimT : upTo1ImpliesUpTo2 refl_t transitivity_t.
unfold. intros. case H1. unfold. left. search. 

Theorem upToBisim_implie_upToBisimK : upTo1ImpliesUpTo2 refl_t context_t.
unfold. intros. case H1. unfold. left. search.

Theorem upToBisim_implie_upToBisimBK : upTo1ImpliesUpTo2 refl_t bisim_context_t.
unfold. intros. case H1. unfold. left. unfold. backchain bisim_refl. backchain bisim_refl.

Theorem upToBisimB_implie_upToBisimBK : upTo1ImpliesUpTo2 bisim_t bisim_context_t.
unfold. intros. case H1. unfold. left. unfold. search. search. 

Theorem upToBisimK_implie_upToBisimBK : upTo1ImpliesUpTo2 context_t bisim_context_t.
unfold. intros. case H1. unfold. case H2.
left. unfold. backchain bisim_refl. backchain bisim_refl.
right. exists (par P2 R). exists (par Q2 R). split.
unfold. backchain bisim_refl. backchain bisim_refl.
exists R. search. 

Define equiv_rel : (proc -> proc -> prop) -> prop by 
  equiv_rel Rel := 
   (forall P, Rel P P) /\
   (forall P Q, Rel P Q -> Rel Q P) /\
   (forall P Q R, Rel P Q -> Rel Q R -> Rel P R).

Define bisim_is_equiv : prop by bisim_is_equiv := equiv_rel (bisim_up_to refl_t).
Define bisimB_is_equiv : prop by bisimB_is_equiv := equiv_rel (bisim_up_to bisim_t).
Define bisimT_is_equiv : prop by bisimT_is_equiv := equiv_rel (bisim_up_to transitivity_t).

Define subst_rel : (proc -> proc -> prop) -> prop by 
   subst_rel Rel := (forall P Q R, Rel P Q -> Rel (par P R) (par Q R)).

Define cong_rel : (proc -> proc -> prop) -> prop by 
  cong_rel Rel := equiv_rel Rel /\ subst_rel Rel.

Define bisim_is_subst : prop by bisim_is_subst := subst_rel (bisim_up_to refl_t).
Define bisimK_is_subst : prop by bisimK_is_subst := subst_rel (bisim_up_to context_t).
Define bisimBK_is_subst : prop by bisimBK_is_subst := subst_rel (bisim_up_to bisim_context_t).

Define bisim_is_cong : prop by bisim_is_cong := cong_rel (bisim_up_to refl_t).
Define bisimK_is_cong : prop by bisimK_is_cong := cong_rel (bisim_up_to context_t).
Define bisimBK_is_cong : prop by bisimBK_is_cong := cong_rel (bisim_up_to bisim_context_t).

% Completeness theorems for the characterization theorems above. 

Theorem bisimB_soundIff_completeness : bisim_is_equiv -> is_sound bisim_t -> bisimB_is_equiv.
intros. unfold. unfold. 
intros. case H1. case H3. apply H4 with P = P. apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. backchain implies.
intros. case H2. apply H4 to H3. case H1. case H6. apply H8 to H5. apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. backchain implies.
intros. case H2. apply H5 to H3. apply H5 to H4. case H1. case H8. apply H11 to H6 H7. apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. backchain implies.

Theorem bisimT_soundIff_completeness : bisim_is_equiv -> is_sound transitivity_t -> bisimT_is_equiv.
intros. unfold. unfold. 
intros. case H1. case H3. apply H4 with P = P. apply upToBisim_implie_upToBisimT. loadLemma : apply bisim_implies_bisimT. implies : case loadLemma. backchain implies.
intros. case H2. apply H4 to H3. case H1. case H6. apply H8 to H5. apply upToBisim_implie_upToBisimT. loadLemma : apply bisim_implies_bisimT. implies : case loadLemma. backchain implies.
intros. case H2. apply H5 to H3. apply H5 to H4. case H1. case H8. apply H11 to H6 H7. apply upToBisim_implie_upToBisimT. loadLemma : apply bisim_implies_bisimT. implies : case loadLemma. backchain implies.

Theorem bisimK_and_subst_completeness : bisim_is_subst -> is_sound context_t -> bisimK_is_subst.
intros. unfold. unfold. intros. case H2. apply H4 to H3. case H1. case H6. apply H7 to H5 with R = R. apply upToBisim_implie_upToBisimK. loadLemma : apply bisim_implies_bisimK. implies : case loadLemma. backchain implies.

Theorem bisimBK_and_subst_completeness : bisim_is_cong -> is_sound bisim_context_t -> bisimBK_is_subst.
intros. unfold. unfold. 
intros. case H2. apply H4 to H3. case H1. case H6. case H8. apply H9 to H5 with R = R. apply upToBisim_implie_upToBisimBK. loadLemma : apply bisim_implies_bisimBK. implies : case loadLemma. backchain implies.


% Soundness theorems for the characterization theorems above. 

Theorem bisimB_soundIff_soundness : bisimB_is_equiv -> bisim_is_equiv -> is_sound bisim_t.
intros. unfold. coinduction. intros. case H3. unfold.
% transitions from P. 
intros. apply H4 to H10. 
exists Q2. split. search. exists P1. exists Q2. split. search.

case H1.				% unfold on bisimBK_is_cong
case H14.				% unfold on bisimBK_is_cong

case H12.				% unfold the upto technique.

upToImplies: apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. 
apply implies to upToImplies H18.
apply implies to upToImplies H19.
	apply H17 to H20 H13.		% transitivity First Middle in New.
	apply H16 to H21. 		% symmetry Second in SecondSym. 
	apply H17 to H22 H23.		% transitivity New SecondSym.
backchain CH.

% dn transitions from P. 
intros. apply H5 to H10. 
exists N. split. search. exists M. exists N. intros. split. search.

apply H12 with W = W.

case H1.				% unfold on bisimBK_is_cong
case H15.				% unfold on bisimBK_is_cong

case H13.				% unfold the upto technique.

upToImplies: apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. 
apply implies to upToImplies H19.
apply implies to upToImplies H20.
	apply H18 to H21 H14.		% transitivity First Middle in New.
	apply H17 to H22. 		% symmetry Second in SecondSym. 
	apply H18 to H23 H24.		% transitivity New SecondSym.
backchain CH.

% up transitions from P. 
intros. apply H6 to H10. 
exists N. split. search. exists M. exists N. intros. split. search.

case H1.				% unfold on bisimBK_is_cong
case H14.				% unfold on bisimBK_is_cong

case H12.				% unfold the upto technique.

upToImplies: apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. 
apply implies to upToImplies H18.
apply implies to upToImplies H19.
	apply H17 to H20 H13.		% transitivity First Middle in New.
	apply H16 to H21. 		% symmetry Second in SecondSym. 
	apply H17 to H22 H23.		% transitivity New SecondSym.
backchain CH.


% transitions from Q. 
intros. apply H7 to H10.
exists P2. split. search. exists P2. exists Q1. split. search.

case H1.				% unfold on bisimBK_is_cong
case H14.				% unfold on bisimBK_is_cong

case H12.				% unfold the upto technique.

upToImplies: apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. 
apply implies to upToImplies H18.
apply implies to upToImplies H19.
	apply H17 to H20 H13.		% transitivity First Middle in New.
	apply H16 to H21. 		% symmetry Second in SecondSym. 
	apply H17 to H22 H23.		% transitivity New SecondSym.
backchain CH.

% dn transitions from Q. 
intros. apply H8 to H10. 
exists M. split. search. exists M. exists N. intros. split. search.

apply H12 with W = W.

case H1.				% unfold on bisimBK_is_cong
case H15.				% unfold on bisimBK_is_cong

case H13.				% unfold the upto technique.

upToImplies: apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. 
apply implies to upToImplies H19.
apply implies to upToImplies H20.
	apply H18 to H21 H14.		% transitivity First Middle in New.
	apply H17 to H22. 		% symmetry Second in SecondSym. 
	apply H18 to H23 H24.		% transitivity New SecondSym.
backchain CH.

% up transitions from P. 
intros. apply H9 to H10. 
exists M. split. search. exists M. exists N. intros. split. search.

case H1.				% unfold on bisimBK_is_cong
case H14.				% unfold on bisimBK_is_cong

case H12.				% unfold the upto technique.

upToImplies: apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. 
apply implies to upToImplies H18.
apply implies to upToImplies H19.
	apply H17 to H20 H13.		% transitivity First Middle in New.
	apply H16 to H21. 		% symmetry Second in SecondSym. 
	apply H17 to H22 H23.		% transitivity New SecondSym.
backchain CH.



Theorem bisimT_soundIff_soundness : bisimT_is_equiv -> bisim_is_equiv -> is_sound transitivity_t. skip.

Theorem bisimK_and_subst_soundness : bisimK_is_subst -> bisim_is_cong -> is_sound context_t.
intros. unfold. coinduction. intros. case H3. unfold.
% transitions from P. 
intros. apply H4 to H10. 
exists Q2. split. search. exists P1. exists Q2. split. search.

case H1.				% unfold on bisimBK_is_cong
case H14.				% unfold on bisimBK_is_cong

case H12.				% unfold the upto technique.
case H16. 

% inside no context 
backchain CH.
% inside a bigger context
	apply H15 to H13 with R = R.	% congruence of Middle in MiddleNew. 
backchain CH.

% dn transitions from P. 
intros. apply H5 to H10. 
exists N. split. search. exists M. exists N. intros. split. search.

apply H12 with W = W.

case H1.				% unfold on bisimBK_is_cong
case H15.				% unfold on bisimBK_is_cong

case H13.				% unfold the upto technique.
case H17. 

% inside no context 
     apply equality_for_structured_cont. case H20. 
     apply H21 to H14 H18 H19. 	
     backchain CH.
% inside a bigger context
     apply H16 to H14 with R = R.	% congruence of Middle in MiddleNew. 
     apply equality_for_structured_cont. case H21. 
     apply H22 to H20 H18 H19. 	
     backchain CH.

% up transitions from P. 
intros. apply H6 to H10. 
exists N. split. search. exists M. exists N. intros. split. search.

case H1.				% unfold on bisimBK_is_cong
case H14.				% unfold on bisimBK_is_cong

case H12.				% unfold the upto technique.
case H16. 

% inside no context 
backchain CH.
% inside a bigger context
	apply H15 to H13 with R = R n1.	% congruence of Middle in MiddleNew. 
backchain CH.


% transitions from Q. 
intros. apply H7 to H10.
exists P2. split. search. exists P2. exists Q1. split. search.

case H1.				% unfold on bisimBK_is_cong
case H14.				% unfold on bisimBK_is_cong

case H12.				% unfold the upto technique.
case H16. 

% inside no context 
backchain CH.
% inside a bigger context
	apply H15 to H13 with R = R.	% congruence of Middle in MiddleNew. 
backchain CH.

% dn transitions from Q. 
intros. apply H8 to H10. 
exists M. split. search. exists M. exists N. intros. split. search.

apply H12 with W = W.

case H1.				% unfold on bisimBK_is_cong
case H15.				% unfold on bisimBK_is_cong

case H13.				% unfold the upto technique.
case H17. 

% inside no context 
     apply equality_for_structured_cont. case H20. 
     apply H21 to H14 H18 H19. 	
     backchain CH.
% inside a bigger context
     apply H16 to H14 with R = R.	% congruence of Middle in MiddleNew. 
     apply equality_for_structured_cont. case H21. 
     apply H22 to H20 H18 H19. 	
     backchain CH.

% up transitions from P. 
intros. apply H9 to H10. 
exists M. split. search. exists M. exists N. intros. split. search.

case H1.				% unfold on bisimBK_is_cong
case H14.				% unfold on bisimBK_is_cong

case H12.				% unfold the upto technique.
case H16. 

% inside no context 
backchain CH.
% inside a bigger context
	apply H15 to H13 with R = R n1.	% congruence of Middle in MiddleNew. 
backchain CH.


Theorem bisimBK_and_subst_soundness_fst : bisimBK_is_subst -> bisim_is_cong -> is_sound_fst bisim_context_t.  
intros. unfold. coinduction. intros. case H1. case H4. case H2. case H6. case H7. case H3. unfold.

% transitions from P. 
intros. case H12. apply H16 to H15. case H13. apply H25 to H22. case H14. apply H34 to H31. 
exists Q5. split. search. exists P1. exists Q5.	 split. search. 

% applying the information from ReflexiviyTechnique 
case H23.				
case H41.

%  proving derivatives are related.
case H32.
case H43.
% Next code is specific of Bisimilarity up-to Bisimilarity and Context (2 cases)
% - inside no bigger context
case H44.
	apply H11 to H24 H45.
	apply H10 to H46.
	apply H11 to H48 H42.
  backchain CH.
% - inside a bigger context
case H44.
	apply H11 to H24 H45.
	apply H10 to H46.
	apply H11 to H48 H42.
	apply H5 to H33 with R = R1.
  backchain CH.

% dn transitions from P. 
intros. case H12. apply H17 to H15. case H13. apply H25 to H22. case H14. apply H33 to H30. 
exists N4. split. search. exists M. exists N4. intros. split. search.

apply H23 with W = W. apply H31 with W = W. apply H39 with W = W.

case H40. case H44.
apply equality_for_structured_refl. case H50. 
apply H51 to H41 H47 H46. 	
apply H51 to H45 H49 H48. 	

case H42.
case H54.

% inside no bigger context
case H55.
	apply H11 to H52 H56.
	apply H10 to H57.
	apply H11 to H59 H53.
backchain CH. 
% inside a bigger context
case H55.
	apply H11 to H52 H56.
	apply H10 to H57.
	apply H11 to H59 H53.
	apply H5 to H43 with R = R1.
backchain CH. 

% up transitions from P. 
intros. case H12. apply H18 to H15. case H13. apply H27 to H22. case H14. apply H36 to H31. 
exists N4. split. search. exists M. exists N4. intros. split. search.

% applying the information from ReflexiviyTechnique 
case H23.				
case H41.

%  proving derivatives are related.
case H32.
case H43.
% Next code is specific of Bisimilarity up-to Bisimilarity and Context (2 cases)
% - inside no bigger context
case H44.
	apply H11 to H24 H45.
	apply H10 to H46.
	apply H11 to H48 H42.
  backchain CH.
% - inside a bigger context
case H44.
	apply H11 to H24 H45.
	apply H10 to H46.
	apply H11 to H48 H42.
	apply H5 to H33 with R = R1 n1.
  backchain CH.

% transitions from Q. 
intros. case H14. apply H19 to H15. case H13. apply H28 to H22. case H12. apply H37 to H31. 
exists P5. split. search. exists P5. exists Q1. split. search. 

% applying the information from ReflexiviyTechnique 
case H23.				
case H41.

%  proving derivatives are related.
case H32.
case H43.
% Next code is specific of Bisimilarity up-to Bisimilarity and Context (2 cases)
% - inside no bigger context
case H44.
	apply H11 to H42 H45.
	apply H10 to H46.
	apply H11 to H48 H24.
  backchain CH.
% - inside a bigger context
case H44.
	apply H11 to H42 H45.
	apply H10 to H46.
	apply H11 to H48 H24.
	apply H5 to H33 with R = R1.
  backchain CH.

% dn transitions from Q. 
intros. case H14. apply H20 to H15. case H13. apply H28 to H22. case H12. apply H36 to H30. 
exists M4. split. search. exists M4. exists N. intros. split. search.

apply H23 with W = W. apply H31 with W = W. apply H39 with W = W.

case H40. case H44.
apply equality_for_structured_refl. case H50. 
apply H51 to H41 H47 H46. 	
apply H51 to H45 H49 H48. 	

case H42.
case H54.

% inside no bigger context
case H55.
	apply H11 to H53 H56.
	apply H10 to H57.
	apply H11 to H59 H52.
backchain CH. 
% inside a bigger context
case H55.
	apply H11 to H53 H56.
	apply H10 to H57.
	apply H11 to H59 H52.
	apply H5 to H43 with R = R1.
backchain CH. 

% up transitions from Q. 
intros. case H14. apply H21 to H15. case H13. apply H30 to H22. case H12. apply H39 to H31. 
exists M4. split. search. exists M4. exists N. intros. split. search.

% applying the information from ReflexiviyTechnique 
case H23.				
case H41.

%  proving derivatives are related.
case H32.
case H43.
% Next code is specific of Bisimilarity up-to Bisimilarity and Context (2 cases)
% - inside no bigger context
case H44.
	apply H11 to H42 H45.
	apply H10 to H46.
	apply H11 to H48 H24.
  backchain CH.
% - inside a bigger context
case H44.
	apply H11 to H42 H45.
	apply H10 to H46.
	apply H11 to H48 H24.
	apply H5 to H33 with R = R1 n1.
  backchain CH.


Theorem bisimBK_and_subst_soundness_snd : bisimBK_is_subst -> bisim_is_cong -> is_sound_snd bisim_context_t.
intros. unfold. intros. case H2. case H4. case H5. apply H7 with P = P. apply H7 with P = Q. exists P. exists Q. search. 

Theorem bisimBK_and_subst_soundness : bisimBK_is_subst -> bisim_is_cong -> is_sound bisim_context_t.
intros. unfold. intros. apply bisimBK_and_subst_soundness_snd. apply H4 to H1 H2. case H5. apply H6 to H3. apply bisimBK_and_subst_soundness_fst. apply H10 to H1 H2. case H11. backchain H12.


% Proof that bisimB is an equivalence, and therefore that bisimilarity up to bisimilarity is sound. 

% First, this lemma will allow us to avoid the circular use of transitivity in the proof of theorem bisimB_is_equiv_th.

Theorem subst_in_bisimB : forall P Q1 Q2, bisim_up_to bisim_t P Q1 -> bisim_up_to refl_t Q1 Q2 -> bisim_up_to bisim_t P Q2. 
coinduction. intros. unfold. 
intros. case H1. apply H4 to H3. case H2. apply H13 to H10. exists Q5. split. search. case H20. exists P3. exists Q6. case H11. split. unfold. search. backchain bisim_refl. apply bisim_sym to H23. apply bisim_trans to H24 H21. backchain CH. 
intros. case H1. apply H5 to H3. case H2. apply H13 to H10. exists N1. split. search. exists M2. exists N1. intros. apply H11 with W = W.  apply H19 with W = W. case H22. case H20. split. unfold. search. backchain bisim_refl. apply equality_for_structured_refl. case H28. apply H29 to H23 H25 H24. apply bisim_sym to H27.
apply bisim_trans to H31 H30. backchain CH. 
intros. case H1. apply H6 to H3. case H2. apply H15 to H10. exists N1. split. search. case H20. case H11. exists M2. exists N3. intros. split. unfold. search. backchain bisim_refl. apply bisim_sym to H23. apply bisim_trans to H24 H21. backchain CH. 
intros. case H2. apply H7 to H3. case H1. apply H16 to H10. exists P1. split. search. case H11. exists P4. exists Q4. case H20. split. unfold. search. backchain bisim_refl. apply bisim_sym to H23. apply bisim_trans to H24 H12. backchain CH. 
intros. case H2. apply H8 to H3. case H1. apply H16 to H10. exists M1. split. search. exists M3. exists N. intros. apply H11 with W = W.  apply H19 with W = W. case H20. case H22. split. unfold. search. backchain bisim_refl. apply equality_for_structured_refl. case H28. apply H29 to H21 H25 H24. apply bisim_sym to H27.
apply bisim_trans to H31 H30. backchain CH. 
intros. case H2. apply H9 to H3. case H1. apply H18 to H10. exists M1. split. search. exists M3. exists N. intros. case H11. case H20. split. unfold. search. backchain bisim_refl. apply bisim_sym to H23. apply bisim_trans to H24 H12. backchain CH. 


Theorem bisimB_is_equiv_th : equiv_rel (bisim_up_to bisim_t).
unfold.
% reflexivity
coinduction. intros. unfold. 
% the 6 transitions.
intros. exists P1. split. search. exists P1. exists P1. split. unfold. backchain bisim_refl. backchain bisim_refl. backchain CH.
intros. exists M. split. search. exists M. exists M. intros. split. unfold. backchain bisim_refl. backchain bisim_refl. backchain CH.
intros. exists M. split. search. exists M. exists M. intros. split. unfold. backchain bisim_refl. backchain bisim_refl. backchain CH.
intros. exists Q1. split. search. exists Q1. exists Q1. split. unfold. backchain bisim_refl. backchain bisim_refl. backchain CH.
intros. exists N. split. search. exists N. exists N. intros. split. unfold. backchain bisim_refl. backchain bisim_refl. backchain CH.
intros. exists N. split. search. exists N. exists N. intros. split. unfold. backchain bisim_refl. backchain bisim_refl. backchain CH.

% symmetry
coinduction. intros. unfold.
% the 6 transitions.
intros. case H1. apply H6 to H2. exists P2. split. search. exists Q3. exists P3. split. case H10. unfold. search. search. backchain CH.
intros. case H1. apply H7 to H2. exists M1. split. search. exists N2. exists M2. intros. apply H10 with W = W. case H11. split. unfold. search. search. backchain CH.
intros. case H1. apply H8 to H2. exists M1. split. search. exists N2. exists M2. intros. case H10. split. unfold. search. search. backchain CH.
intros. case H1. apply H3 to H2. exists Q2. split. search. exists Q3. exists P3. split. case H10. unfold. search. search. backchain CH.
intros. case H1. apply H4 to H2. exists N1. split. search.  exists N2. exists M2. intros. apply H10 with W = W. case H11. split. unfold. search. search. backchain CH.
intros. case H1. apply H5 to H2. exists N1. split. search. exists N2. exists M2. intros. case H10. split. unfold. search. search. backchain CH.

% transitivity
coinduction. intros. unfold.
% the 6 transitions.
intros. case H1. apply H4 to H3. case H2. apply H13 to H10. exists Q1. split. search. exists P3. exists Q4. case H11. case H20. split. unfold. search. search. 
apply bisim_sym to H23. apply bisim_trans to H26 H24. apply subst_in_bisimB to H12 H27. backchain CH with P = P3, Q = P2, R = Q4.
intros. case H1. apply H5 to H3. case H2. apply H13 to H10. exists N1. split. search. exists M2. exists N3. intros. apply H11 with W = W.  apply H19 with W = W. case H20. case H22. split. unfold. search. search. 
apply bisim_sym to H25. apply bisim_trans to H28 H26. apply subst_in_bisimB to H21 H29. backchain CH with P = M2 W, Q = M1 W, R = N3 W.
intros. case H1. apply H6 to H3. case H2. apply H15 to H10. exists N1. split. search. exists M2. exists N3. intros. case H11. case H20. split. unfold. search. search. 
apply bisim_sym to H23. apply bisim_trans to H26 H24. apply subst_in_bisimB to H12 H27. backchain CH with P = M2 n1, Q = M1 n1, R = N3 n1.
intros. case H2. apply H7 to H3. case H1. apply H16 to H10. exists P1. split. search. exists P4. exists Q3. case H11. case H20. split. unfold. search. search.
apply bisim_sym to H25. apply bisim_trans to H26 H22. apply subst_in_bisimB to H21 H27. backchain CH with P = P4, Q = P3, R = Q3.
intros. case H2. apply H8 to H3. case H1. apply H16 to H10. exists M1. split. search. exists M3. exists N2. intros. apply H11 with W = W.  apply H19 with W = W. case H20. case H22. split. unfold. search. search. 
apply bisim_sym to H27. apply bisim_trans to H28 H24. apply subst_in_bisimB to H23 H29. backchain CH with P = M3 W, Q = M2 W, R = N2 W.
intros. case H2. apply H9 to H3. case H1. apply H18 to H10. exists M1. split. search. exists M3. exists N2. intros. case H11. case H20. split. unfold. search. search.
apply bisim_sym to H25. apply bisim_trans to H26 H22. apply subst_in_bisimB to H21 H27. backchain CH with P = M3 n1, Q = M2 n1, R = N2 n1.


% Proof that bisimT is an equivalence, and therefore that bisim up to transitivity is sound. 

% Proof that bisimK is substitutive, and therefore that bisimilarity up to context is sound. 
% This proof necessarily use the insight of the language at hand, and in particular faithful contexts for CCS. 

% Definition of faithful contexts. 

Theorem faithful_par : forall P P1 A R1, 
				(exists R2, one (par P R1) A P1 -> P1 = (par P R2) /\ (forall Q, one (par Q R1) A (par Q R2))) \/
				(one (par P R1) A P1 -> 
					(exists P2 B R2, one P B P2 /\ P1 = (par P2 R2) /\ (forall Q Q1, one Q B Q1 -> one (par Q R1) A (par Q1 R2)))).skip.

Theorem bisimK_is_subst_th : subst_rel (bisim_up_to context_t). skip. 



% --- EXAMPLES --- %
%
% For bisimilarity up-to bisimilarity:
% -- !(a(c) + b(c)) is bisimilar to !(a(c)) || !(b(c))
% -- !!a is bisimilar to !a
%
% For bisimilarity up-to bisimilarity and context:
% -- !(a(c).P + b(c).P) is bisimilar to !(a(c)).P || !(b(c)).P
% -- !!a.P is bisimilar to !a.P


% For bisimilarity up-to bisimilarity:

% Example: !(a(c) + b(c)) is bisimilar to !(a(c)) || !(b(c))
% Instead of showing a bisimulation between the two processes, we prove that they are bisimilar up-to bisimilarity.
% Notice that proving the ordinary bisimilarity of those two processes requires an infinite relation.  

Theorem bisim_par_zeroEl : forall P,
bisim_up_to refl_t (par P null) P. skip.

Theorem bisim_par_comm : forall P Q,
bisim_up_to refl_t (par P Q) (par Q P).skip.

Theorem bisim_par_assoc : forall P Q R,
bisim_up_to refl_t (par (par P Q) R) (par P (par Q R)).skip.

Theorem bisim_par_cong_right : forall P Q R, 
bisim_up_to refl_t P Q -> bisim_up_to refl_t (par P R) (par Q R).skip. 

Theorem bisim_par_cong_left : forall P Q R, 
bisim_up_to refl_t P Q -> bisim_up_to refl_t (par R P) (par R Q).skip. 

Theorem bisim_repl_absorb : forall P, 
bisim_up_to refl_t (par (repl P) P) (repl P).skip.



Theorem example_1_bisim : forall A B, bisim_up_to bisim_t (repl (plus (in A x\null) (in B x\null))) (par (repl (in A x\null)) (repl (in B x\null))).
coinduction. intros. unfold.					

% It will split to the 6 cases of bisim.

% Case of plain transitions from P: not possible from (in A x\null) or (in B x\null). 
% This case will be discharged after we traverse the SOS semantics of repl and get to the "leaves" of form (in A x\null) -A-> P' (with the relation step: one).
% Those are not possible, recall indeed that (in A x\null) can do only oneb transitions. Same thing for (in B x\null).

intros. case H1. case H2. case H3. case H3.
% case for repl-with-comm
case H2. case H4. case H4.
% case for repl-with-close
case H2. case H4. case H4.

% Case of dn transitions from P: those are possible both from (in A x\null) and (in B x\null).
% First case: the a() input move. 

intros. case H1. case H2. case H3.	
exists x\par (par (repl (in X (x\null))) ((x\null) x)) (repl (in B (x\null))).	% we need to give the result of the transition. 
split. search.

exists x\(repl (plus (in X (x\null)) (in B (x\null)))).
exists x\ (par (repl (in X (x\null))) (repl (in B (x\null)))).
intros. split.					

% first we have to prove they are related by the technique.

unfold.
apply bisim_par_zeroEl with P = (repl (plus (in X (x\null)) (in B (x\null)))).
search.
apply bisim_par_zeroEl with P = (repl (in X (x\null))).
apply bisim_par_cong_right to H4 with R = (repl (in B (x\null))).          
search.

% and then, that they are related by bisim_up_to bisim_t.
backchain CH. 

% Second case: the b() input move. 

case H3.
exists x\par (repl (in A (x\null))) (par (repl (in X (x\null))) ((x\null) x)).
split. search.

exists x\(repl (plus (in A (x\null)) (in X (x\null)))).
exists x\ (par (repl (in A (x\null))) (repl (in X (x\null)))).
intros. split.

% first we have to prove they are related by the technique.

unfold.
apply bisim_par_zeroEl with P = (repl (plus (in A (x\null)) (in X (x\null)))).
search.
apply bisim_par_zeroEl with P = (repl (in X (x\null))).
apply bisim_par_cong_left to H4 with R = (repl (in A (x\null))).          
search. 

% and then, that they are related by bisim_up_to bisim_t.
backchain CH.

% Case of up transitions from P (bound output): not possible from (in A x\null) or (in B x\null). 
% This case will be discharged.
intros. case H1. case H2. case H3. case H3.

% Case of plain transitions from Q: not possible from (in A x\null) or (in B x\null). 
% This case will be discharged.

intros. case H1. case H2. case H3. case H3. case H3. case H2. case H3. case H3. case H3. case H3. case H4. case H2. case H3. case H4. case H3. case H4. case H3. case H4.

% Case of dn transitions from Q: those are possible both from (in A x\null) and (in B x\null).
% First case: the a() input move. 
intros. case H1. case H2. case H3.

exists x\par (repl (plus (in X (x\null)) (in B (x\null)))) ((x\null) x).
split. search.

exists x\(repl (plus (in X (x\null)) (in B (x\null)))).
exists x\(par (repl (in X (x\null))) (repl (in B (x\null)))).
intros. split.

% first we have to prove they are related by the technique.
unfold.
apply bisim_par_zeroEl with P = (repl (plus (in X (x\null)) (in B (x\null)))).
search.
apply bisim_par_zeroEl with P = (repl (in X (x\null))).
apply bisim_par_cong_right to H4 with R = (repl (in B (x\null))).          
search.

% and then, that they are related by bisim_up_to bisim_t.
backchain CH. 

% Second case: the a() input move. 

case H2. case H3.

exists x\par (repl (plus (in A (x\null)) (in X (x\null)))) ((x\null) x).
split. search.

exists x\(repl (plus (in A (x\null)) (in X (x\null)))).
exists x\ (par (repl (in A (x\null))) (repl (in X (x\null)))).
intros. split.

% first we have to prove they are related by the technique.
unfold.
apply bisim_par_zeroEl with P = (repl (plus (in A (x\null)) (in X (x\null)))).
search.
apply bisim_par_zeroEl with P = (repl (in X (x\null))).
apply bisim_par_cong_left to H4 with R = (repl (in A (x\null))).          
search.

% and then, that they are related by bisim_up_to bisim_t.
backchain CH.

% Case of up transitions from Q (bound output): not possible from (in A x\null) or (in B x\null). 
% This case will be discharged.
intros. case H1. case H2. case H3. case H2. case H3.


% Example: !!a is bisimilar to !a.
% Instead of showing a bisimulation between the two processes, we prove that they are bisimilar up-to bisimilarity.
% Notice that proving the ordinary bisimilarity of those two processes requires an infinite relation.  

Theorem example_2_bisim : forall A, bisim_up_to bisim_t (repl (repl (in A x\null))) (repl (in A x\null)).
coinduction. intros. unfold.

% it will split to the 6 cases of bisim.

% Case of plain transitions from P: not possible from (in A x\null).
% This case will be discharged after we traverse the SOS semantics of repl and get to the "leaves" of form (in A x\null) -A-> P' (with the relation step: one).
% Those are not possible, recall indeed that (in A x\null) can do only oneb transitions. 
intros. case H1. case H2. case H3. case H3. case H3. case H2. case H4. case H2. case H4.

% Case of dn transitions from P: those are possible from (in A x\null).
intros. case H1. case H2. case H3.

exists (x\par (repl (in X (x\null))) ((x\null) x)).
split. search.

exists x\(repl (repl (in X (x\null)))).
exists x\(repl (in X (x\null))).
intros. split.

% first we have to prove they are related by the technique.
unfold.
apply bisim_par_zeroEl with P = (repl (in X (x\null))).
apply bisim_par_cong_left to H4 with R = (repl (repl (in X (x\null)))).
apply bisim_repl_absorb with P = (repl (in X (x\null))).
apply bisim_trans to H5 H6.
search.
apply bisim_par_zeroEl with P = (repl (in X (x\null))).
search.

% and then, that they are related by bisim_up_to bisim_t.
backchain CH.

% Case of up transitions from P (bound output): not possible from (in A x\null). 
% This case will be discharged.
intros. case H1. case H2. case H3.

% Case of plain transitions from Q (bound output): not possible from (in A x\null). 
% This case will be discharged.
intros. case H1. case H2. case H2. case H2.

% Case of dn transitions from Q: those are possible from (in A x\null).
intros. case H1. case H2.

exists (x\(par (repl (repl (in X (x\null)))) (par (repl (in X (x\null))) ((x\null) x)))).
split. search.

exists x\(repl (repl (in X (x\null)))).
exists x\(repl (in X (x\null))).
intros. split.

% first we have to prove they are related by the technique.
unfold.
apply bisim_par_zeroEl with P = (repl (in X (x\null))).
apply bisim_par_cong_left to H3 with R = (repl (repl (in X (x\null)))).
apply bisim_repl_absorb with P = (repl (in X (x\null))).
apply bisim_trans to H4 H5.
search.
apply bisim_par_zeroEl with P = (repl (in X (x\null))).
search.

% and then, that they are related by bisim_up_to bisim_t.
backchain CH.


% Case of up transitions from Q (bound output): not possible from (in A x\null). 
% This case will be discharged.
intros. case H1. case H2.


% For bisimilarity up-to bisimilarity and context:

% Example: !(a(c).P + b(c).P) is bisimilar to !(a(c).P) || !(b(c).P)
% Instead of showing a bisimulation between the two processes, we prove that they are bisimilar up-to bisimilarity and context.
% Notice that proving the ordinary bisimilarity of those two processes requires an infinite relation.  

Theorem example_1_context : forall A B P, bisim_up_to bisim_context_t (repl (plus (in A P) (in B P))) (par (repl (in A P)) (repl (in B P))).
coinduction. intros. unfold.

% it will split to the 6 cases of bisim.

% Case of plain transitions from P: not possible from (in A P) or (in B P). 
% This case will be discharged after we traverse the SOS semantics of repl and get to the "leaves" of form (in A P) -A-> P' (with the relation step: one).
% Those are not possible, recall indeed that (in A P) can do only oneb transitions. Same thing for (in B P).

intros. case H1. case H2. case H3. case H3. case H2. case H4. case H4. case H2. case H4. case H4.

% Case of dn transitions from P: those are possible both from (in A P) and (in B P).
% First case: the a() input move. 
intros. case H1. case H2. case H3.

exists x\par (par (repl (in X M1)) (M1 x)) (repl (in B M1)).	% we need to give the result of the transition. 
split. search.

exists x\(repl (plus (in X M1) (in B M1))).
exists x\ (par (repl (in X M1)) (repl (in B M1))).
intros. split.					

% first we have to prove they are related by the technique.
unfold. right.

exists (par (repl (plus (in X M1) (in B M1))) (M1 W)).
exists (par (par (repl (in X M1)) (repl (in B M1))) (M1 W)).
split.
unfold.
apply bisim_refl with P = (par (repl (plus (in X M1) (in B M1))) (M1 W)).
search.
apply bisim_par_comm with P = (M1 W), Q = (repl (in B M1)).
apply bisim_par_cong_left to H4 with R = (repl (in X M1)).
apply bisim_par_assoc with P = (repl (in X M1)), Q = (M1 W), R = (repl (in B M1)).
apply bisim_par_assoc with P = (repl (in X M1)), Q = (repl (in B M1)), R = (M1 W).
apply bisim_trans to H6 H5.
apply bisim_sym to H7.
apply bisim_trans to H8 H9.
search.
exists (M1 W).							% the common context. 
split. search. search.

% and then, that they are related by bisim_up_to bisim_context_t.
backchain CH.

% Second case: the b() input move. 
case H3.

exists x\par (repl (in A M1)) (par (repl (in X M1)) (M1 x)).
split. search.

exists x\(repl (plus (in A M1) (in X M1))).
exists x\ (par (repl (in A M1)) (repl (in X M1))).
intros. split.

% first we have to prove they are related by the technique.
unfold. right.

exists (par (repl (plus (in A M1) (in X M1))) (M1 W)).
exists (par (par (repl (in A M1)) (repl (in X M1))) (M1 W)).
split.
unfold.
apply bisim_refl with P = (par (repl (plus (in A M1) (in X M1))) (M1 W)). 
search.
apply bisim_par_assoc with P = (repl (in A M1)), Q = (repl (in X M1)), R = (M1 W).
apply bisim_sym to H4.
search.
exists (M1 W).							% the common context. 
split. search. search.

% and then, that they are related by bisim_up_to bisim_context_t.
backchain CH.

% Case of up transitions from P (bound output): not possible from (in A P) or (in B P). 
% This case will be discharged.
intros. case H1. case H2. case H3. case H3.

% Case of plain transitions from Q: not possible from (in A P) or (in B P). 
% This case will be discharged.
intros. case H1. case H2. case H3. case H3. case H3. case H2. case H3. case H3. case H3. case H3. case H4. case H2. case H3. case H4. case H3. case H4. case H3. case H4.


% Case of dn transitions from Q: those are possible both from (in A P) and (in B P).
% First case: the a() input move. 
intros. case H1. case H2. case H3.

exists x\par (repl (plus (in X M1) (in B M1))) (M1 x).
split.
search.

exists x\(repl (plus (in X M1) (in B M1))).
exists x\(par (repl (in X M1)) (repl (in B M1))).
intros. split.

% first we have to prove they are related by the technique.
unfold. right.

exists (par (repl (plus (in X M1) (in B M1))) (M1 W)).
exists (par (par (repl (in X M1)) (repl (in B M1))) (M1 W)).
split.
unfold.
apply bisim_refl with P = (par (repl (plus (in X M1) (in B M1))) (M1 W)).
search.
apply bisim_par_comm with P = (M1 W), Q = (repl (in B M1)).
apply bisim_par_cong_left to H4 with R = (repl (in X M1)).
apply bisim_par_assoc with P = (repl (in X M1)), Q = (M1 W), R = (repl (in B M1)).
apply bisim_par_assoc with P = (repl (in X M1)), Q = (repl (in B M1)), R = (M1 W).
apply bisim_trans to H6 H5.
apply bisim_sym to H7.
apply bisim_trans to H8 H9.
search.
exists (M1 W).							% the common context. 
split. search. search.

% and then, that they are related by bisim_up_to bisim_context_t.
backchain CH.


% Second case: the b() input move. 
case H2. case H3.

exists x\par (repl (plus (in A M) (in X M))) (M x).
split. search.

exists x\(repl (plus (in A M) (in X M))).
exists x\(par (repl (in A M)) (repl (in X M))).
intros. split.

% first we have to prove they are related by the technique.
unfold. right.

exists par (repl (plus (in A M) (in X M))) (M W).
exists par (par (repl (in A M)) (repl (in X M))) (M W).
split.
unfold.
apply bisim_refl with P = (par (repl (plus (in A M) (in X M))) (M W)).
search.
apply bisim_par_assoc with P = (repl (in A M)), Q = (repl (in X M)), R = (M W).
apply bisim_sym to H4.
search.
exists (M W).							% the common context. 
split. search. search.

% and then, that they are related by bisim_up_to bisim_context_t.
backchain CH.

% Case of up transitions from Q (bound output): not possible from (in A P) or (in B P). 
% This case will be discharged.
intros. case H1. case H2. case H3. case H2. case H3.


% Example: !!a.P is bisimilar to !a.P.
% Instead of showing a bisimulation between the two processes, we prove that they are bisimilar up-to bisimilarity and context.
% Notice that proving the ordinary bisimilarity of those two processes requires an infinite relation.  

Theorem example_2_context : forall A P, bisim_up_to bisim_context_t (repl (repl (in A P))) (repl (in A P)).
coinduction. intros. unfold.

% it will split to the 6 cases of bisim.

% Case of plain transitions from P: not possible from (in A P).
% This case will be discharged after we traverse the SOS semantics of repl and get to the "leaves" of form (in A P) -A-> P' (with the relation step: one).
% Those are not possible, recall indeed that (in A P) can do only oneb transitions. 

intros. case H1. case H2. case H3. case H3. case H3. case H2. case H4. case H2. case H4.

% Case of dn transitions from P: those are possible from (in A P).
intros. case H1. case H2. case H3.

exists (x\par (repl (in X M2)) (M2 x)).
split. search.

exists x\(repl (repl (in X M2))).
exists x\(repl (in X M2)).
intros. split.

% first we have to prove they are related by the technique.
unfold. right. 

exists (par (repl (repl (in X M2))) (M2 W)).
exists (par (repl (in X M2)) (M2 W)).
split.
unfold.
apply bisim_repl_absorb with P = (repl (in X M2)).
apply bisim_par_cong_right to H4 with R = (M2 W).
apply bisim_par_assoc with P = (repl (repl (in X M2))), Q = (repl (in X M2)), R = (M2 W).
apply bisim_sym to H6.
apply bisim_trans to H7 H5.
search.
apply bisim_refl with P = (par (repl (in X M2)) (M2 W)).
search.
exists (M2 W).							% the common context. 
search.

% and then, that they are related by bisim_up_to bisim_context_t.
backchain CH.

% Case of up transitions from P (bound output): not possible from (in A P).
% This case will be discharged.
intros. case H1. case H2. case H3.

% Case of up transitions from Q (bound output): not possible from (in A P).
% This case will be discharged.
intros. case H1. case H2. case H2. case H2.

% Case of dn transitions from Q: those are possible from (in A P).
intros. case H1. case H2.

exists (x\(par (repl (repl (in X M))) (par (repl (in X M)) (M x)))).
split. search.

exists x\(repl (repl (in X M))).
exists x\(repl (in X M)).
intros. split.

% first we have to prove they are related by the technique.
unfold. right.

exists (par (repl (repl (in X M))) (M W)).
exists (par (repl (in X M)) (M W)).
split.
unfold.
apply bisim_repl_absorb with P = (repl (in X M)).
apply bisim_par_cong_right to H3 with R = (M W).
apply bisim_par_assoc with P = (repl (repl (in X M))), Q = (repl (in X M)), R = (M W).
apply bisim_sym to H5.
apply bisim_trans to H6 H4.
search.
apply bisim_refl with P = (par (repl (in X M)) (M W)).
search.
exists (M W).							% the common context. 
search.

% and then, that they are related by bisim_up_to bisim_context_t.
backchain CH.


% Case of up transitions from Q (bound output): not possible from (in A P).
% This case will be discharged.
intros. case H1. case H2.

