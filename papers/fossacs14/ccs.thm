% Bisimilarity up-to techniques for CCS. 

% A specification of the SOS semantics for CCS.
% This specification involves the bang constructor.

Kind name,action,proc type.

% Action constructors
Type tau          action.
Type up,dn        name -> action.

% Process constructors
Type null         proc.
Type plus,par     proc -> proc -> proc.
Type act          action -> proc -> proc.
Type repl         proc -> proc.

Define one : proc -> action -> proc -> prop by
  one (act A P) A P
; one (plus P1 P2) A Q             := one P1 A Q
; one (plus P1 P2) A Q             := one P2 A Q
; one (par P Q) A (par P1 Q)       := one P A P1
; one (par P Q) A (par P Q1)       := one Q A Q1
; one (repl P) A (par (repl P) Q)  := one P A Q
; one (par P Q) tau (par P1 Q1)    :=
    exists X, one P (up X) P1 /\ one Q (dn X) Q1
; one (repl P) tau (par (repl P) (par Q R)) :=
    exists X, one P (up X) Q /\ one P (dn X) R.

% Definitions of contexts

Kind ctx type.

Type emptyCtx				ctx. 
Type noHole				proc -> ctx. 
Type act_ctx				action -> ctx -> ctx.
Type par_ctx_l, plus_ctx_l		ctx -> proc -> ctx.
Type par_ctx_r, plus_ctx_r		proc -> ctx -> ctx.


Define in_ctx : ctx -> proc -> proc -> prop by 
	in_ctx emptyCtx P P;
	in_ctx (noHole P)		Q	P;
	in_ctx 	(par_ctx_l C Q) 	P	(par R Q) := in_ctx C P R;
	in_ctx 	(par_ctx_r P C) 	Q	(par P R) := in_ctx C Q R;
	in_ctx 	(plus_ctx_l C Q) 	P	(plus R Q) := in_ctx C P R;
	in_ctx 	(plus_ctx_r P C) 	Q	(plus P R) := in_ctx C Q R;
	in_ctx 	(act_ctx A C) 		P 	(act A R) := in_ctx C P R.


% Definitions for key properties of the relations. 

Define equiv_rel : (proc -> proc -> prop) -> prop by 
  equiv_rel Rel := 
   (forall P, Rel P P) /\
   (forall P Q, Rel P Q -> Rel Q P) /\
   (forall P Q R, Rel P Q -> Rel Q R -> Rel P R).

Define subst_rel : (proc -> proc -> prop) -> prop by 
   subst_rel Rel := (forall P Q C P' Q', Rel P Q -> in_ctx C P P' -> in_ctx C Q Q' -> Rel P' Q').

Define cong_rel : (proc -> proc -> prop) -> prop by 
  cong_rel Rel := equiv_rel Rel /\ subst_rel Rel.

% Bisimilarity up-to techniques.
% The predicate bisimUpTo is parametrized by the up-to technique, that is the argument Upto.
% Intuitively: Upto P1 P2 Q1 Q2 means "in the co-inductive step, use P2 instead of P1 and Q2 instead of Q1."


CoDefine bisim_up_to : (proc -> proc -> proc -> proc -> prop) ->
                         (proc -> proc -> prop) by
  bisim_up_to Upto P Q :=
   (forall A P1, one P A P1 ->
      exists Q1, one Q A Q1 /\
        exists P2 Q2, Upto P1 P2 Q1 Q2 /\ bisim_up_to Upto P2 Q2) /\
   (forall A Q1, one Q A Q1 ->
      exists P1, one P A P1 /\
        exists P2 Q2, Upto P1 P2 Q1 Q2 /\ bisim_up_to Upto P2 Q2).

% An alternative definition of bisimilarity which is based on a "vacuous" up-to technique.

Define refl_t : proc -> proc -> proc -> proc -> prop by refl_t P P Q Q.

CoDefine bisimr : proc -> proc -> prop by bisimr P Q := bisim_up_to refl_t P Q.

Theorem bisim_refl : forall P, bisim_up_to refl_t P P.
coinduction. intros. unfold.
  intros PaP1. exists P1. split. search.
   exists P1. exists P1. split. search. backchain CH.
  intros QaQ1. exists Q1. split. search.
   exists Q1. exists Q1. split. search. backchain CH.

Theorem bisim_sym : forall P Q, bisim_up_to refl_t P Q -> bisim_up_to refl_t Q P.
coinduction. intros. case H1. unfold.
  intros. apply H3 to H4. exists P2. split. search. exists P1. exists P2. split. search. case H6. backchain CH.
  intros. apply H2 to H4. exists Q2. split. search.  exists Q2. exists Q1. split. search. case H6. backchain CH.

Theorem bisim_trans : forall P Q R, bisim_up_to refl_t P Q -> bisim_up_to refl_t Q R -> bisim_up_to refl_t P R. 
coinduction. intros. case H1. case H2. unfold. 
  intros. apply H3 to H7. apply H5 to H8. case H9. case H12. exists Q4. split. search. exists P3. exists Q4. split. search. backchain CH.
  intros. apply H6 to H7. apply H4 to H8. case H9. case H12. exists P4. split. search. exists P4. exists Q3. split. search. backchain CH.

Theorem bisim_is_equiv_th : equiv_rel (bisim_up_to refl_t). apply bisim_refl. apply bisim_sym. apply bisim_trans. search. 
Theorem bisim_is_subst_th : subst_rel (bisim_up_to refl_t). skip. % The proof can be found in the standard library of Abella. 
Theorem bisim_is_cong_th : cong_rel (bisim_up_to refl_t).  apply bisim_is_equiv_th. apply bisim_is_subst_th. search. 


% Abstract definitions for soundness for the various proof techniques. 
% They are to be instantiated later at any convenience.

Define is_sound : (proc -> proc -> proc -> proc -> prop) -> prop by
  is_sound Upto := forall P Q, bisim_up_to Upto P Q -> bisim_up_to refl_t P Q.

Define is_sound_fst : (proc -> proc -> proc -> proc -> prop) -> prop by
  is_sound_fst Upto := forall P Q,
    (exists R S, bisim_up_to refl_t P R /\ bisim_up_to Upto R S /\ bisim_up_to refl_t S Q)
    -> bisim_up_to refl_t P Q.

Define is_sound_snd : (proc -> proc -> proc -> proc -> prop) -> prop by
  is_sound_snd Upto := forall P Q, bisim_up_to Upto P Q ->
    exists R S, bisim_up_to refl_t P R /\ bisim_up_to Upto R S /\ bisim_up_to refl_t S Q.

% Remark: 
%	the soundness of all the techniques that follow but up-to context, are proved by two lemmas first and second. 
%	the up-to context technique can be proved directly, i.e. with lemma is_sound_snd.
%	only is_sound_fst depends on the particular up-to technique and at a specific point of the proof.
%	is_sound_snd works for all reflexive equivalences: proofs are copy/pasted/adjusted.
%	is_sound_snd combines the first and second lemma with no intervention from the up-to technique nor even the equivalence relation: proofs are copy/pasted/adjusted.


% Soundness of Bisimilarity up-to Bisimilarity.

Define bisim_t : proc -> proc -> proc -> proc -> prop by
  bisim_t P1 P2 Q1 Q2 := bisim_up_to refl_t P1 P2 /\ bisim_up_to refl_t Q1 Q2.

Theorem bisim_sound_fst : is_sound_fst bisim_t.
unfold. coinduction. intros. case H1. unfold.

% Remark:
% unfold, open the 2 cases of bisimilarity:
% - transitions from P.
% - transitions from Q.

% Every case is divided in two independent subproofs. 
% - given the step from P, we need to find a suitable step from Q.
% - prove that the derivatives are again in the relation. 
%	the particular up-to technique will play a role in a specific and localized point of this sub-proof.
%	i.e. the proof can be packaged as a procedure that can be copy/pasted/adjusted in a well-defined point of the proof.

% transitions from P.
%   searching for the suitable step from Q. 
intros.	case H2. apply H6 to H5. case H3. apply H11 to H8. case H4. apply H16 to H13.
exists Q5. 
split. search.
exists P1. exists Q5.	
split. search. 

% applying the information from reflexive refl_t. 
case H9.				
case H19.

%  proving derivatives are related.
case H14.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Bisimilarity.
  apply bisim_trans to H10 H21.
  apply bisim_sym to H22.
  apply bisim_trans to H24 H20.
backchain CH.

/* Alternative code based on names
 rename H10 to Left.
 rename H15 to Middle.
 rename H20 to Right.
 rename H21 to First.
 rename H22 to Snd.
 	apply bisim_trans to Left First.
 	SndSym : apply bisim_sym to Snd.
 	apply bisim_trans to SndSym Right.
 backchain CH.
*/

% Case of transitions from Q
%   searching for the suitable step from P. 
intros.	case H4. apply H7 to H5. case H3. apply H12 to H8. case H2. apply H17 to H13.
exists P5.
split. search.
exists P5.
exists Q1.				
split. search. 

% applying the information from ReflexiviyTechnique 
case H9.				
case H19.

% proving derivatives are related.
case H14.				% unfold of up-to technique: we 
% Next code is specific of Bisimilarity up-to Bisimilarity.
% Because it is the symmetric, we need only to switch H10/H20 in the proof code above.
  apply bisim_trans to H20 H21.
  apply bisim_sym to H22.
  apply bisim_trans to H24 H10.
backchain CH.

Theorem bisim_sound_snd : is_sound_snd bisim_t.
unfold.
intros.
apply bisim_refl with P = P.
apply bisim_refl with P = Q.
exists P.
exists Q.
search.

Theorem bisim_sound : is_sound bisim_t.
unfold.
intros.
apply bisim_sound_snd.
case H2.
apply H3 to H1.
apply bisim_sound_fst.
case H7.
backchain H8.


% Soundness of Bisimilarity up-to reflexivity and transitivity closure. 

Define transitivity_t : proc -> proc -> proc -> proc -> prop by
  transitivity_t P1 P3 Q1 Q3 := 
   (P1 = P3 /\ Q1 = Q3) \/
   exists P2 Q2, (bisim_up_to transitivity_t P1 P2) /\ (bisim_up_to transitivity_t  P2 P3) /\ (bisim_up_to transitivity_t Q1 Q2) /\ (bisim_up_to transitivity_t  Q2 Q3).

% Here below are the lemmas we need for the task. 

Theorem bisimUpToTrans_sym : forall P Q, bisim_up_to transitivity_t P Q -> bisim_up_to transitivity_t Q P.skip.
Theorem bisimUpToTrans_trans : forall P Q R, bisim_up_to transitivity_t P Q -> bisim_up_to transitivity_t Q R -> bisim_up_to transitivity_t P R. skip. 

Theorem transitivity_sound_fst : is_sound_fst transitivity_t.
% Remark: as we pointed out above, this proof is nearly copy/pasted until from the soundness of Bisimilarity up-to Bisimilarity.
% the specific code for Bisimilarity up-to Transitivity is needed in a precise and localized point. 

unfold. coinduction. intros. case H1. unfold.

% plain transitions from P.
%   searching for the suitable step from Q. 
intros.	case H2. apply H6 to H5. case H3. apply H11 to H8. case H4. apply H16 to H13.
exists Q5. 
split. search.
exists P1. exists Q5.	
split. search. 

% applying the information from ReflexiviyTechnique 
case H9.				
case H19.

%  proving derivatives are related.
case H14.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Transitivity.
case H21.
% reflexivity case.
backchain CH.
% transitivity case.
  apply bisimUpToTrans_trans to H22 H23.
  apply bisimUpToTrans_sym to H25.
  apply bisimUpToTrans_trans to H15 H27.
  apply bisimUpToTrans_sym to H24.
  apply bisimUpToTrans_trans to H28 H29.
  apply bisimUpToTrans_trans to H26 H30.
backchain CH.

% Case of transitions from Q
%   searching for the suitable step from P. 

intros.	case H4. apply H7 to H5. case H3. apply H12 to H8. case H2. apply H17 to H13.
exists P5.
split. search.
exists P5.
exists Q1.				
split. search. 

% applying the information from ReflexiviyTechnique 
case H9.				
case H19.

% proving derivatives are related.
case H14.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
% Next code is specific of Bisimilarity up-to Transitivity.
case H21.
% reflexivity case.
backchain CH.
% transitivity case.
  apply bisimUpToTrans_trans to H22 H23.
  apply bisimUpToTrans_sym to H25.
  apply bisimUpToTrans_trans to H15 H27.
  apply bisimUpToTrans_sym to H24.
  apply bisimUpToTrans_trans to H28 H29.
  apply bisimUpToTrans_trans to H26 H30.
backchain CH.

% Remark, the "abstract" proof code for tranitivity_t does not depend on Bottom/Top (so they had to switch for bisim_t for transitions from Q).
% So, we could copy/paste the proof code of the case of transitions from P.


Theorem transitivity_sound_snd : is_sound_snd transitivity_t.
unfold.
intros.
apply bisim_refl with P = P.
apply bisim_refl with P = Q.
exists P.
exists Q.
search.


Theorem transitivity_sound : is_sound transitivity_t.
unfold.
intros.
apply transitivity_sound_snd.
case H2.
apply H3 to H1.
apply transitivity_sound_fst.
case H7.
backchain H8.


% Soundness of Bisimilarity up-to Context
% The development proceeds as follows:
% - We prove that CCS has faithful contexts (needed for substitutivity)
% - We prove substitutivity of the up-to context relation
% - We prove soundness of the up-to context technique.


Define context_t : proc -> proc -> proc -> proc -> prop by
  context_t P1 P2 Q1 Q2 := exists C, in_ctx C P2 P1 /\ in_ctx C Q2 Q1.

Define concat_ctx : ctx -> ctx -> ctx -> prop by 
	concat_ctx emptyCtx emptyCtx emptyCtx.

Theorem instanciate_context : forall C P, exists P1, in_ctx C P P1. skip. 
Theorem concat_ctx_thm : forall C1 C2 P1 P2 P3, in_ctx C1 P2 P1 -> in_ctx C2 P3 P2 -> exists C, concat_ctx C2 C1 C /\ in_ctx C P3 P1. skip. 
Theorem concat_ctxs_are_equal : forall C1 C2 C3 C4, concat_ctx C2 C1 C3 -> concat_ctx C2 C1 C4 -> C3 = C4. skip. 
Theorem process_ctxs_are_equal : forall C P Q1 Q2, in_ctx C P Q1 -> in_ctx C P Q2 -> Q1 = Q2. skip.
 
% Faithful contexts in CCS. 

Theorem faithful_contexts : forall C P P1 A R, in_ctx C P P1 -> one P1 A R ->
				(exists C', in_ctx C' P R /\ (forall Q Q1, exists R1, in_ctx C Q Q1 -> one Q1 A R1 /\ in_ctx C' Q R1)) \/
				(exists C' P2 B, one P B P2 /\ in_ctx C' P2 R /\ (forall Q Q2, one Q B Q2 -> (forall Q1, in_ctx C Q Q1 -> exists R1, one Q1 A R1 /\ in_ctx C' Q2 R1))).
induction on 1.
intros.
case H1.			% This will split over the contexts. 

% emptyCtx
right. exists emptyCtx. exists R. exists A. split. search. search. intros. case H4. exists Q2. search. 

% noHole
left.
exists (noHole R).
split. search. 
intros.  
exists R. 
intros. 
case H3.
search.


% par_ctx_l
case H2. 			% split for the 3 transitons of par.

%  (par P Q) -> (par P' Q) 
apply IH to H3 H4. 
case H5.			% here you have to reason on the possible 2 cases of faithful context that YOU have.

% left case
left. exists (par_ctx_l C' Q). split. search.
intros. 
apply instanciate_context with C = C1, P = Q1.
apply H7 with Q = Q1, Q1 = P2.
apply H9 to H8. 
exists (par R2 Q).
intros. case H12.
apply process_ctxs_are_equal to H8 H13.
split. search. search. 

% right case
right.
exists (par_ctx_l C' Q).
exists P2. exists B.
split. search. search. 
intros. 
apply H8 to H9.
apply instanciate_context with C = C1, P = Q1.
apply H11 to H12.
exists (par R2 Q).
case H10. 
apply process_ctxs_are_equal to H12 H15.
split. 
search.
search.


% (par P Q) -> (par P Q') 
left. 
exists (par_ctx_l C1 Q2). split. search. 
intros.
apply instanciate_context with C = C1, P = Q1. 
exists (par P2 Q2).
intros. 
case H6.
apply process_ctxs_are_equal to H5 H7.
split. search. search. 

% synchronization (par P Q) -> (par P' Q') 
apply IH to H3 H4. 
case H6.			% here you have to reason on the possible 2 cases of faithful context that YOU have.

% left case
left. exists (par_ctx_l C' Q2). split. search.
intros. 
apply instanciate_context with C = C1, P = Q1.
apply H8 with Q = Q1, Q1 = P2.
apply H10 to H9. 
exists (par R2 Q2).
intros.
case H13. 
apply process_ctxs_are_equal to H9 H14.
split. search. search. 

% right case
right.
exists (par_ctx_l C' Q2).
exists P2. exists B.
split. search. search. 
intros. 
apply H9 to H10. 
apply instanciate_context with C = C1, P = Q1.
apply H12 to H13.
exists (par R2 Q2).
case H11. 
apply process_ctxs_are_equal to H13 H16.
split. 
search.
search.



% par_ctx_r
case H2. 			% split for the 3 transitons of par.

% (par P Q) -> (par P Q') 
left. 
exists (par_ctx_r P4 C1). split. search. 
intros.
apply instanciate_context with C = C1, P = Q. 
exists (par P4 P3).
intros. 
case H6.
apply process_ctxs_are_equal to H5 H7.
split. search. search. 


%  (par P Q) -> (par P' Q) 
apply IH to H3 H4. 
case H5.			% here you have to reason on the possible 2 cases of faithful context that YOU have.

% left case
left. exists (par_ctx_r P2 C'). split. search.
intros. 
apply instanciate_context with C = C1, P = Q.
apply H7 with Q = Q, Q2 = P3.
apply H9 to H8. 
exists (par P2 R2).
intros. case H12.
apply process_ctxs_are_equal to H8 H13.
split. search. search. 

% right case
right.
exists (par_ctx_r P2 C').
exists P3. exists B.
split. search. search. 
intros. 
apply H8 to H9.
apply instanciate_context with C = C1, P = Q.
apply H11 to H12.
exists (par P2 R2).
case H10. 
apply process_ctxs_are_equal to H12 H15.
split. 
search.
search.


% synchronization (par P Q) -> (par P' Q') 
apply IH to H3 H5. 
case H6.			% here you have to reason on the possible 2 cases of faithful context that YOU have.

% left case
left. exists (par_ctx_r P4 C'). split. search.
intros. 
apply instanciate_context with C = C1, P = Q.
apply H8 with Q = Q, Q2 = P3.
apply H10 to H9. 
exists (par P4 R2).
intros.
case H13. 
apply process_ctxs_are_equal to H9 H14.
split. search. search. 

% right case
right.
exists (par_ctx_r P4 C').
exists P3. exists B.
split. search. search. 
intros. 
apply H9 to H10. 
apply instanciate_context with C = C1, P = Q.
apply H12 to H13.
exists (par P4 R2).
case H11. 
apply process_ctxs_are_equal to H13 H16.
split. 
search.
search.

% plus_ctx_l
case H2.				% This will split into the two cases of +.

% case P + Q -> P'.
apply IH to H3 H4. 
case H5.			% here you have to reason on the possible 2 cases of faithful context that YOU have.

% left
left. 
exists C'.
split. search.
intros. 
apply instanciate_context with C = C1, P = Q1.
apply H7 with Q = Q1, Q1 = P2.
apply H9 to H8. 
exists R2.
intros.
case H12. 
apply process_ctxs_are_equal to H13 H8.
split. search. search. 

% right
right. 
exists C'. 
exists P2. 
exists B.
split. search. search. 
intros. 
apply H8 to H9.
apply instanciate_context with C = C1, P = Q1.
apply H11 to H12.
exists R2.
case H10. 
apply process_ctxs_are_equal to H12 H15.
split. 
search.
search.

% case P + Q -> Q'.

left.
exists (noHole R).
split. search.
intros. 
exists R. 
intros. 
case H5.
search. 

% plus_ctx_r
case H2.				% This will split into the two cases of +.

% case P + Q -> P'.
left.
exists (noHole R).
split. search.
intros. 
exists R. 
intros. 
case H5.
search. 

% case P + Q -> Q'.

apply IH to H3 H4. 
case H5.			% here you have to reason on the possible 2 cases of faithful context that YOU have.

% left
left. 
exists C'.
split. search.
intros. 
apply instanciate_context with C = C1, P = Q.
apply H7 with Q = Q, Q1 = P3.
apply H9 to H8. 
exists R2.
intros.
case H12. 
apply process_ctxs_are_equal to H13 H8.
split. search. search. 

% right
right. 
exists C'. 
exists P3. 
exists B.
split. search. search. 
intros. 
apply H8 to H9.
apply instanciate_context with C = C1, P = Q.
apply H11 to H12.
exists R2.
case H10. 
apply process_ctxs_are_equal to H12 H15.
split. 
search.
search.

% act_ctx
left.
case H2.
exists C1.
split. search.
intros. 
apply instanciate_context with C = C1, P = Q.
exists P2. 
intros. 
case H5. 
apply process_ctxs_are_equal to H4 H6.
split. search. search. 



% Substitutivity of the up-to context relation. 

Theorem bisimK_is_subst_th : subst_rel (bisim_up_to context_t). 
unfold. coinduction. intros. unfold. 

% Transitions from P.
intros. 
apply faithful_contexts to H2 H4. 
case H5.				% it will split into the two cases. 

% First case
apply H7 with Q = Q, Q1 = Q'.
apply H8 to H3. 
exists R1. split. search. 
exists P1. exists R1. split. search.
backchain CH. 				%apply CH to H1 H3 H4 with P = P, Q = Q, C = C, P' = P1, Q' = Q1.

% Second case
% first, since P is bisim_context with Q, we can calculate the step for Q. 
case H1.
apply H9 to H6.
apply H8 to H11.			% this is to apply faithful context. 
apply H14 to H3.			% this is to apply faithful context.
exists R1. split. search.

case H12. 

% create the context. 
apply concat_ctx_thm to H7 H17.		% existence of the concat context.
apply concat_ctx_thm to H16 H18.	% existence of the concat context.
apply concat_ctxs_are_equal to H19 H21.	% the two are equal. 
exists P3. exists Q3. split. search. 
backchain CH. 

% Transitions from Q.
intros. 
apply faithful_contexts to H3 H4. 
case H5.				% it will split into the two cases. 

% First case
apply H7 with Q2 = P, Q3 = P'.
apply H8 to H2. 
exists R1. split. search. 
exists R1. exists Q1. split. search.
backchain CH. 				%apply CH to H1 H3 H4 with P = P, Q = Q, C = C, P' = P1, Q' = Q1.

% Second case
% first, since P is bisim_context with Q, we can calculate the step for P. 
case H1.
apply H10 to H6.
apply H8 to H11.			% this is to apply faithful context. 
apply H14 to H2.			% this is to apply faithful context.
exists R1. split. search.

case H12. 

% create the context. 
apply concat_ctx_thm to H7 H18.		% existence of the concat context.
apply concat_ctx_thm to H16 H17.	% existence of the concat context.
apply concat_ctxs_are_equal to H19 H21.	% the two are equal. 
exists P3. exists Q3. split. search. 
backchain CH. 

% Soundness of the up-to context technique. 

Theorem context_sound : is_sound context_t.
apply bisimK_is_subst_th. case H1. rename H2 to bisimK_is_subst.  
unfold. coinduction. intros. case H3. unfold.


% transitions from P. 
intros. apply H4 to H6. 
exists Q2. split. search. exists P1. exists Q2. split. search. 
case H8. 
   apply bisimK_is_subst to H9 H10 H11.
   backchain CH.

% transitions from Q. 
intros. apply H5 to H6. 
exists P2. split. search. exists P2. exists Q1. split. search. 
case H8. 
   apply bisimK_is_subst to H9 H10 H11.
   backchain CH.



% Soundness of Bisimilarity up-to Bisimilarity and Context.

Define bisim_context_t : proc -> proc -> proc -> proc -> prop by
        bisim_context_t P1 P3 Q1 Q3 := exists P2 Q2, bisim_t P1 P2 Q1 Q2 /\ context_t P2 P3 Q2 Q3. 

Theorem bisimBK_is_subst_th : subst_rel (bisim_up_to bisim_context_t). 
unfold. coinduction. intros. unfold. 

% Transitions from P.
intros. 
apply faithful_contexts to H2 H4. 
case H5.				% it will split into the two cases. 

% First case
apply H7 with Q = Q, Q1 = Q'.
apply H8 to H3. 
exists R1. split. search. 
exists P1. exists R1. 
split. unfold. exists P1. exists R1. split. unfold. backchain bisim_refl. backchain bisim_refl. 
unfold. exists emptyCtx. search. 
backchain CH. 		

% Second case
% first, since P is bisim_context with Q, we can calculate the step for Q. 
case H1.
apply H9 to H6.
apply H8 to H11.			% this is to apply faithful context. 
apply H14 to H3.			% this is to apply faithful context.
exists R1. split. search.

case H12. 
case H17.
case H18. 

apply bisim_is_subst_th. case H23. 
apply instanciate_context with C = C', P = P4.
apply instanciate_context with C = C', P = Q1.
apply H24 to H19 H7 H25.
apply H24 to H20 H16 H26.

exists P3. exists Q3. split. 
unfold. exists P5. exists P6. split. unfold. search. search. unfold. 

apply concat_ctx_thm to H25 H21.		% existence of the concat context.
apply concat_ctx_thm to H26 H22.	% existence of the concat context.
apply concat_ctxs_are_equal to H29 H31.	% the two are equal. 
exists C3. search. 
backchain CH. 

% Transitions from Q.
intros. 
apply faithful_contexts to H3 H4. 
case H5.				% it will split into the two cases. 

% First case
apply H7 with Q2 = P, Q3 = P'.
apply H8 to H2. 
exists R1. split. search. 
exists R1. exists Q1.
split. unfold. exists R1. exists Q1. split. unfold. backchain bisim_refl. backchain bisim_refl. 
unfold. exists emptyCtx. search. 
backchain CH. 		

% Second case
% first, since P is bisim_context with Q, we can calculate the step for P. 
case H1.
apply H10 to H6.
apply H8 to H11.			% this is to apply faithful context. 
apply H14 to H2.			% this is to apply faithful context.
exists R1. split. search.

case H12. 
case H17.
case H18. 

apply bisim_is_subst_th. case H23. 
apply instanciate_context with C = C', P = P4.
apply instanciate_context with C = C', P = Q2.
apply H24 to H19 H16 H25.
apply H24 to H20 H7 H26.

exists P3. exists Q3. split. 
unfold. exists P5. exists P6. split. unfold. search. search. unfold. 

apply concat_ctx_thm to H25 H21.		% existence of the concat context.
apply concat_ctx_thm to H26 H22.	% existence of the concat context.
apply concat_ctxs_are_equal to H29 H31.	% the two are equal. 
exists C3. search. 
backchain CH. 


% Soundness of the up-to bisimilarity and context technique. 

Theorem bisim_context_sound_fst : is_sound_fst bisim_context_t.
unfold. coinduction. intros. case H1. unfold.

% plain transitions from P.
%   searching for the suitable step from Q. 
intros.	case H2. apply H6 to H5. case H3. apply H11 to H8. case H4. apply H16 to H13.
exists Q5. 
split. search.
exists P1. exists Q5.	
split. search. 

% applying the information from ReflexiviyTechnique 
case H9.				
case H19.

apply bisimBK_is_subst_th. case H21. rename H22 to bisimBK_is_subst.  

%  proving derivatives are related.
case H14.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
case H23.
  apply bisim_trans to H10 H25.		% NOT copy paste. but calculated with first/bottom etc. 
  apply bisim_sym to H26.
  apply bisim_trans to H28 H20.
case H24. 
  apply bisimBK_is_subst to H15 H30 H31. 
backchain CH.   

% Case of transitions from Q
%   searching for the suitable step from P. 

intros.	case H4. apply H7 to H5. case H3. apply H12 to H8. case H2. apply H17 to H13.
exists P5.
split. search.
exists P5.
exists Q1.				
split. search. 

% applying the information from ReflexiviyTechnique 
case H9.				
case H19.

apply bisimBK_is_subst_th. case H21. rename H22 to bisimBK_is_subst.  

%  proving derivatives are related.
case H14.				% unfold of up-to technique: we observe what the up-to technique is about at this point. 
case H23.
  apply bisim_trans to H20 H25.		% NOT copy paste. but calculated with first/bottom etc. 
  apply bisim_sym to H26.
  apply bisim_trans to H28 H10.
case H24. 
  apply bisimBK_is_subst to H15 H30 H31. 
backchain CH.   


Theorem bisim_context_sound_snd : is_sound_snd bisim_context_t.
unfold.
intros.                                 
apply bisim_refl with P = P.
apply bisim_refl with P = Q.
exists P.
exists Q.
search.

Theorem bisim_context_sound : is_sound bisim_context_t.
unfold.
intros.
apply bisim_context_sound_snd.
case H2.
apply H3 to H1.
apply bisim_context_sound_fst.
case H7.
backchain H8.


% Characterization theorems for the soundness of up to techniques: 
%
%	Soundness of up to bisimilarity holds iff bisimilarity up to bisimilarity is an equivalence.	
%	Soundness of up to reflexivity and transitivity holds iff bisim up to reflexivity and transitivity is an equivalence.	
%	If bisim is a substitutive, then the soundness of up to context technique holds iff bisim up to context is a substitutive.
%	If bisim is a congruence, then the soundness of up to bisimilarity and context technique holds iff bisim up to bisimilarity and context is substitutive.
%

Define upTo1ImpliesUpTo2 : (proc -> proc -> proc -> proc -> prop) -> (proc -> proc -> proc -> proc -> prop) -> prop by
   upTo1ImpliesUpTo2 Upto1 Upto2 := forall P1 P2 Q1 Q2, Upto1 P1 P2 Q1 Q2 -> Upto2 P1 P2 Q1 Q2.

Define bisim1ImpliesBisim2 : (proc -> proc -> proc -> proc -> prop) -> (proc -> proc -> proc -> proc -> prop) -> prop by
    bisim1ImpliesBisim2 Upto1 Upto2 := forall P Q, upTo1ImpliesUpTo2 Upto1 Upto2 -> bisim_up_to Upto1 P Q -> bisim_up_to Upto2 P Q.

%   bisim1ImpliesBisim2 Upto1 Upto2 := upTo1ImpliesUpTo2 Upto1 Upto2 -> (forall P Q, bisim_up_to Upto1 P Q -> bisim_up_to Upto2 P Q).
% With the above more natural definition, we have CH : upTo1ImpliesUpTo2 refl_t context_t -> (forall P Q, bisim_up_to refl_t P Q -> bisim_up_to context_t P Q +)
% that does not unify with the goal bisim_up_to context_t P3 Q3.
% We cannot do coinduction only on the subformula that starts from (forall P Q, ...) because the first "intros" introduce everything until bisim_up_to context_t P Q.

% Remarks:
% 	For these theorems, the same proof is copy/pasted. I.e., 
% 	Therefore, it is sufficient to prove just that the up-to technique predicate implies the other, with upTo1ImpliesUpTo2.
% 	This theorem should be proved in Second Order Abella, because it works for every Upto1 Upto2.
% 	We need it only to prove that the bisim up to is a refinement of bisim. 
%	However, it can be used for instance to show that bisimBK is a refinement of bisimK. (provided that you prove upTo1ImpliesUpTo2 context_t bisim_context_t)

Theorem bisim_implies_bisimB : bisim1ImpliesBisim2 refl_t bisim_t.
unfold. coinduction. intros. unfold. 
intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 
intros. case H2. apply H5 to H3. exists P2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 

Theorem bisim_implies_bisimT : bisim1ImpliesBisim2 refl_t transitivity_t.
unfold. coinduction. intros. unfold. 
intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 
intros. case H2. apply H5 to H3. exists P2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 

Theorem bisim_implies_bisimK : bisim1ImpliesBisim2 refl_t context_t.
unfold. coinduction. intros. unfold. 
intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 
intros. case H2. apply H5 to H3. exists P2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 

Theorem bisim_implies_bisimBK : bisim1ImpliesBisim2 refl_t bisim_context_t.
unfold. coinduction. intros. unfold. 
intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 
intros. case H2. apply H5 to H3. exists P2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 

Theorem bisimB_implies_bisimBK : bisim1ImpliesBisim2 bisim_t bisim_context_t.
unfold. coinduction. intros. unfold. 
intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 
intros. case H2. apply H5 to H3. exists P2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 

Theorem bisimK_implies_bisimBK : bisim1ImpliesBisim2 context_t bisim_context_t.
unfold. coinduction. intros. unfold. 
intros. case H2. apply H4 to H3. exists Q2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 
intros. case H2. apply H5 to H3. exists P2. split. search. exists P3. exists Q3. split. 
% proving context_t P1 P3 Q2 Q3 from bisim_up_to refl_t P3 Q3 thanks to upTo1ImpliesUpTo2.
apply H1. case H9. apply H10 to H7. search. 
backchain CH. 


% We prove that the reflexivity technique is a special case of the techniques here considered.
% This is sufficient to show that bisimilarity is refined by the bisimilarity up to the techniques here considered. 
% The following proofs necessary depends on the peculiarities of the technique at hand.
% But at least, we can isolated and confined here the core of it.
% And the user needs not to use the coinduction side of the proof, which is handled automatic from the proof above. 

Theorem upToBisim_implie_upToBisimB : upTo1ImpliesUpTo2 refl_t bisim_t.
unfold. intros. case H1. unfold. backchain bisim_refl. backchain bisim_refl.

Theorem upToBisim_implie_upToBisimT : upTo1ImpliesUpTo2 refl_t transitivity_t.
unfold. intros. case H1. unfold. left. search. 

Theorem upToBisim_implie_upToBisimK : upTo1ImpliesUpTo2 refl_t context_t.
unfold. intros. case H1. search.

Theorem upToBisim_implie_upToBisimBK : upTo1ImpliesUpTo2 refl_t bisim_context_t.
unfold. intros. case H1. unfold. exists P2. exists Q2. split. unfold. backchain bisim_refl. backchain bisim_refl. search. 

Theorem upToBisimB_implie_upToBisimBK : upTo1ImpliesUpTo2 bisim_t bisim_context_t.
unfold. intros. case H1. unfold. exists P2. exists Q2. split. unfold. search. search. search.

Theorem upToBisimK_implie_upToBisimBK : upTo1ImpliesUpTo2 context_t bisim_context_t.
unfold. intros. case H1. unfold. exists P1. exists Q1. split. unfold. backchain bisim_refl. backchain bisim_refl. search. 

Define bisim_is_equiv : prop by bisim_is_equiv := equiv_rel (bisim_up_to refl_t).
Define bisimB_is_equiv : prop by bisimB_is_equiv := equiv_rel (bisim_up_to bisim_t).
Define bisimT_is_equiv : prop by bisimT_is_equiv := equiv_rel (bisim_up_to transitivity_t).

Define bisim_is_subst : prop by bisim_is_subst := subst_rel (bisim_up_to refl_t).
Define bisimK_is_subst : prop by bisimK_is_subst := subst_rel (bisim_up_to context_t).
Define bisimBK_is_subst : prop by bisimBK_is_subst := subst_rel (bisim_up_to bisim_context_t).

Define bisim_is_cong : prop by bisim_is_cong := cong_rel (bisim_up_to refl_t).
Define bisimK_is_cong : prop by bisimK_is_cong := cong_rel (bisim_up_to context_t).
Define bisimBK_is_cong : prop by bisimBK_is_cong := cong_rel (bisim_up_to bisim_context_t).

% Completeness theorems for the characterization theorems above. 

Theorem bisimB_soundIff_completeness : bisim_is_equiv -> is_sound bisim_t -> bisimB_is_equiv.
intros. unfold. unfold. 
intros. case H1. case H3. apply H4 with P = P. apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. backchain implies.
intros. case H2. apply H4 to H3. case H1. case H6. apply H8 to H5. apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. backchain implies.
intros. case H2. apply H5 to H3. apply H5 to H4. case H1. case H8. apply H11 to H6 H7. apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. backchain implies.

Theorem bisimT_soundIff_completeness : bisim_is_equiv -> is_sound transitivity_t -> bisimT_is_equiv.
intros. unfold. unfold. 
intros. case H1. case H3. apply H4 with P = P. apply upToBisim_implie_upToBisimT. loadLemma : apply bisim_implies_bisimT. implies : case loadLemma. backchain implies.
intros. case H2. apply H4 to H3. case H1. case H6. apply H8 to H5. apply upToBisim_implie_upToBisimT. loadLemma : apply bisim_implies_bisimT. implies : case loadLemma. backchain implies.
intros. case H2. apply H5 to H3. apply H5 to H4. case H1. case H8. apply H11 to H6 H7. apply upToBisim_implie_upToBisimT. loadLemma : apply bisim_implies_bisimT. implies : case loadLemma. backchain implies.

Theorem bisimK_and_subst_completeness : bisim_is_subst -> is_sound context_t -> bisimK_is_subst.
intros. unfold. unfold. intros. case H2. apply H6 to H3. case H1. case H8. apply H9 to H7 H4 H5. apply upToBisim_implie_upToBisimK. loadLemma : apply bisim_implies_bisimK. implies : case loadLemma. backchain implies.

Theorem bisimBK_and_subst_completeness : bisim_is_cong -> is_sound bisim_context_t -> bisimBK_is_subst.
intros. unfold. unfold. 
intros. case H2. apply H6 to H3. case H1. case H8. case H10. apply H11 to H7 H4 H5. apply upToBisim_implie_upToBisimBK. loadLemma : apply bisim_implies_bisimBK. implies : case loadLemma. backchain implies.

% Soundness theorems for the characterization theorems above. 

Theorem bisimB_soundIff_soundness : bisimB_is_equiv -> bisim_is_equiv -> is_sound bisim_t.
intros. unfold. coinduction. intros. case H3. unfold.
% transitions from P. 
intros. apply H4 to H6. 
exists Q2. split. search. exists P1. exists Q2. split. search.

case H1.				% unfold on bisimBK_is_cong
case H10.				% unfold on bisimBK_is_cong

case H8.				% unfold the upto technique.

upToImplies: apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. 
apply implies to upToImplies H14.
apply implies to upToImplies H15.
	apply H13 to H16 H9.		% transitivity First Middle in New.
	apply H12 to H17. 		% symmetry Second in SecondSym. 
	apply H13 to H18 H19.		% transitivity New SecondSym.
backchain CH.

% transitions from Q. 
intros. apply H5 to H6.
exists P2. split. search. exists P2. exists Q1. split. search.

case H1.				% unfold on bisimBK_is_cong
case H10.				% unfold on bisimBK_is_cong

case H8.				% unfold the upto technique.
upToImplies: apply upToBisim_implie_upToBisimB. loadLemma : apply bisim_implies_bisimB. implies : case loadLemma. 
apply implies to upToImplies H14.
apply implies to upToImplies H15.
	apply H13 to H16 H9.		% transitivity First Middle in New.
	apply H12 to H17. 		% symmetry Second in SecondSym. 
	apply H13 to H18 H19.		% transitivity New SecondSym.
backchain CH.

Theorem bisimT_soundIff_completeness : bisimT_is_equiv -> bisim_is_equiv -> is_sound transitivity_t.
intros. unfold. coinduction. intros. case H3. unfold.
% transitions from P. 
intros. apply H4 to H6. 
exists Q2. split. search. exists P1. exists Q2. split. search.

case H1.				% unfold on bisimBK_is_cong
case H10.				% unfold on bisimBK_is_cong

case H8.				% unfold the upto technique.
case H14.

% reflexivity case. 
backchain CH.

% transitivity case. 
		apply H13 to H15 H16.
		apply H13 to H17 H18.
		apply H13 to H19 H9.
		apply H12 to H20.
		apply H13 to H21 H22.
backchain CH.

% transitions from Q. 
intros. apply H5 to H6.
exists P2. split. search. exists P2. exists Q1. split. search.

case H1.				% unfold on bisimBK_is_cong
case H10.				% unfold on bisimBK_is_cong

case H8.				% unfold the upto technique.
case H14.

% reflexivity case. 
backchain CH.

% transitivity case. 
		apply H13 to H15 H16.
		apply H13 to H17 H18.
		apply H13 to H19 H9.
		apply H12 to H20.
		apply H13 to H21 H22.
backchain CH.


Theorem bisimK_and_subst_soundness : bisimK_is_subst -> bisim_is_cong -> is_sound context_t.
intros. unfold. coinduction. intros. case H3. unfold.
% transitions from P. 
intros. apply H4 to H6. 
exists Q2. split. search. exists P1. exists Q2. split. search.

case H1.				% unfold on bisimBK_is_subst
case H10.				% unfold on bisimBK_is_subst

case H8.				% unfold the upto technique.
	apply H11 to H9 H12 H13.	% congruence of Middle in MiddleNew. 
backchain CH.

% transitions from Q. 
intros. apply H5 to H6.
exists P2. split. search. exists P2. exists Q1. split. search.

case H1.				% unfold on bisimBK_is_subst
case H10.				% unfold on bisimBK_is_subst

case H8.				% unfold the upto technique.
	apply H11 to H9 H12 H13.	% congruence of Middle in MiddleNew. 
backchain CH.

Theorem bisimBK_and_subst_soundness_fst : bisimBK_is_subst -> bisim_is_cong -> is_sound_fst bisim_context_t.  
intros. unfold. coinduction. intros. case H1. case H4. case H2. case H6. case H7. case H3. unfold.
% transitions from P. 
intros. case H12. apply H16 to H15. case H13. apply H21 to H18. case H14. apply H26 to H23. 

exists Q5. split. search. exists P1. exists Q5.	 split. search. 

% applying the information from ReflexiviyTechnique 
case H19.				
case H29.

%  proving derivatives are related.
case H24.

% Next code is the specific of up-to bisimilarity. 
case H31.
	apply H11 to H20 H33.
	apply H10 to H34.
	apply H11 to H36 H30.
% Next code is the specific of up-to context. 
case H32.
	apply H5 to H25 H38 H39.
backchain CH.

% transitions from Q. 
intros. case H14. apply H17 to H15. case H13. apply H22 to H18. case H12. apply H27 to H23.

exists P5. split. search. exists P5. exists Q1.	split. search. 

% applying the information from ReflexiviyTechnique 
case H19.				
case H29.

%  proving derivatives are related.
case H24.

% Next code is the specific of up-to bisimilarity. 
case H31.
	apply H11 to H30 H33.
	apply H10 to H34.
	apply H11 to H36 H20.
% Next code is the specific of up-to context. 
case H32.
	apply H5 to H25 H38 H39.
backchain CH.


Theorem bisimBK_and_subst_soundness_snd : bisimBK_is_subst -> bisim_is_cong -> is_sound_snd bisim_context_t.
intros. unfold. intros. case H2. case H4. case H5. apply H7 with P = P. apply H7 with P = Q. exists P. exists Q. search. 
Theorem bisimBK_and_subst_soundness : bisimBK_is_subst -> bisim_is_cong -> is_sound bisim_context_t.
intros. unfold. intros. apply bisimBK_and_subst_soundness_snd. apply H4 to H1 H2. case H5. apply H6 to H3. apply bisimBK_and_subst_soundness_fst. apply H10 to H1 H2. case H11. backchain H12.


% Proof that bisimB is an equivalence, and therefore that bisimilarity up to bisimilarity is sound. 

Theorem subst_in_bisimB : forall P Q1 Q2, bisim_up_to bisim_t P Q1 -> bisim_up_to refl_t Q1 Q2 -> bisim_up_to bisim_t P Q2.
coinduction. intros. unfold. 
intros. case H1. apply H4 to H3. case H2. apply H9 to H6. exists Q5. split. search. case H12. exists P3. exists Q6. case H7. split. unfold. search. backchain bisim_refl. apply bisim_sym to H15. apply bisim_trans to H16 H13. backchain CH.
intros. case H2. apply H5 to H3. case H1. apply H10 to H6. exists P1. split. search. case H7. exists P4. exists Q4. case H12. split. unfold. search. backchain bisim_refl. apply bisim_sym to H15. apply bisim_trans to H16 H8. backchain CH.

Theorem bisimB_is_equiv_th : equiv_rel (bisim_up_to bisim_t).
unfold.
% reflexivity
coinduction. intros. unfold. 
% transitions from P and Q.
intros. exists P1. split. search. exists P1. exists P1. split. unfold. backchain bisim_refl. backchain bisim_refl. backchain CH.
intros. exists Q1. split. search. exists Q1. exists Q1. split. unfold. backchain bisim_refl. backchain bisim_refl. backchain CH.

% symmetry
coinduction. intros. unfold.
% transitions from P and Q. 
intros. case H1. apply H4 to H2. exists P2. split. search. exists Q3. exists P3. split. case H6. unfold. search. search. backchain CH.
intros. case H1. apply H3 to H2. exists Q2. split. search. exists Q3. exists P3. split. case H6. unfold. search. search. backchain CH.

% transitivity
coinduction. intros. unfold.
% transitions from P and Q. 
intros. case H1. apply H4 to H3. case H2. apply H9 to H6. exists Q1. split. search. exists P3. exists Q4. case H7. case H12. split. unfold. search. search. 
apply bisim_sym to H15. apply bisim_trans to H18 H16. apply subst_in_bisimB to H8 H19. backchain CH with P = P3, Q = P2, R = Q4.
intros. case H2. apply H5 to H3. case H1. apply H10 to H6. exists P1. split. search. exists P4. exists Q3. case H7. case H12. split. unfold. search. search. 
apply bisim_sym to H17. apply bisim_trans to H18 H14. apply subst_in_bisimB to H13 H19. backchain CH with P = P4, Q = P3, R = Q3.



% --- EXAMPLES --- %
%
% For bisimilarity up-to bisimilarity:
% -- !(a(c) + b(c)) is bisimilar to !(a(c)) || !(b(c))
% -- !!a is bisimilar to !a
%
% For bisimilarity up-to bisimilarity and context:
% -- !(a(c).P + b(c).P) is bisimilar to !(a(c)).P || !(b(c)).P
% -- !!a.P is bisimilar to !a.P

% For bisimilarity up-to bisimilarity:

% Example: !(a(c) + b(c)) is bisimilar to !(a(c)) || !(b(c))
% Instead of showing a bisimulation between the two processes, we prove that they are bisimilar up-to bisimilarity.
% Notice that proving the ordinary bisimilarity of those two processes requires an infinite relation.  

Theorem bisim_par_zeroEl : forall P,
bisim_up_to refl_t (par P null) P. skip.

Theorem bisim_par_comm : forall P Q,
bisim_up_to refl_t (par P Q) (par Q P).skip.

Theorem bisim_par_assoc : forall P Q R,
bisim_up_to refl_t (par (par P Q) R) (par P (par Q R)).skip.

Theorem bisim_par_cong_right : forall P Q R, 
bisim_up_to refl_t P Q -> bisim_up_to refl_t (par P R) (par Q R).skip. 

Theorem bisim_par_cong_left : forall P Q R, 
bisim_up_to refl_t P Q -> bisim_up_to refl_t (par R P) (par R Q).skip. 

Theorem bisim_repl_absorb : forall P, 
bisim_up_to refl_t (par (repl P) P) (repl P).skip.


Theorem example_1_bisim : forall A B, bisim_up_to bisim_t (repl (plus (act (dn A) null) (act (dn B) null))) (par (repl (act (dn A) null)) (repl (act (dn B) null))).
coinduction. intros. unfold.					

% It will split to the 2 cases of bisim.
% - transitions from P: (repl (plus (act (dn A) null) (act (dn B) null))).
% - transitions from Q: (par (repl (act (dn A) null)) (repl (act (dn B) null))).

% Case of transitions from P. 
% First case: the a() input move. 

intros. case H1. case H2. case H3.	
exists (par (par (repl (act (dn A) null)) null) (repl (act (dn B) null))).	% we need to give the result of the transition. 
split. search.

exists (repl (plus (act (dn A) null) (act (dn B) null))).
exists (par (repl (act (dn A) null)) (repl (act (dn B) null))).
split.					

% first we have to prove they are related by the technique.

unfold.
apply bisim_par_zeroEl with P = (repl (plus (act (dn A) null) (act (dn B) null))).
search.
apply bisim_par_zeroEl with P = (repl (act (dn A) null)).
apply bisim_par_cong_right to H4 with R = (repl (act (dn B) null)).          
search.

% and then, that they are related by bisimUpTo upToBisimilarity.
backchain CH. 

% Second case: the b() input move. 

case H3.
exists (par (repl (act (dn A) null)) (par (repl (act (dn B) null)) null)).
split. search.

exists (repl (plus (act (dn A) null) (act (dn B) null))).
exists (par (repl (act (dn A) null)) (repl (act (dn B) null))).
intros. split.

% first we have to prove they are related by the technique.

unfold.
apply bisim_par_zeroEl with P = (repl (plus (act (dn A) null) (act (dn B) null))).
search.
apply bisim_par_zeroEl with P = (repl (act (dn B) null)).
apply bisim_par_cong_left to H4 with R = (repl (act (dn A) null)).          
search. 

% and then, that they are related by bisimUpTo upToBisimilarity.
backchain CH.

% Now, the proof will explore the possibility of interaction because of the communication rule of the parallel operator.
% This case is not possible as both (act (dn A) null) and (act (dn B) null)) perform an input. 
% Therefore, this case will be discharged when we reach the "leaves", i.e. one (act (dn A) null) up X ?
case H2. case H4. case H4.

% Case of transitions from Q. 
% First case: the a() input move. 
intros. case H1. case H2. case H3.

exists (par (repl (plus (act (dn A) null) (act (dn B) null))) null).
split. search.

exists (repl (plus (act (dn A) null) (act (dn B) null))).
exists (par (repl (act (dn A) null)) (repl (act (dn B) null))).
split.

% first we have to prove they are related by the technique.
unfold.
apply bisim_par_zeroEl with P = (repl (plus (act (dn A) null) (act (dn B) null))).
search.
apply bisim_par_zeroEl with P = (repl (act (dn A) null)).
apply bisim_par_cong_right to H4 with R = (repl (act (dn B) null)).          
search. 

% and then, that they are related by bisimUpTo upToBisimilarity.
backchain CH.

% Now, the proof will explore the case of interaction because of the communication rule of the parallel operator.
% This case will be discharged
case H3.

% Second case: the b() input move. 

case H2. case H3.

exists (par (repl (plus (act (dn A) null) (act (dn B) null))) null).
split. search.

exists (repl (plus (act (dn A) null) (act (dn B) null))).
exists (par (repl (act (dn A) null)) (repl (act (dn B) null))).
split.

% first we have to prove they are related by the technique.
unfold.
apply bisim_par_zeroEl with P = (repl (plus (act (dn A) null) (act (dn B) null))).
search.
apply bisim_par_zeroEl with P = (repl (act (dn B) null)).
apply bisim_par_cong_left to H4 with R = (repl (act (dn A) null)).          
search. 

% and then, that they are related by bisimUpTo upToBisimilarity.
backchain CH.

% Other cases for interaction that will be discharged. 
case H3. case H2. case H4.


% Example: !!a is bisimilar to !a.
% Instead of showing a bisimulation between the two processes, we prove that they are bisimilar up-to bisimilarity.
% Notice that proving the ordinary bisimilarity of those two processes requires an infinite relation.  

Theorem example_2_bisim : forall A, bisim_up_to bisim_t (repl (repl (act (dn A) null))) (repl (act (dn A) null)).
coinduction. intros. unfold.

% It will split to the 2 cases of bisim.
% - transitions from P: (repl (repl (act (dn A) null)))
% - transitions from Q: (repl (act (dn A) null)).

% Case of transitions from P. 
intros. case H1. case H2. case H3.

exists (par (repl (act (dn A) null)) null).
split. search.

exists (repl (repl (act (dn A) null))).
exists (repl (act (dn A) null)).
split.

% first we have to prove they are related by the technique.
unfold.
apply bisim_par_zeroEl with P = (repl (act (dn A) null)).
apply bisim_par_cong_left to H4 with R = (repl (repl (act (dn A) null))).
apply bisim_repl_absorb with P = (repl (act (dn A) null)).
apply bisim_trans to H5 H6.
search.
apply bisim_par_zeroEl with P = (repl (act (dn A) null)).
search.

% and then, that they are related by bisimUpTo upToBisimilarity.
backchain CH.

% Now, the proof will explore the case of interaction because of the communication rule of the parallel operator.
% Some cases for interaction that will be discharged. 
case H3. case H2. case H4.

% Case of transitions from Q. 
intros. case H1. case H2.

exists (par (repl (repl (act (dn A) null))) (par (repl (act (dn A) null)) null)).
split. search.

exists (repl (repl (act (dn A) null))).
exists (repl (act (dn A) null)).
split.

% first we have to prove they are related by the technique.
unfold.
apply bisim_par_zeroEl with P = (repl (act (dn A) null)).
apply bisim_par_cong_left to H3 with R = (repl (repl (act (dn A) null))).
apply bisim_repl_absorb with P = (repl (act (dn A) null)).
apply bisim_trans to H4 H5.
search.
apply bisim_par_zeroEl with P = (repl (act (dn A) null)).
search.

% and then, that they are related by bisimUpTo upToBisimilarity.
backchain CH.

% An other case for interaction that will be discharged. 
case H2.


% For bisimilarity up-to bisimilarity and context:

% Example: !(a(c).P + b(c).P) is bisimilar to !(a(c).P) || !(b(c).P)
% Instead of showing a bisimulation between the two processes, we prove that they are bisimilar up-to bisimilarity and context.
% Notice that proving the ordinary bisimilarity of those two processes requires an infinite relation.  

Theorem example_1_context : forall A B P, bisim_up_to bisim_context_t (repl (plus (act (dn A) P) (act (dn B) P))) (par (repl (act (dn A) P)) (repl (act (dn B) P))).
coinduction. intros. unfold.					

% It will split to the 2 cases of bisim.
% - transitions from P (of the bisim def): (repl (plus (act (dn A) P) (act (dn B) P))).
% - transitions from Q (of the bisim def): (par (repl (act (dn A) P)) (repl (act (dn B) P))).

% Case of transitions from P (of the bisim def). 
% First case: the a() input move. 

intros. case H1. case H2. case H3.	
exists (par (par (repl (act (dn A) P)) P) (repl (act (dn B) P))).	% we need to give the result of the transition. 
split. search.

exists (repl (plus (act (dn A) P) (act (dn B) P))).
exists (par (repl (act (dn A) P)) (repl (act (dn B) P))).
split.					

% first we have to prove they are related by the technique.
% bisim_t
unfold. 
exists (par (repl (plus (act (dn A) P) (act (dn B) P))) P).
exists (par (par (repl (act (dn A) P)) (repl (act (dn B) P))) P).
split.
unfold. 
apply bisim_refl with P = (par (repl (plus (act (dn A) Q) (act (dn B) Q))) Q).
search.
apply bisim_par_comm with P = P, Q = (repl (act (dn B) Q)).
apply bisim_par_cong_left to H4 with R = (repl (act (dn A) Q)).
apply bisim_par_assoc with P = (repl (act (dn A) Q)), Q = P, R = (repl (act (dn B) Q)).
apply bisim_par_assoc with P = (repl (act (dn A) Q)), Q = (repl (act (dn B) Q)), R = P.
apply bisim_trans to H6 H5.
apply bisim_sym to H7.
apply bisim_trans to H8 H9.
search.

% context_t
search.

% and then, that they are related by bisimUpTo upToBisimAndContext.
backchain CH. 

% First case: the b() input move. 
case H3.

exists (par (repl (act (dn A) P)) (par (repl (act (dn B) P)) P)).	% we need to give the result of the transition. 
split. search.

exists (repl (plus (act (dn A) P) (act (dn B) P))).
exists (par (repl (act (dn A) P)) (repl (act (dn B) P))).
split.					

% first we have to prove they are related by the technique.
% bisim_t
unfold. 
exists (par (repl (plus (act (dn A) P) (act (dn B) P))) P).
exists (par (par (repl (act (dn A) P)) (repl (act (dn B) P))) P).
split.
unfold. 
apply bisim_refl with P = (par (repl (plus (act (dn A) Q) (act (dn B) Q))) Q).
search.
apply bisim_par_assoc with P = (repl (act (dn A) Q)), Q = (repl (act (dn B) Q)), R = Q.
apply bisim_sym to H4.
search.

% context_t
search. 

% and then, that they are related by bisimUpTo upToBisimAndContext.
backchain CH.

% An other case for interaction that will be discharged. 
case H2. case H4. case H4. 

% Case of transitions from Q (of the bisim def). 
% First case: the a() input move. 
intros. case H1. case H2. case H3.

exists (par (repl (plus (act (dn A) P) (act (dn B) P))) P).
split. search.

exists (repl (plus (act (dn A) P) (act (dn B) P))).
exists (par (repl (act (dn A) P)) (repl (act (dn B) P))).
split.					

% first we have to prove they are related by the technique.
% bisim_t
unfold. 
exists (par (repl (plus (act (dn A) P) (act (dn B) P))) P).
exists (par (par (repl (act (dn A) P)) (repl (act (dn B) P))) P).
split.
unfold.
apply bisim_refl with P = (par (repl (plus (act (dn A) Q) (act (dn B) Q))) Q).
search.

apply bisim_par_comm with P = Q, Q = (repl (act (dn B) Q)).
apply bisim_par_cong_left to H4 with R = (repl (act (dn A) Q)).
apply bisim_par_assoc with P = (repl (act (dn A) Q)), Q = Q, R = (repl (act (dn B) Q)).
apply bisim_par_assoc with P = (repl (act (dn A) Q)), Q = (repl (act (dn B) Q)), R = Q.
apply bisim_trans to H6 H5.
apply bisim_sym to H7.
apply bisim_trans to H8 H9.
search.

% context_t
search.

% and then, that they are related by bisimUpTo upToBisimAndContext.
backchain CH.

% An other case for interaction that will be discharged. 
case H3.

% First case: the b() input move. 
case H2. case H3.

exists (par (repl (plus (act (dn A) P) (act (dn B) P))) P).
split. search.

exists (repl (plus (act (dn A) P) (act (dn B) P))).
exists (par (repl (act (dn A) P)) (repl (act (dn B) P))).
split.					

% first we have to prove they are related by the technique.
% bisim_t
unfold. 
exists par (repl (plus (act (dn A) P) (act (dn B) P))) Q.
exists par (par (repl (act (dn A) P)) (repl (act (dn B) P))) Q.
split.
unfold.
apply bisim_refl with P = (par (repl (plus (act (dn A) P) (act (dn B) P))) Q).
search.
apply bisim_par_assoc with P = (repl (act (dn A) P)), Q = (repl (act (dn B) P)), R = Q.
apply bisim_sym to H4.
search.

% context_t
search.

% and then, that they are related by bisimUpTo upToBisimAndContext2.
backchain CH.

% Some other case for interaction that will be discharged. 
case H3. case H2. case H4.


% Example: !!a.P is bisimilar to !a.P.
% Instead of showing a bisimulation between the two processes, we prove that they are bisimilar up-to bisimilarity and context.
% Notice that proving the ordinary bisimilarity of those two processes requires an infinite relation.  

Theorem example_2_context : forall A P, bisim_up_to bisim_context_t (repl (repl (act (dn A) P))) (repl (act (dn A) P)).
coinduction. intros. unfold.

% It will split to the 2 cases of bisim.
% - transitions from P: (repl (repl (act (dn A) P)))
% - transitions from Q: (repl (act (dn A) P)).

% Case of transitions from P. 
intros. case H1. case H2. case H3.

exists (par (repl (act (dn A) P)) P).
split. search.

exists (repl (repl (act (dn A) P))).
exists (repl (act (dn A) P)).
split.

% first we have to prove they are related by the technique.
% bisim_t
unfold. 
exists (par (repl (repl (act (dn A) P))) P).
exists (par (repl (act (dn A) P)) P).
split.
unfold.
apply bisim_repl_absorb with P = (repl (act (dn A) P)).
apply bisim_par_cong_right to H4 with R = P.
apply bisim_par_assoc with P = (repl (repl (act (dn A) P))), Q = (repl (act (dn A) P)), R = P.
apply bisim_sym to H6.
apply bisim_trans to H7 H5.
search.
apply bisim_refl with P = (par (repl (act (dn A) P)) P).
search.

% context_t
search.

% and then, that they are related by bisimUpTo upToBisimAndContext.
backchain CH.

% Some other case for interaction that will be discharged. 
case H3. case H2. case H4.

% Case of dn transitions from Q.
intros. case H1. case H2.

exists (par (repl (repl (act (dn A) P))) (par (repl (act (dn A) P)) P)).
split. search.

exists (repl (repl (act (dn A) P))).
exists (repl (act (dn A) P)).
split.

% first we have to prove they are related by the technique.
% bisim_t
unfold. 
exists (par (repl (repl (act (dn A) P))) P).
exists (par (repl (act (dn A) P)) P).
split.
unfold.
apply bisim_repl_absorb with P = (repl (act (dn A) P)).
apply bisim_par_cong_right to H3 with R = P.
apply bisim_par_assoc with P = (repl (repl (act (dn A) P))), Q = (repl (act (dn A) P)), R = P.
apply bisim_sym to H5.
apply bisim_trans to H6 H4.
search.
apply bisim_refl with P = (par (repl (act (dn A) P)) P).
search.

% context_t
search.

% and then, that they are related by bisimUpTo upToBisimAndContext.
backchain CH.

% An other case for interaction that will be discharged. 
case H2.




