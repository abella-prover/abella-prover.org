
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Abella: Specification "bred_alt". - Details</title>
<link href="/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="/images/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="/images/favicon.ico"
        type="image/x-icon" />
</head>

<body>

<div id="logo-small">
<a href="/index.html">
<img src="/images/logo-small.png"/>
</a>
</div>

<div class="section">
Welcome to Abella 2.0.5-dev.
<a name="1"></a>
<pre class="code">
Abella < <b>Specification "bred_alt".</b>
Reading specification "bred_alt".

</pre>
<a name="2"></a>
<pre class="code">
Abella < <b>Close tm, p.</b>

</pre>
<a name="3"></a>
<pre class="code">
Abella < <b>Define ctx2 : olist -> olist -> prop by 
ctx2 nil nil;
nabla x p, ctx2 (bred x x :: G) (path x p :: D) := ctx2 G D;
nabla x, ctx2 ((pi u\bred N u => bred x u) :: G) ((pi q\path N q => path x q) :: D) := ctx2 G D.</b>

</pre>
<a name="4"></a>
<pre class="code">
Abella < <b>Define name : tm -> prop by 
nabla n, name n.</b>

</pre>
<a name="5"></a>
<pre class="code">
Abella < <b>Define fresh : tm -> tm -> prop by 
nabla n, fresh n X.</b>

</pre>
<a name="6"></a>
<pre class="code">
Abella < <b>Define pname : p -> prop by 
nabla p, pname p.</b>

</pre>
<a name="7"></a>
<pre class="code">
Abella < <b>Define btctx : olist -> olist -> prop by 
btctx nil nil;
nabla x, btctx (bred x x :: L) (tm x :: K) := btctx L K.</b>

</pre>
<a name="8"></a>
<pre class="code">
Abella < <b>Theorem btctx_mem1 : 
forall L K F, btctx L K -> member F K -> (exists X, F = tm X /\ name X).</b>

</pre>
<a name="9"></a>
<pre class="code">

============================
 forall L K F, btctx L K -> member F K -> (exists X, F = tm X /\ name X)

btctx_mem1 < <b>induction on 1.</b>
</pre>
<a name="10"></a>
<pre class="code">

IH : forall L K F, btctx L K * -> member F K ->
       (exists X, F = tm X /\ name X)
============================
 forall L K F, btctx L K @ -> member F K -> (exists X, F = tm X /\ name X)

btctx_mem1 < <b>intros.</b>
</pre>
<a name="11"></a>
<pre class="code">

Variables: L K F
IH : forall L K F, btctx L K * -> member F K ->
       (exists X, F = tm X /\ name X)
H1 : btctx L K @
H2 : member F K
============================
 exists X, F = tm X /\ name X

btctx_mem1 < <b>case H1.</b>
</pre>
<a name="12"></a>
<pre class="code">
Subgoal 1:

Variables: F
IH : forall L K F, btctx L K * -> member F K ->
       (exists X, F = tm X /\ name X)
H2 : member F nil
============================
 exists X, F = tm X /\ name X

Subgoal 2 is:
 exists X, F n1 = tm X /\ name X

btctx_mem1 < <b>case H2.</b>
</pre>
<a name="13"></a>
<pre class="code">
Subgoal 2:

Variables: F K1 L1
IH : forall L K F, btctx L K * -> member F K ->
       (exists X, F = tm X /\ name X)
H2 : member (F n1) (tm n1 :: K1)
H3 : btctx L1 K1 *
============================
 exists X, F n1 = tm X /\ name X

btctx_mem1 < <b>case H2.</b>
</pre>
<a name="14"></a>
<pre class="code">
Subgoal 2.1:

Variables: K1 L1
IH : forall L K F, btctx L K * -> member F K ->
       (exists X, F = tm X /\ name X)
H3 : btctx L1 K1 *
============================
 exists X, tm n1 = tm X /\ name X

Subgoal 2.2 is:
 exists X, F n1 = tm X /\ name X

btctx_mem1 < <b>search.</b>
</pre>
<a name="15"></a>
<pre class="code">
Subgoal 2.2:

Variables: F K1 L1
IH : forall L K F, btctx L K * -> member F K ->
       (exists X, F = tm X /\ name X)
H3 : btctx L1 K1 *
H4 : member (F n1) K1
============================
 exists X, F n1 = tm X /\ name X

btctx_mem1 < <b>apply IH to H3 H4.</b>
</pre>
<a name="16"></a>
<pre class="code">
Subgoal 2.2:

Variables: K1 L1 X
IH : forall L K F, btctx L K * -> member F K ->
       (exists X, F = tm X /\ name X)
H3 : btctx L1 K1 *
H4 : member (tm (X n1)) K1
H5 : name (X n1)
============================
 exists X1, tm (X n1) = tm X1 /\ name X1

btctx_mem1 < <b>search.</b>
Proof completed.
</pre>
<a name="17"></a>
<pre class="code">
Abella < <b>Theorem btctx_mem2 : 
forall L K F, btctx L K -> member F L -> (exists x, F = bred x x /\ name x).</b>

</pre>
<a name="18"></a>
<pre class="code">

============================
 forall L K F, btctx L K -> member F L -> (exists x, F = bred x x /\ name x)

btctx_mem2 < <b>induction on 1.</b>
</pre>
<a name="19"></a>
<pre class="code">

IH : forall L K F, btctx L K * -> member F L ->
       (exists x, F = bred x x /\ name x)
============================
 forall L K F, btctx L K @ -> member F L ->
   (exists x, F = bred x x /\ name x)

btctx_mem2 < <b>intros.</b>
</pre>
<a name="20"></a>
<pre class="code">

Variables: L K F
IH : forall L K F, btctx L K * -> member F L ->
       (exists x, F = bred x x /\ name x)
H1 : btctx L K @
H2 : member F L
============================
 exists x, F = bred x x /\ name x

btctx_mem2 < <b>case H1.</b>
</pre>
<a name="21"></a>
<pre class="code">
Subgoal 1:

Variables: F
IH : forall L K F, btctx L K * -> member F L ->
       (exists x, F = bred x x /\ name x)
H2 : member F nil
============================
 exists x, F = bred x x /\ name x

Subgoal 2 is:
 exists x, F n1 = bred x x /\ name x

btctx_mem2 < <b>case H2.</b>
</pre>
<a name="22"></a>
<pre class="code">
Subgoal 2:

Variables: F K1 L1
IH : forall L K F, btctx L K * -> member F L ->
       (exists x, F = bred x x /\ name x)
H2 : member (F n1) (bred n1 n1 :: L1)
H3 : btctx L1 K1 *
============================
 exists x, F n1 = bred x x /\ name x

btctx_mem2 < <b>case H2.</b>
</pre>
<a name="23"></a>
<pre class="code">
Subgoal 2.1:

Variables: K1 L1
IH : forall L K F, btctx L K * -> member F L ->
       (exists x, F = bred x x /\ name x)
H3 : btctx L1 K1 *
============================
 exists x, bred n1 n1 = bred x x /\ name x

Subgoal 2.2 is:
 exists x, F n1 = bred x x /\ name x

btctx_mem2 < <b>search.</b>
</pre>
<a name="24"></a>
<pre class="code">
Subgoal 2.2:

Variables: F K1 L1
IH : forall L K F, btctx L K * -> member F L ->
       (exists x, F = bred x x /\ name x)
H3 : btctx L1 K1 *
H4 : member (F n1) L1
============================
 exists x, F n1 = bred x x /\ name x

btctx_mem2 < <b>apply IH to H3 H4.</b>
</pre>
<a name="25"></a>
<pre class="code">
Subgoal 2.2:

Variables: K1 L1 x
IH : forall L K F, btctx L K * -> member F L ->
       (exists x, F = bred x x /\ name x)
H3 : btctx L1 K1 *
H4 : member (bred (x n1) (x n1)) L1
H5 : name (x n1)
============================
 exists x1, bred (x n1) (x n1) = bred x1 x1 /\ name x1

btctx_mem2 < <b>case H5.</b>
</pre>
<a name="26"></a>
<pre class="code">
Subgoal 2.2.1:

Variables: K1 L1
IH : forall L K F, btctx L K * -> member F L ->
       (exists x, F = bred x x /\ name x)
H3 : btctx (L1 n2) (K1 n2) *
H4 : member (bred n2 n2) (L1 n2)
============================
 exists x1, bred n2 n2 = bred x1 x1 /\ name x1

Subgoal 2.2.2 is:
 exists x1, bred n1 n1 = bred x1 x1 /\ name x1

btctx_mem2 < <b>search.</b>
</pre>
<a name="27"></a>
<pre class="code">
Subgoal 2.2.2:

Variables: K1 L1
IH : forall L K F, btctx L K * -> member F L ->
       (exists x, F = bred x x /\ name x)
H3 : btctx L1 K1 *
H4 : member (bred n1 n1) L1
============================
 exists x1, bred n1 n1 = bred x1 x1 /\ name x1

btctx_mem2 < <b>search.</b>
Proof completed.
</pre>
<a name="28"></a>
<pre class="code">
Abella < <b>Theorem btctx_sync : 
forall L K x, btctx L K -> member (tm x) K -> member (bred x x) L.</b>

</pre>
<a name="29"></a>
<pre class="code">

============================
 forall L K x, btctx L K -> member (tm x) K -> member (bred x x) L

btctx_sync < <b>induction on 1.</b>
</pre>
<a name="30"></a>
<pre class="code">

IH : forall L K x, btctx L K * -> member (tm x) K -> member (bred x x) L
============================
 forall L K x, btctx L K @ -> member (tm x) K -> member (bred x x) L

btctx_sync < <b>intros.</b>
</pre>
<a name="31"></a>
<pre class="code">

Variables: L K x
IH : forall L K x, btctx L K * -> member (tm x) K -> member (bred x x) L
H1 : btctx L K @
H2 : member (tm x) K
============================
 member (bred x x) L

btctx_sync < <b>case H1.</b>
</pre>
<a name="32"></a>
<pre class="code">
Subgoal 1:

Variables: x
IH : forall L K x, btctx L K * -> member (tm x) K -> member (bred x x) L
H2 : member (tm x) nil
============================
 member (bred x x) nil

Subgoal 2 is:
 member (bred (x n1) (x n1)) (bred n1 n1 :: L1)

btctx_sync < <b>case H2.</b>
</pre>
<a name="33"></a>
<pre class="code">
Subgoal 2:

Variables: x K1 L1
IH : forall L K x, btctx L K * -> member (tm x) K -> member (bred x x) L
H2 : member (tm (x n1)) (tm n1 :: K1)
H3 : btctx L1 K1 *
============================
 member (bred (x n1) (x n1)) (bred n1 n1 :: L1)

btctx_sync < <b>case H2.</b>
</pre>
<a name="34"></a>
<pre class="code">
Subgoal 2.1:

Variables: K1 L1
IH : forall L K x, btctx L K * -> member (tm x) K -> member (bred x x) L
H3 : btctx L1 K1 *
============================
 member (bred n1 n1) (bred n1 n1 :: L1)

Subgoal 2.2 is:
 member (bred (x n1) (x n1)) (bred n1 n1 :: L1)

btctx_sync < <b>search.</b>
</pre>
<a name="35"></a>
<pre class="code">
Subgoal 2.2:

Variables: x K1 L1
IH : forall L K x, btctx L K * -> member (tm x) K -> member (bred x x) L
H3 : btctx L1 K1 *
H4 : member (tm (x n1)) K1
============================
 member (bred (x n1) (x n1)) (bred n1 n1 :: L1)

btctx_sync < <b>apply IH to H3 H4.</b>
</pre>
<a name="36"></a>
<pre class="code">
Subgoal 2.2:

Variables: x K1 L1
IH : forall L K x, btctx L K * -> member (tm x) K -> member (bred x x) L
H3 : btctx L1 K1 *
H4 : member (tm (x n1)) K1
H5 : member (bred (x n1) (x n1)) L1
============================
 member (bred (x n1) (x n1)) (bred n1 n1 :: L1)

btctx_sync < <b>search.</b>
Proof completed.
</pre>
<a name="37"></a>
<pre class="code">
Abella < <b>Theorem bred_subst : 
forall L K R U N V, nabla x, btctx L K ->
  {L, bred x x |- bred (R x) (U x)} -> {L |- bred N V} ->
  {L |- bred (R N) (U V)}.</b>

</pre>
<a name="38"></a>
<pre class="code">

============================
 forall L K R U N V, nabla x, btctx L K ->
   {L, bred x x |- bred (R x) (U x)} -> {L |- bred N V} ->
   {L |- bred (R N) (U V)}

bred_subst < <b>induction on 2.</b>
</pre>
<a name="39"></a>
<pre class="code">

IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
============================
 forall L K R U N V, nabla x, btctx L K ->
   {L, bred x x |- bred (R x) (U x)}@ -> {L |- bred N V} ->
   {L |- bred (R N) (U V)}

bred_subst < <b>intros.</b>
</pre>
<a name="40"></a>
<pre class="code">

Variables: L K R U N V
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H2 : {L, bred n1 n1 |- bred (R n1) (U n1)}@
H3 : {L |- bred N V}
============================
 {L |- bred (R N) (U V)}

bred_subst < <b>case H2.</b>
</pre>
<a name="41"></a>
<pre class="code">
Subgoal 1:

Variables: L K N V U1 M
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H4 : {L, bred n1 n1, bred n2 n2 |- bred (M n1 n2) (U1 n1 n2)}*
============================
 {L |- bred (abs (M N)) (abs (U1 V))}

Subgoal 2 is:
 {L |- bred (app (M N) (N1 N)) (app (U1 V) (V1 V))}

Subgoal 3 is:
 {L |- bred (beta (R1 N) (N1 N)) (U V)}

Subgoal 4 is:
 {L |- bred (R N) (U V)}

bred_subst < <b>apply IH to _ H4 H3.</b>
</pre>
<a name="42"></a>
<pre class="code">
Subgoal 1:

Variables: L K N V U1 M
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H4 : {L, bred n1 n1, bred n2 n2 |- bred (M n1 n2) (U1 n1 n2)}*
H5 : {L, bred n2 n2 |- bred (M N n2) (U1 V n2)}
============================
 {L |- bred (abs (M N)) (abs (U1 V))}

Subgoal 2 is:
 {L |- bred (app (M N) (N1 N)) (app (U1 V) (V1 V))}

Subgoal 3 is:
 {L |- bred (beta (R1 N) (N1 N)) (U V)}

Subgoal 4 is:
 {L |- bred (R N) (U V)}

bred_subst < <b>search.</b>
</pre>
<a name="43"></a>
<pre class="code">
Subgoal 2:

Variables: L K N V V1 N1 U1 M
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H4 : {L, bred n1 n1 |- bred (M n1) (U1 n1)}*
H5 : {L, bred n1 n1 |- bred (N1 n1) (V1 n1)}*
============================
 {L |- bred (app (M N) (N1 N)) (app (U1 V) (V1 V))}

Subgoal 3 is:
 {L |- bred (beta (R1 N) (N1 N)) (U V)}

Subgoal 4 is:
 {L |- bred (R N) (U V)}

bred_subst < <b>apply IH to H1 H4 H3.</b>
</pre>
<a name="44"></a>
<pre class="code">
Subgoal 2:

Variables: L K N V V1 N1 U1 M
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H4 : {L, bred n1 n1 |- bred (M n1) (U1 n1)}*
H5 : {L, bred n1 n1 |- bred (N1 n1) (V1 n1)}*
H6 : {L |- bred (M N) (U1 V)}
============================
 {L |- bred (app (M N) (N1 N)) (app (U1 V) (V1 V))}

Subgoal 3 is:
 {L |- bred (beta (R1 N) (N1 N)) (U V)}

Subgoal 4 is:
 {L |- bred (R N) (U V)}

bred_subst < <b>apply IH to H1 H5 H3.</b>
</pre>
<a name="45"></a>
<pre class="code">
Subgoal 2:

Variables: L K N V V1 N1 U1 M
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H4 : {L, bred n1 n1 |- bred (M n1) (U1 n1)}*
H5 : {L, bred n1 n1 |- bred (N1 n1) (V1 n1)}*
H6 : {L |- bred (M N) (U1 V)}
H7 : {L |- bred (N1 N) (V1 V)}
============================
 {L |- bred (app (M N) (N1 N)) (app (U1 V) (V1 V))}

Subgoal 3 is:
 {L |- bred (beta (R1 N) (N1 N)) (U V)}

Subgoal 4 is:
 {L |- bred (R N) (U V)}

bred_subst < <b>search.</b>
</pre>
<a name="46"></a>
<pre class="code">
Subgoal 3:

Variables: L K U N V N1 R1
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H4 : {L, bred n1 n1 |- bred (R1 n1 (N1 n1)) (U n1)}*
============================
 {L |- bred (beta (R1 N) (N1 N)) (U V)}

Subgoal 4 is:
 {L |- bred (R N) (U V)}

bred_subst < <b>apply IH to H1 H4 H3.</b>
</pre>
<a name="47"></a>
<pre class="code">
Subgoal 3:

Variables: L K U N V N1 R1
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H4 : {L, bred n1 n1 |- bred (R1 n1 (N1 n1)) (U n1)}*
H5 : {L |- bred (R1 N (N1 N)) (U V)}
============================
 {L |- bred (beta (R1 N) (N1 N)) (U V)}

Subgoal 4 is:
 {L |- bred (R N) (U V)}

bred_subst < <b>search.</b>
</pre>
<a name="48"></a>
<pre class="code">
Subgoal 4:

Variables: L K R U N V F
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H4 : {L, bred n1 n1, [F n1] |- bred (R n1) (U n1)}*
H5 : member (F n1) (bred n1 n1 :: L)
============================
 {L |- bred (R N) (U V)}

bred_subst < <b>case H5.</b>
</pre>
<a name="49"></a>
<pre class="code">
Subgoal 4.1:

Variables: L K R U N V
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H4 : {L, bred n1 n1, [bred n1 n1] |- bred (R n1) (U n1)}*
============================
 {L |- bred (R N) (U V)}

Subgoal 4.2 is:
 {L |- bred (R N) (U V)}

bred_subst < <b>case H4.</b>
</pre>
<a name="50"></a>
<pre class="code">
Subgoal 4.1:

Variables: L K N V
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
============================
 {L |- bred N V}

Subgoal 4.2 is:
 {L |- bred (R N) (U V)}

bred_subst < <b>search.</b>
</pre>
<a name="51"></a>
<pre class="code">
Subgoal 4.2:

Variables: L K R U N V F
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H4 : {L, bred n1 n1, [F n1] |- bred (R n1) (U n1)}*
H6 : member (F n1) L
============================
 {L |- bred (R N) (U V)}

bred_subst < <b>apply btctx_mem2 to H1 H6.</b>
</pre>
<a name="52"></a>
<pre class="code">
Subgoal 4.2:

Variables: L K R U N V x
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H4 : {L, bred n1 n1, [bred (x n1) (x n1)] |- bred (R n1) (U n1)}*
H6 : member (bred (x n1) (x n1)) L
H7 : name (x n1)
============================
 {L |- bred (R N) (U V)}

bred_subst < <b>case H4.</b>
</pre>
<a name="53"></a>
<pre class="code">
Subgoal 4.2:

Variables: L K U N V
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H6 : member (bred (U n1) (U n1)) L
H7 : name (U n1)
============================
 {L |- bred (U N) (U V)}

bred_subst < <b>case H7.</b>
</pre>
<a name="54"></a>
<pre class="code">
Subgoal 4.2.1:

Variables: L K N V
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx (L n2) (K n2)
H3 : {L n2 |- bred (N n2) (V n2)}
H6 : member (bred n2 n2) (L n2)
============================
 {L n2 |- bred n2 n2}

Subgoal 4.2.2 is:
 {L |- bred N V}

bred_subst < <b>search.</b>
</pre>
<a name="55"></a>
<pre class="code">
Subgoal 4.2.2:

Variables: L K N V
IH : forall L K R U N V, nabla x, btctx L K ->
       {L, bred x x |- bred (R x) (U x)}* -> {L |- bred N V} ->
       {L |- bred (R N) (U V)}
H1 : btctx L K
H3 : {L |- bred N V}
H6 : member (bred n1 n1) L
============================
 {L |- bred N V}

bred_subst < <b>search.</b>
Proof completed.
</pre>
<a name="56"></a>
<pre class="code">
Abella < <b>Theorem bred_terminate : 
forall L K M, btctx L K -> {K |- tm M} -> (exists U, {L |- bred M U}).</b>

</pre>
<a name="57"></a>
<pre class="code">

============================
 forall L K M, btctx L K -> {K |- tm M} -> (exists U, {L |- bred M U})

bred_terminate < <b>induction on 2.</b>
</pre>
<a name="58"></a>
<pre class="code">

IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
============================
 forall L K M, btctx L K -> {K |- tm M}@ -> (exists U, {L |- bred M U})

bred_terminate < <b>intros.</b>
</pre>
<a name="59"></a>
<pre class="code">

Variables: L K M
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H2 : {K |- tm M}@
============================
 exists U, {L |- bred M U}

bred_terminate < <b>case H2.</b>
</pre>
<a name="60"></a>
<pre class="code">
Subgoal 1:

Variables: L K M1
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H3 : {K, tm n1 |- tm (M1 n1)}*
============================
 exists U, {L |- bred (abs M1) U}

Subgoal 2 is:
 exists U, {L |- bred (app M1 N) U}

Subgoal 3 is:
 exists U, {L |- bred (beta R N) U}

Subgoal 4 is:
 exists U, {L |- bred M U}

bred_terminate < <b>apply IH to _ H3.</b>
</pre>
<a name="61"></a>
<pre class="code">
Subgoal 1:

Variables: L K M1 U
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H3 : {K, tm n1 |- tm (M1 n1)}*
H4 : {L, bred n1 n1 |- bred (M1 n1) (U n1)}
============================
 exists U, {L |- bred (abs M1) U}

Subgoal 2 is:
 exists U, {L |- bred (app M1 N) U}

Subgoal 3 is:
 exists U, {L |- bred (beta R N) U}

Subgoal 4 is:
 exists U, {L |- bred M U}

bred_terminate < <b>search.</b>
</pre>
<a name="62"></a>
<pre class="code">
Subgoal 2:

Variables: L K N M1
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H3 : {K |- tm M1}*
H4 : {K |- tm N}*
============================
 exists U, {L |- bred (app M1 N) U}

Subgoal 3 is:
 exists U, {L |- bred (beta R N) U}

Subgoal 4 is:
 exists U, {L |- bred M U}

bred_terminate < <b>apply IH to H1 H3.</b>
</pre>
<a name="63"></a>
<pre class="code">
Subgoal 2:

Variables: L K N M1 U
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H3 : {K |- tm M1}*
H4 : {K |- tm N}*
H5 : {L |- bred M1 U}
============================
 exists U, {L |- bred (app M1 N) U}

Subgoal 3 is:
 exists U, {L |- bred (beta R N) U}

Subgoal 4 is:
 exists U, {L |- bred M U}

bred_terminate < <b>apply IH to H1 H4.</b>
</pre>
<a name="64"></a>
<pre class="code">
Subgoal 2:

Variables: L K N M1 U U1
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H3 : {K |- tm M1}*
H4 : {K |- tm N}*
H5 : {L |- bred M1 U}
H6 : {L |- bred N U1}
============================
 exists U, {L |- bred (app M1 N) U}

Subgoal 3 is:
 exists U, {L |- bred (beta R N) U}

Subgoal 4 is:
 exists U, {L |- bred M U}

bred_terminate < <b>search.</b>
</pre>
<a name="65"></a>
<pre class="code">
Subgoal 3:

Variables: L K R N
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H3 : {K |- tm N}*
H4 : {K, tm n1 |- tm (R n1)}*
============================
 exists U, {L |- bred (beta R N) U}

Subgoal 4 is:
 exists U, {L |- bred M U}

bred_terminate < <b>apply IH to _ H3.</b>
</pre>
<a name="66"></a>
<pre class="code">
Subgoal 3:

Variables: L K R N U
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H3 : {K |- tm N}*
H4 : {K, tm n1 |- tm (R n1)}*
H5 : {L |- bred N U}
============================
 exists U, {L |- bred (beta R N) U}

Subgoal 4 is:
 exists U, {L |- bred M U}

bred_terminate < <b>apply IH to _ H4.</b>
</pre>
<a name="67"></a>
<pre class="code">
Subgoal 3:

Variables: L K R N U U1
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H3 : {K |- tm N}*
H4 : {K, tm n1 |- tm (R n1)}*
H5 : {L |- bred N U}
H6 : {L, bred n1 n1 |- bred (R n1) (U1 n1)}
============================
 exists U, {L |- bred (beta R N) U}

Subgoal 4 is:
 exists U, {L |- bred M U}

bred_terminate < <b>apply bred_subst to H1 H6 H5.</b>
</pre>
<a name="68"></a>
<pre class="code">
Subgoal 3:

Variables: L K R N U U1
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H3 : {K |- tm N}*
H4 : {K, tm n1 |- tm (R n1)}*
H5 : {L |- bred N U}
H6 : {L, bred n1 n1 |- bred (R n1) (U1 n1)}
H7 : {L |- bred (R N) (U1 U)}
============================
 exists U, {L |- bred (beta R N) U}

Subgoal 4 is:
 exists U, {L |- bred M U}

bred_terminate < <b>search.</b>
</pre>
<a name="69"></a>
<pre class="code">
Subgoal 4:

Variables: L K M F
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H3 : {K, [F] |- tm M}*
H4 : member F K
============================
 exists U, {L |- bred M U}

bred_terminate < <b>apply btctx_mem1 to H1 H4.</b>
</pre>
<a name="70"></a>
<pre class="code">
Subgoal 4:

Variables: L K M X
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H3 : {K, [tm X] |- tm M}*
H4 : member (tm X) K
H5 : name X
============================
 exists U, {L |- bred M U}

bred_terminate < <b>case H3.</b>
</pre>
<a name="71"></a>
<pre class="code">
Subgoal 4:

Variables: L K M
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H4 : member (tm M) K
H5 : name M
============================
 exists U, {L |- bred M U}

bred_terminate < <b>apply btctx_sync to H1 H4.</b>
</pre>
<a name="72"></a>
<pre class="code">
Subgoal 4:

Variables: L K M
IH : forall L K M, btctx L K -> {K |- tm M}* -> (exists U, {L |- bred M U})
H1 : btctx L K
H4 : member (tm M) K
H5 : name M
H6 : member (bred M M) L
============================
 exists U, {L |- bred M U}

bred_terminate < <b>search.</b>
Proof completed.
</pre>
<a name="73"></a>
<pre class="code">
Abella < 
</pre>
</div>

</body>
</html>
