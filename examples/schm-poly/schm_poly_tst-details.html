
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Abella: Specification "schm_poly_tst". - Details</title>
<link href="http://abella-prover.org/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="http://abella-prover.org/images/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="http://abella-prover.org/images/favicon.ico"
        type="image/x-icon" />
</head>

<body>

<div id="logo-small">
<a href="http://abella-prover.org/index.html">
<img src="http://abella-prover.org/images/logo-small.png"/>
</a>
</div>

<div class="section">
Welcome to Abella 2.0.6-dev.
<a name="1"></a>
<pre class="code">
Abella < <b>Specification "schm_poly_tst".</b>
Reading specification "schm_poly_tst".

</pre>
<a name="2"></a>
<pre class="code">
Abella < <b>Define append : (list A) -> (list A) -> (list A) -> prop by 
append nil L L;
append (X :: L1) L2 (X :: L3) := append L1 L2 L3.</b>

</pre>
<a name="3"></a>
<pre class="code">
Abella < <b>Theorem append_det [A] : 
forall L1 L2 L3 L3', append L1 L2 L3 -> append L1 L2 L3' -> L3 = L3'.</b>

</pre>
<a name="4"></a>
<pre class="code">

============================
 forall L1 L2 L3 L3', append L1 L2 L3 -> append L1 L2 L3' -> L3 = L3'

append_det < <b>induction on 1.</b>
</pre>
<a name="5"></a>
<pre class="code">

IH : forall L1 L2 L3 L3', append L1 L2 L3 * -> append L1 L2 L3' -> L3 = L3'
============================
 forall L1 L2 L3 L3', append L1 L2 L3 @ -> append L1 L2 L3' -> L3 = L3'

append_det < <b>intros.</b>
</pre>
<a name="6"></a>
<pre class="code">

Variables: L1 L2 L3 L3'
IH : forall L1 L2 L3 L3', append L1 L2 L3 * -> append L1 L2 L3' -> L3 = L3'
H1 : append L1 L2 L3 @
H2 : append L1 L2 L3'
============================
 L3 = L3'

append_det < <b>case H1.</b>
</pre>
<a name="7"></a>
<pre class="code">
Subgoal 1:

Variables: L3 L3'
IH : forall L1 L2 L3 L3', append L1 L2 L3 * -> append L1 L2 L3' -> L3 = L3'
H2 : append nil L3 L3'
============================
 L3 = L3'

Subgoal 2 is:
 X :: L6 = L3'

append_det < <b>case H2.</b>
</pre>
<a name="8"></a>
<pre class="code">
Subgoal 1:

Variables: L3'
IH : forall L1 L2 L3 L3', append L1 L2 L3 * -> append L1 L2 L3' -> L3 = L3'
============================
 L3' = L3'

Subgoal 2 is:
 X :: L6 = L3'

append_det < <b>search.</b>
</pre>
<a name="9"></a>
<pre class="code">
Subgoal 2:

Variables: L2 L3' L6 X L4
IH : forall L1 L2 L3 L3', append L1 L2 L3 * -> append L1 L2 L3' -> L3 = L3'
H2 : append (X :: L4) L2 L3'
H3 : append L4 L2 L6 *
============================
 X :: L6 = L3'

append_det < <b>case H2.</b>
</pre>
<a name="10"></a>
<pre class="code">
Subgoal 2:

Variables: L2 L6 X L4 L8
IH : forall L1 L2 L3 L3', append L1 L2 L3 * -> append L1 L2 L3' -> L3 = L3'
H3 : append L4 L2 L6 *
H4 : append L4 L2 L8
============================
 X :: L6 = X :: L8

append_det < <b>apply IH to H3 H4.</b>
</pre>
<a name="11"></a>
<pre class="code">
Subgoal 2:

Variables: L2 X L4 L8
IH : forall L1 L2 L3 L3', append L1 L2 L3 * -> append L1 L2 L3' -> L3 = L3'
H3 : append L4 L2 L8 *
H4 : append L4 L2 L8
============================
 X :: L8 = X :: L8

append_det < <b>search.</b>
Proof completed.
</pre>
<a name="12"></a>
<pre class="code">
Abella < <b>Theorem oappend_det : 
forall L1 L2 L3 L3', append L1 L2 L3 -> append L1 L2 L3' -> L3 = L3'.</b>

</pre>
<a name="13"></a>
<pre class="code">

============================
 forall L1 L2 L3 L3', append L1 L2 L3 -> append L1 L2 L3' -> L3 = L3'

oappend_det < <b>intros.</b>
</pre>
<a name="14"></a>
<pre class="code">

Variables: L1 L2 L3 L3'
H1 : append L1 L2 L3
H2 : append L1 L2 L3'
============================
 L3 = L3'

oappend_det < <b>apply append_det[o] to H1 H2.</b>
</pre>
<a name="15"></a>
<pre class="code">

Variables: L1 L2 L3'
H1 : append L1 L2 L3'
H2 : append L1 L2 L3'
============================
 L3' = L3'

oappend_det < <b>search.</b>
Proof completed.
</pre>
<a name="16"></a>
<pre class="code">
Abella < <b>Theorem append_det1 [A] : 
forall L1 L2 L3 L3', append L1 L2 L3 -> append L1 L2 L3' -> L3 = L3'.</b>

</pre>
<a name="17"></a>
<pre class="code">

============================
 forall L1 L2 L3 L3', append L1 L2 L3 -> append L1 L2 L3' -> L3 = L3'

append_det1 < <b>intros.</b>
</pre>
<a name="18"></a>
<pre class="code">

Variables: L1 L2 L3 L3'
H1 : append L1 L2 L3
H2 : append L1 L2 L3'
============================
 L3 = L3'

append_det1 < <b>apply append_det[A] to H1 H2.</b>
</pre>
<a name="19"></a>
<pre class="code">

Variables: L1 L2 L3'
H1 : append L1 L2 L3'
H2 : append L1 L2 L3'
============================
 L3' = L3'

append_det1 < <b>search.</b>
Proof completed.
</pre>
<a name="20"></a>
<pre class="code">
Abella < <b>Theorem append_det2 [A] : 
forall L1 L2 L3 L3', append L1 L2 L3 -> append L1 L2 L3' -> L3 = L3'.</b>

</pre>
<a name="21"></a>
<pre class="code">

============================
 forall L1 L2 L3 L3', append L1 L2 L3 -> append L1 L2 L3' -> L3 = L3'

append_det2 < <b>intros.</b>
</pre>
<a name="22"></a>
<pre class="code">

Variables: L1 L2 L3 L3'
H1 : append L1 L2 L3
H2 : append L1 L2 L3'
============================
 L3 = L3'

append_det2 < <b>apply append_det[?302] to H1 H2.</b>
</pre>
<a name="23"></a>
<pre class="code">

Variables: L1 L2 L3'
H1 : append L1 L2 L3'
H2 : append L1 L2 L3'
============================
 L3' = L3'

append_det2 < <b>search.</b>
Proof completed.
</pre>
<a name="24"></a>
<pre class="code">
Abella < <b>Theorem append_det3 [A] : 
forall L1 L2 L3 L3', append L1 L2 L3 -> append L1 L2 L3' -> L3 = L3'.</b>

</pre>
<a name="25"></a>
<pre class="code">

============================
 forall L1 L2 L3 L3', append L1 L2 L3 -> append L1 L2 L3' -> L3 = L3'

append_det3 < <b>intros.</b>
</pre>
<a name="26"></a>
<pre class="code">

Variables: L1 L2 L3 L3'
H1 : append L1 L2 L3
H2 : append L1 L2 L3'
============================
 L3 = L3'

append_det3 < <b>apply append_det to H1 H2.</b>
</pre>
<a name="27"></a>
<pre class="code">

Variables: L1 L2 L3'
H1 : append L1 L2 L3'
H2 : append L1 L2 L3'
============================
 L3' = L3'

append_det3 < <b>search.</b>
Proof completed.
</pre>
<a name="28"></a>
<pre class="code">
Abella < <b>Type p A -> o.</b>

</pre>
<a name="29"></a>
<pre class="code">
Abella < <b>Define eq : A -> A -> prop by 
eq M M.</b>

</pre>
<a name="30"></a>
<pre class="code">
Abella < <b>Theorem tst [A,B] : 
forall X Y, eq (p X) (p Y) -> false.</b>

</pre>
<a name="31"></a>
<pre class="code">

============================
 forall X Y, eq (p X) (p Y) -> false

tst < <b>intros.</b>
</pre>
<a name="32"></a>
<pre class="code">

Variables: X Y
H1 : eq (p X) (p Y)
============================
 false

tst < <b>skip.</b>
Proof completed.
</pre>
<a name="33"></a>
<pre class="code">
Abella < <b>Theorem inst_gen_var1 [A,B] : 
forall X Y, p X = p Y -> false.</b>

</pre>
<a name="34"></a>
<pre class="code">

============================
 forall X Y, p X = p Y -> false

inst_gen_var1 < <b>intros.</b>
</pre>
<a name="35"></a>
<pre class="code">

Variables: X Y
H1 : p X = p Y
============================
 false

inst_gen_var1 < <b>skip.</b>
Proof completed.
</pre>
<a name="36"></a>
<pre class="code">
Abella < <b>Theorem inst_gen_var2 [A] : 
forall X Y, p X = p Y -> false.</b>

</pre>
<a name="37"></a>
<pre class="code">

============================
 forall X Y, p X = p Y -> false

inst_gen_var2 < <b>intros.</b>
</pre>
<a name="38"></a>
<pre class="code">

Variables: X Y
H1 : p X = p Y
============================
 false

inst_gen_var2 < <b>skip.</b>
Proof completed.
</pre>
<a name="39"></a>
<pre class="code">
Abella < <b>Theorem inst_gen_var3 [A] : 
forall X Y, p X = p Y -> false.</b>

</pre>
<a name="40"></a>
<pre class="code">

============================
 forall X Y, p X = p Y -> false

inst_gen_var3 < <b>intros.</b>
</pre>
<a name="41"></a>
<pre class="code">

Variables: X Y
H1 : p X = p Y
============================
 false

inst_gen_var3 < <b>case H1.</b>
Proof completed.
</pre>
<a name="42"></a>
<pre class="code">
Abella < <b>Theorem member_prune [A,B] : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').</b>

</pre>
<a name="43"></a>
<pre class="code">

============================
 forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

member_prune < <b>induction on 1.</b>
</pre>
<a name="44"></a>
<pre class="code">

IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
============================
 forall M L, nabla x, member (M x) L @ -> (exists M', M = y\M')

member_prune < <b>intros.</b>
</pre>
<a name="45"></a>
<pre class="code">

Variables: M L
IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
H1 : member (M n1) L @
============================
 exists M', M = y\M'

member_prune < <b>case H1.</b>
</pre>
<a name="46"></a>
<pre class="code">
Subgoal 1:

Variables: L3 L2
IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
============================
 exists M', z1\L2 = y\M'

Subgoal 2 is:
 exists M', M = y\M'

member_prune < <b>search.</b>
</pre>
<a name="47"></a>
<pre class="code">
Subgoal 2:

Variables: M L3 L2
IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
H2 : member (M n1) L3 *
============================
 exists M', M = y\M'

member_prune < <b>apply IH to H2.</b>
</pre>
<a name="48"></a>
<pre class="code">
Subgoal 2:

Variables: L3 L2 M'
IH : forall M L, nabla x, member (M x) L * -> (exists M', M = y\M')
H2 : member M' L3 *
============================
 exists M'1, z1\M' = y\M'1

member_prune < <b>search.</b>
Proof completed.
</pre>
<a name="49"></a>
<pre class="code">
Abella < <b>Theorem olist_mem_prune : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').</b>

</pre>
<a name="50"></a>
<pre class="code">

============================
 forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

olist_mem_prune < <b>intros.</b>
</pre>
<a name="51"></a>
<pre class="code">

Variables: M L
H1 : member (M n1) L
============================
 exists M', M = y\M'

olist_mem_prune < <b>apply member_prune[o,o] to H1.</b>
</pre>
<a name="52"></a>
<pre class="code">

Variables: L M'
H1 : member M' L
============================
 exists M'1, z1\M' = y\M'1

olist_mem_prune < <b>search.</b>
Proof completed.
</pre>
<a name="53"></a>
<pre class="code">
Abella < <b>Theorem member_prune1 [A,B] : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').</b>

</pre>
<a name="54"></a>
<pre class="code">

============================
 forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

member_prune1 < <b>intros.</b>
</pre>
<a name="55"></a>
<pre class="code">

Variables: M L
H1 : member (M n1) L
============================
 exists M', M = y\M'

member_prune1 < <b>apply member_prune[A,B] to H1.</b>
</pre>
<a name="56"></a>
<pre class="code">

Variables: L M'
H1 : member M' L
============================
 exists M'1, z1\M' = y\M'1

member_prune1 < <b>search.</b>
Proof completed.
</pre>
<a name="57"></a>
<pre class="code">
Abella < <b>Theorem member_prune2 [A,B] : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').</b>

</pre>
<a name="58"></a>
<pre class="code">

============================
 forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

member_prune2 < <b>intros.</b>
</pre>
<a name="59"></a>
<pre class="code">

Variables: M L
H1 : member (M n1) L
============================
 exists M', M = y\M'

member_prune2 < <b>apply member_prune[?450,B] to H1.</b>
</pre>
<a name="60"></a>
<pre class="code">

Variables: L M'
H1 : member M' L
============================
 exists M'1, z1\M' = y\M'1

member_prune2 < <b>search.</b>
Proof completed.
</pre>
<a name="61"></a>
<pre class="code">
Abella < <b>Theorem member_prune3 [A,B] : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').</b>

</pre>
<a name="62"></a>
<pre class="code">

============================
 forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

member_prune3 < <b>intros.</b>
</pre>
<a name="63"></a>
<pre class="code">

Variables: M L
H1 : member (M n1) L
============================
 exists M', M = y\M'

member_prune3 < <b>apply member_prune[?467,i] to H1.</b>
</pre>
<a name="64"></a>
<pre class="code">

Variables: L M'
H1 : member M' L
============================
 exists M'1, z1\M' = y\M'1

member_prune3 < <b>search.</b>
Proof completed.
</pre>
<a name="65"></a>
<pre class="code">
Abella < <b>Theorem member_prune4 [A,B] : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').</b>

</pre>
<a name="66"></a>
<pre class="code">

============================
 forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

member_prune4 < <b>intros.</b>
</pre>
<a name="67"></a>
<pre class="code">

Variables: M L
H1 : member (M n1) L
============================
 exists M', M = y\M'

member_prune4 < <b>apply member_prune to H1.</b>
</pre>
<a name="68"></a>
<pre class="code">

Variables: L M'
H1 : member M' L
============================
 exists M'1, z1\M' = y\M'1

member_prune4 < <b>search.</b>
Proof completed.
</pre>
<a name="69"></a>
<pre class="code">
Abella < <b>Theorem olist_mem_prune_bc : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').</b>

</pre>
<a name="70"></a>
<pre class="code">

============================
 forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

olist_mem_prune_bc < <b>intros.</b>
</pre>
<a name="71"></a>
<pre class="code">

Variables: M L
H1 : member (M n1) L
============================
 exists M', M = y\M'

olist_mem_prune_bc < <b>backchain member_prune[o,o].</b>
Proof completed.
</pre>
<a name="72"></a>
<pre class="code">
Abella < <b>Theorem member_prune1_bc [A,B] : 
forall M L, nabla x, member (M x) L -> (exists M', M = y\M').</b>

</pre>
<a name="73"></a>
<pre class="code">

============================
 forall M L, nabla x, member (M x) L -> (exists M', M = y\M')

member_prune1_bc < <b>intros.</b>
</pre>
<a name="74"></a>
<pre class="code">

Variables: M L
H1 : member (M n1) L
============================
 exists M', M = y\M'

member_prune1_bc < <b>backchain member_prune[A,B].</b>
Proof completed.
</pre>
<a name="75"></a>
<pre class="code">
Abella < <b>Theorem app_det [A] : 
forall L1 L2 L3 L3', {app L1 L2 L3} -> {app L1 L2 L3'} -> L3 = L3'.</b>

</pre>
<a name="76"></a>
<pre class="code">

============================
 forall L1 L2 L3 L3', {app L1 L2 L3} -> {app L1 L2 L3'} -> L3 = L3'

app_det < <b>induction on 1.</b>
</pre>
<a name="77"></a>
<pre class="code">

IH : forall L1 L2 L3 L3', {app L1 L2 L3}* -> {app L1 L2 L3'} -> L3 = L3'
============================
 forall L1 L2 L3 L3', {app L1 L2 L3}@ -> {app L1 L2 L3'} -> L3 = L3'

app_det < <b>intros.</b>
</pre>
<a name="78"></a>
<pre class="code">

Variables: L1 L2 L3 L3'
IH : forall L1 L2 L3 L3', {app L1 L2 L3}* -> {app L1 L2 L3'} -> L3 = L3'
H1 : {app L1 L2 L3}@
H2 : {app L1 L2 L3'}
============================
 L3 = L3'

app_det < <b>case H1 (keep).</b>
</pre>
<a name="79"></a>
<pre class="code">
Subgoal 1:

Variables: L3 L3'
IH : forall L1 L2 L3 L3', {app L1 L2 L3}* -> {app L1 L2 L3'} -> L3 = L3'
H1 : {app nil L3 L3}@
H2 : {app nil L3 L3'}
============================
 L3 = L3'

Subgoal 2 is:
 X :: L4 = L3'

app_det < <b>case H2.</b>
</pre>
<a name="80"></a>
<pre class="code">
Subgoal 1:

Variables: L3'
IH : forall L1 L2 L3 L3', {app L1 L2 L3}* -> {app L1 L2 L3'} -> L3 = L3'
H1 : {app nil L3' L3'}@
============================
 L3' = L3'

Subgoal 2 is:
 X :: L4 = L3'

app_det < <b>search.</b>
</pre>
<a name="81"></a>
<pre class="code">
Subgoal 2:

Variables: L2 L3' L4 L6 X
IH : forall L1 L2 L3 L3', {app L1 L2 L3}* -> {app L1 L2 L3'} -> L3 = L3'
H1 : {app (X :: L6) L2 (X :: L4)}@
H2 : {app (X :: L6) L2 L3'}
H3 : {app L6 L2 L4}*
============================
 X :: L4 = L3'

app_det < <b>case H2.</b>
</pre>
<a name="82"></a>
<pre class="code">
Subgoal 2:

Variables: L2 L4 L6 X L5
IH : forall L1 L2 L3 L3', {app L1 L2 L3}* -> {app L1 L2 L3'} -> L3 = L3'
H1 : {app (X :: L6) L2 (X :: L4)}@
H3 : {app L6 L2 L4}*
H4 : {app L6 L2 L5}
============================
 X :: L4 = X :: L5

app_det < <b>apply IH to H3 H4.</b>
</pre>
<a name="83"></a>
<pre class="code">
Subgoal 2:

Variables: L2 L6 X L5
IH : forall L1 L2 L3 L3', {app L1 L2 L3}* -> {app L1 L2 L3'} -> L3 = L3'
H1 : {app (X :: L6) L2 (X :: L5)}@
H3 : {app L6 L2 L5}*
H4 : {app L6 L2 L5}
============================
 X :: L5 = X :: L5

app_det < <b>search.</b>
Proof completed.
</pre>
<a name="84"></a>
<pre class="code">
Abella < <b>Theorem app_search [A] : 
forall X L, {app (X :: nil) L (X :: L)}.</b>

</pre>
<a name="85"></a>
<pre class="code">

============================
 forall X L, {app (X :: nil) L (X :: L)}

app_search < <b>search.</b>
Proof completed.
</pre>
<a name="86"></a>
<pre class="code">
Abella < <b>Theorem ty_fdet_left [A] : 
forall X, {pred (cst X)} -> true.</b>

</pre>
<a name="87"></a>
<pre class="code">

============================
 forall X, {pred (cst X)} -> true

ty_fdet_left < <b>intros.</b>
</pre>
<a name="88"></a>
<pre class="code">

Variables: X
H1 : {pred (cst X)}
============================
 true

ty_fdet_left < <b>case H1.</b>
</pre>
<a name="89"></a>
<pre class="code">

Variables: X
============================
 true

ty_fdet_left < <b>search.</b>
Proof completed.
</pre>
<a name="90"></a>
<pre class="code">
Abella < <b>Theorem ty_fdet_right [A] : 
forall X, {pred (cst X)}.</b>

</pre>
<a name="91"></a>
<pre class="code">

============================
 forall X, {pred (cst X)}

ty_fdet_right < <b>search.</b>
Proof completed.
</pre>
<a name="92"></a>
<pre class="code">
Abella < <b>Theorem ty_not_fdet_left : 
forall M, {pred M} -> false.</b>

</pre>
<a name="93"></a>
<pre class="code">

============================
 forall M, {pred M} -> false

ty_not_fdet_left < <b>intros.</b>
</pre>
<a name="94"></a>
<pre class="code">

Variables: M
H1 : {pred M}
============================
 false

ty_not_fdet_left < <b>skip.</b>
Proof completed.
</pre>
<a name="95"></a>
<pre class="code">
Abella < <b>Theorem ty_not_fdet_right : 
forall M, {pred M}.</b>

</pre>
<a name="96"></a>
<pre class="code">

============================
 forall M, {pred M}

ty_not_fdet_right < <b>skip.</b>
Proof completed.
</pre>
<a name="97"></a>
<pre class="code">
Abella < 
</pre>
</div>

</body>
</html>
