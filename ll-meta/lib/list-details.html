
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Abella: Type is_o  o -> prop. - Details</title>
<link href="http://abella-prover.org/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="http://abella-prover.org/images/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="http://abella-prover.org/images/favicon.ico"
        type="image/x-icon" />
</head>

<body>

<div id="logo-small">
<a href="http://abella-prover.org/index.html">
<img src="http://abella-prover.org/images/logo-small.png"/>
</a>
</div>

<div class="section">
Welcome to Abella 2.0.5-dev
<a name="1"></a>
<pre class="code">
Abella < <b>Type is_o o -> prop.</b>

</pre>
<a name="2"></a>
<pre class="code">
Abella < <b>Define is_list : (list o) -> prop by 
is_list nil;
is_list (A :: L) := is_o A /\ is_list L.</b>

</pre>
<a name="3"></a>
<pre class="code">
Abella < <b>Define append : (list o) -> (list o) -> (list o) -> prop by 
append nil L L := is_list L;
append (A :: J) K (A :: L) := is_o A /\ append J K L.</b>

</pre>
<a name="4"></a>
<pre class="code">
Abella < <b>Theorem append_1_is_list : 
forall J K L, append J K L -> is_list J.</b>

</pre>
<a name="5"></a>
<pre class="code">

============================
 forall J K L, append J K L -> is_list J

append_1_is_list < <b>induction on 1.</b>
</pre>
<a name="6"></a>
<pre class="code">

IH : forall J K L, append J K L * -> is_list J
============================
 forall J K L, append J K L @ -> is_list J

append_1_is_list < <b>intros.</b>
</pre>
<a name="7"></a>
<pre class="code">

Variables: J K L
IH : forall J K L, append J K L * -> is_list J
H1 : append J K L @
============================
 is_list J

append_1_is_list < <b>case H1.</b>
</pre>
<a name="8"></a>
<pre class="code">
Subgoal 1:

Variables: L
IH : forall J K L, append J K L * -> is_list J
H2 : is_list L
============================
 is_list nil

Subgoal 2 is:
 is_list (A :: J1)

append_1_is_list < <b>search.</b>
</pre>
<a name="9"></a>
<pre class="code">
Subgoal 2:

Variables: K L1 A J1
IH : forall J K L, append J K L * -> is_list J
H2 : is_o A
H3 : append J1 K L1 *
============================
 is_list (A :: J1)

append_1_is_list < <b>apply IH to H3.</b>
</pre>
<a name="10"></a>
<pre class="code">
Subgoal 2:

Variables: K L1 A J1
IH : forall J K L, append J K L * -> is_list J
H2 : is_o A
H3 : append J1 K L1 *
H4 : is_list J1
============================
 is_list (A :: J1)

append_1_is_list < <b>search.</b>
Proof completed.
</pre>
<a name="11"></a>
<pre class="code">
Abella < <b>Theorem append_2_is_list : 
forall J K L, append J K L -> is_list K.</b>

</pre>
<a name="12"></a>
<pre class="code">

============================
 forall J K L, append J K L -> is_list K

append_2_is_list < <b>induction on 1.</b>
</pre>
<a name="13"></a>
<pre class="code">

IH : forall J K L, append J K L * -> is_list K
============================
 forall J K L, append J K L @ -> is_list K

append_2_is_list < <b>intros.</b>
</pre>
<a name="14"></a>
<pre class="code">

Variables: J K L
IH : forall J K L, append J K L * -> is_list K
H1 : append J K L @
============================
 is_list K

append_2_is_list < <b>case H1.</b>
</pre>
<a name="15"></a>
<pre class="code">
Subgoal 1:

Variables: L
IH : forall J K L, append J K L * -> is_list K
H2 : is_list L
============================
 is_list L

Subgoal 2 is:
 is_list K

append_2_is_list < <b>search.</b>
</pre>
<a name="16"></a>
<pre class="code">
Subgoal 2:

Variables: K L1 A J1
IH : forall J K L, append J K L * -> is_list K
H2 : is_o A
H3 : append J1 K L1 *
============================
 is_list K

append_2_is_list < <b>apply IH to H3.</b>
</pre>
<a name="17"></a>
<pre class="code">
Subgoal 2:

Variables: K L1 A J1
IH : forall J K L, append J K L * -> is_list K
H2 : is_o A
H3 : append J1 K L1 *
H4 : is_list K
============================
 is_list K

append_2_is_list < <b>search.</b>
Proof completed.
</pre>
<a name="18"></a>
<pre class="code">
Abella < <b>Theorem append_3_is_list : 
forall J K L, append J K L -> is_list L.</b>

</pre>
<a name="19"></a>
<pre class="code">

============================
 forall J K L, append J K L -> is_list L

append_3_is_list < <b>induction on 1.</b>
</pre>
<a name="20"></a>
<pre class="code">

IH : forall J K L, append J K L * -> is_list L
============================
 forall J K L, append J K L @ -> is_list L

append_3_is_list < <b>intros.</b>
</pre>
<a name="21"></a>
<pre class="code">

Variables: J K L
IH : forall J K L, append J K L * -> is_list L
H1 : append J K L @
============================
 is_list L

append_3_is_list < <b>case H1.</b>
</pre>
<a name="22"></a>
<pre class="code">
Subgoal 1:

Variables: L
IH : forall J K L, append J K L * -> is_list L
H2 : is_list L
============================
 is_list L

Subgoal 2 is:
 is_list (A :: L1)

append_3_is_list < <b>search.</b>
</pre>
<a name="23"></a>
<pre class="code">
Subgoal 2:

Variables: K L1 A J1
IH : forall J K L, append J K L * -> is_list L
H2 : is_o A
H3 : append J1 K L1 *
============================
 is_list (A :: L1)

append_3_is_list < <b>apply IH to H3.</b>
</pre>
<a name="24"></a>
<pre class="code">
Subgoal 2:

Variables: K L1 A J1
IH : forall J K L, append J K L * -> is_list L
H2 : is_o A
H3 : append J1 K L1 *
H4 : is_list L1
============================
 is_list (A :: L1)

append_3_is_list < <b>search.</b>
Proof completed.
</pre>
<a name="25"></a>
<pre class="code">
Abella < <b>Theorem can_append : 
forall J K, is_list J -> is_list K -> (exists L, append J K L).</b>

</pre>
<a name="26"></a>
<pre class="code">

============================
 forall J K, is_list J -> is_list K -> (exists L, append J K L)

can_append < <b>induction on 1.</b>
</pre>
<a name="27"></a>
<pre class="code">

IH : forall J K, is_list J * -> is_list K -> (exists L, append J K L)
============================
 forall J K, is_list J @ -> is_list K -> (exists L, append J K L)

can_append < <b>intros.</b>
</pre>
<a name="28"></a>
<pre class="code">

Variables: J K
IH : forall J K, is_list J * -> is_list K -> (exists L, append J K L)
H1 : is_list J @
H2 : is_list K
============================
 exists L, append J K L

can_append < <b>case H1.</b>
</pre>
<a name="29"></a>
<pre class="code">
Subgoal 1:

Variables: K
IH : forall J K, is_list J * -> is_list K -> (exists L, append J K L)
H2 : is_list K
============================
 exists L, append nil K L

Subgoal 2 is:
 exists L1, append (A :: L) K L1

can_append < <b>search.</b>
</pre>
<a name="30"></a>
<pre class="code">
Subgoal 2:

Variables: K L A
IH : forall J K, is_list J * -> is_list K -> (exists L, append J K L)
H2 : is_list K
H3 : is_o A
H4 : is_list L *
============================
 exists L1, append (A :: L) K L1

can_append < <b>apply IH to H4 H2.</b>
</pre>
<a name="31"></a>
<pre class="code">
Subgoal 2:

Variables: K L A L1
IH : forall J K, is_list J * -> is_list K -> (exists L, append J K L)
H2 : is_list K
H3 : is_o A
H4 : is_list L *
H5 : append L K L1
============================
 exists L1, append (A :: L) K L1

can_append < <b>search.</b>
Proof completed.
</pre>
<a name="32"></a>
<pre class="code">
Abella < <b>Define rev : (list o) -> (list o) -> prop by 
rev nil nil;
rev (A :: J) L := exists K, rev J K /\ append K (A :: nil) L.</b>

</pre>
<a name="33"></a>
<pre class="code">
Abella < <b>Theorem rev_1_is_list : 
forall J K, rev J K -> is_list J.</b>

</pre>
<a name="34"></a>
<pre class="code">

============================
 forall J K, rev J K -> is_list J

rev_1_is_list < <b>induction on 1.</b>
</pre>
<a name="35"></a>
<pre class="code">

IH : forall J K, rev J K * -> is_list J
============================
 forall J K, rev J K @ -> is_list J

rev_1_is_list < <b>intros.</b>
</pre>
<a name="36"></a>
<pre class="code">

Variables: J K
IH : forall J K, rev J K * -> is_list J
H1 : rev J K @
============================
 is_list J

rev_1_is_list < <b>case H1.</b>
</pre>
<a name="37"></a>
<pre class="code">
Subgoal 1:

IH : forall J K, rev J K * -> is_list J
============================
 is_list nil

Subgoal 2 is:
 is_list (A :: J1)

rev_1_is_list < <b>search.</b>
</pre>
<a name="38"></a>
<pre class="code">
Subgoal 2:

Variables: K K1 J1 A
IH : forall J K, rev J K * -> is_list J
H2 : rev J1 K1 *
H3 : append K1 (A :: nil) K
============================
 is_list (A :: J1)

rev_1_is_list < <b>apply IH to H2.</b>
</pre>
<a name="39"></a>
<pre class="code">
Subgoal 2:

Variables: K K1 J1 A
IH : forall J K, rev J K * -> is_list J
H2 : rev J1 K1 *
H3 : append K1 (A :: nil) K
H4 : is_list J1
============================
 is_list (A :: J1)

rev_1_is_list < <b>apply append_2_is_list to H3.</b>
</pre>
<a name="40"></a>
<pre class="code">
Subgoal 2:

Variables: K K1 J1 A
IH : forall J K, rev J K * -> is_list J
H2 : rev J1 K1 *
H3 : append K1 (A :: nil) K
H4 : is_list J1
H5 : is_list (A :: nil)
============================
 is_list (A :: J1)

rev_1_is_list < <b>case H5.</b>
</pre>
<a name="41"></a>
<pre class="code">
Subgoal 2:

Variables: K K1 J1 A
IH : forall J K, rev J K * -> is_list J
H2 : rev J1 K1 *
H3 : append K1 (A :: nil) K
H4 : is_list J1
H6 : is_o A
H7 : is_list nil
============================
 is_list (A :: J1)

rev_1_is_list < <b>search.</b>
Proof completed.
</pre>
<a name="42"></a>
<pre class="code">
Abella < <b>Theorem rev_2_is_list : 
forall J K, rev J K -> is_list K.</b>

</pre>
<a name="43"></a>
<pre class="code">

============================
 forall J K, rev J K -> is_list K

rev_2_is_list < <b>intros.</b>
</pre>
<a name="44"></a>
<pre class="code">

Variables: J K
H1 : rev J K
============================
 is_list K

rev_2_is_list < <b>case H1.</b>
</pre>
<a name="45"></a>
<pre class="code">
Subgoal 1:

============================
 is_list nil

Subgoal 2 is:
 is_list K

rev_2_is_list < <b>search.</b>
</pre>
<a name="46"></a>
<pre class="code">
Subgoal 2:

Variables: K K1 J1 A
H2 : rev J1 K1
H3 : append K1 (A :: nil) K
============================
 is_list K

rev_2_is_list < <b>apply append_3_is_list to H3.</b>
</pre>
<a name="47"></a>
<pre class="code">
Subgoal 2:

Variables: K K1 J1 A
H2 : rev J1 K1
H3 : append K1 (A :: nil) K
H4 : is_list K
============================
 is_list K

rev_2_is_list < <b>search.</b>
Proof completed.
</pre>
<a name="48"></a>
<pre class="code">
Abella < <b>Theorem can_rev : 
forall J, is_list J -> (exists K, rev J K).</b>

</pre>
<a name="49"></a>
<pre class="code">

============================
 forall J, is_list J -> (exists K, rev J K)

can_rev < <b>induction on 1.</b>
</pre>
<a name="50"></a>
<pre class="code">

IH : forall J, is_list J * -> (exists K, rev J K)
============================
 forall J, is_list J @ -> (exists K, rev J K)

can_rev < <b>intros.</b>
</pre>
<a name="51"></a>
<pre class="code">

Variables: J
IH : forall J, is_list J * -> (exists K, rev J K)
H1 : is_list J @
============================
 exists K, rev J K

can_rev < <b>case H1.</b>
</pre>
<a name="52"></a>
<pre class="code">
Subgoal 1:

IH : forall J, is_list J * -> (exists K, rev J K)
============================
 exists K, rev nil K

Subgoal 2 is:
 exists K, rev (A :: L) K

can_rev < <b>search.</b>
</pre>
<a name="53"></a>
<pre class="code">
Subgoal 2:

Variables: L A
IH : forall J, is_list J * -> (exists K, rev J K)
H2 : is_o A
H3 : is_list L *
============================
 exists K, rev (A :: L) K

can_rev < <b>apply IH to H3.</b>
</pre>
<a name="54"></a>
<pre class="code">
Subgoal 2:

Variables: L A K
IH : forall J, is_list J * -> (exists K, rev J K)
H2 : is_o A
H3 : is_list L *
H4 : rev L K
============================
 exists K, rev (A :: L) K

can_rev < <b>apply can_append to _ _ with J = K, K = A :: nil.</b>
</pre>
<a name="55"></a>
<pre class="code">
Subgoal 2.1:

Variables: L A K
IH : forall J, is_list J * -> (exists K, rev J K)
H2 : is_o A
H3 : is_list L *
H4 : rev L K
============================
 is_list K

Subgoal 2 is:
 exists K, rev (A :: L) K

can_rev < <b>apply rev_2_is_list to H4.</b>
</pre>
<a name="56"></a>
<pre class="code">
Subgoal 2.1:

Variables: L A K
IH : forall J, is_list J * -> (exists K, rev J K)
H2 : is_o A
H3 : is_list L *
H4 : rev L K
H5 : is_list K
============================
 is_list K

Subgoal 2 is:
 exists K, rev (A :: L) K

can_rev < <b>search.</b>
</pre>
<a name="57"></a>
<pre class="code">
Subgoal 2:

Variables: L A K L1
IH : forall J, is_list J * -> (exists K, rev J K)
H2 : is_o A
H3 : is_list L *
H4 : rev L K
H5 : append K (A :: nil) L1
============================
 exists K, rev (A :: L) K

can_rev < <b>search.</b>
Proof completed.
</pre>
<a name="58"></a>
<pre class="code">
Abella < 
</pre>
</div>

</body>
</html>
